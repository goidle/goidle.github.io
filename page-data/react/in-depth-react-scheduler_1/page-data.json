{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react-scheduler_1/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"75244c3b-7b72-5197-8966-2fd9fc19c117","excerpt":"모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 사용자가 컴포넌트의 상태를 업데이트하기 위해 를 사용했을 때 이 함수에서 에 를 연결하고 마지막에 업데이트를 반영하기 위해 Work를 로 스케줄링시켰습니다. 이번 포스트에서는 를 시작으로 scheduler의 전반적인 흐름을 알아볼 것입니다. 리액트의 scheduler는 push 방식이 아닌 pull 방식입니다. 이 말이 무슨 뜻이냐면 Work…","html":"<blockquote>\n<p>모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.</p>\n</blockquote>\n<p>사용자가 컴포넌트의 상태를 업데이트하기 위해 <code class=\"language-text\">dispatchAction()</code>를 사용했을 때 이 함수에서 <code class=\"language-text\">queue</code>에 <code class=\"language-text\">update</code>를 연결하고 마지막에 업데이트를 반영하기 위해 Work를 <code class=\"language-text\">scheduleWork()</code>로 스케줄링시켰습니다. 이번 포스트에서는 <code class=\"language-text\">shceduleWork()</code>를 시작으로 scheduler의 전반적인 흐름을 알아볼 것입니다.</p>\n<p>리액트의 scheduler는 push 방식이 아닌 pull 방식입니다. 이 말이 무슨 뜻이냐면 Work의 실행 제어권을 좀 더 똑똑한 scheduler에게 위임하는 겁니다. reconciler가 스스로 판단해서 Work를 실행하는 게 아닌 이 부분에서 좀 더 똑똑한 scheduler가 브라우저의 상태와 여러 조건을 기반으로 실행하기 적절할 때 스스로 판단해서 Work를 실행하는 걸 뜻합니다.</p>\n<p>다음은 우리가 알아볼 스케줄링 흐름도입니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 790px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaElEQVQoz6VTXXODMAzj//9KXnq9G6OFUPJta3Io0G3d03KnMwHHluTQqSrewdYwDOj7HpfLBdfrtUV7Z98rISVhGS6YZoecc3vfHQV2AG0vKvhrLTnhI3rMjMdSnAWFG8/ziQ+xVKwlw5XCgxk+JczJCgSM3mN4LJhSxMycWCs8i4ZaUEUaoc44aU2ocaSEFbUEiFQoYbHUzOTaGNu+skgxVTznrSmbWTwLGsM4QZceEgaUMKFEB/H0Ki9stECLZ86dkfuwojweABlnMhYy3W1qkkVKK2L2lcRkPxI31Bwai01B2BqkOxuEVlDdDFA+QjiGqLvkmj0T3WauGU0JBqVX0jzehqQGpti4hBKbFXWzwaCnh/xgndlNJkpbHOL4icDniQ1Gm+pzEI55t+BxsyExOr9ico5Ew/dr0zpbXCnHvCEDJWyCgWxbfE5TD9Z62HJK/nmpd9+eCb/W6+V/80N0u/7XSf0HXxOEYWAsL3OCAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"scheduling flow\" title=\"scheduling flow\" src=\"/static/9e327099e752bd46cae5074351cfbe5c/c94d1/scheduling_flow.png\" srcset=\"/static/9e327099e752bd46cae5074351cfbe5c/0780f/scheduling_flow.png 198w,\n/static/9e327099e752bd46cae5074351cfbe5c/47b26/scheduling_flow.png 395w,\n/static/9e327099e752bd46cae5074351cfbe5c/c94d1/scheduling_flow.png 790w,\n/static/9e327099e752bd46cae5074351cfbe5c/9e288/scheduling_flow.png 1185w,\n/static/9e327099e752bd46cae5074351cfbe5c/9adaa/scheduling_flow.png 1580w,\n/static/9e327099e752bd46cae5074351cfbe5c/bf7ce/scheduling_flow.png 2560w\" sizes=\"(max-width: 790px) 100vw, 790px\" loading=\"lazy\">\n    </span>\n<p>흐름도를 보면 함수들이 같은 패키지에 있는 게 아닙니다. 패키지가 다르다는 건 하는 일이 완전히 다르다는 걸 뜻합니다.<br>\n들어가기 전 이 부분을 미리 생각해서 각 섹션을 시작하시면 좀 더 따라가기 편하실 것 같습니다.<br>\nreconciler는 VDOM 재조정 작업 전에 설정해줘야 하는 부분들이 주를 이룰 것이고 scheduler는 스케줄링 된 Task에 우선순위 반영과 실행하기 적절한 때를 판단하고 작업의 진행과 중단을 담당하는 코드들이 주를 이룰 것입니다.</p>\n<p>추가로 scheduler 중에 host config가 있는데 이 부분은 사용자의 호스트 환경에 맞는 api를 사용하기 위한 모듈입니다. 여기에는 비동기 api, performance, <a href=\"https://wicg.github.io/is-input-pending/\" target=\"_blank\">isInputPending</a> 등이 있습니다.</p>\n<a id=\"is-input-pending\">\n<blockquote>\n<h3 id=\"isinputpending\"><a href=\"#isinputpending\" aria-label=\"isinputpending permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>isInputPending</h3>\n<p>Facebook이 처음으로 기여한 브라우저 API로 이름 그대로 자바스크립트에서 알 수 없었던 대기 중인 input event가 있는지 확인할 수 있습니다. 이를 이용하여 자바스크립트가 메인 스레드를 계속해서 점유하고 있어도 되는지 판단할 수 있습니다.<br>\n리액트는 이 API가 어떤 상황일 때 필요했냐면 concurrent mode에서 VDOM 재조정 작업을 할 때 혹시 있을지 모를 브라우저의 페인트 작업이나 사용자의 input event를 처리하기 위해 할당된 시간이 지나면 잠시 콜스택을 비워주었습니다. 굳이 브라우저가 필요하지 않은 상황인데도 이런 불필요한 동작을 계속할 수 밖에 없었습니다.<br>\n이제 isInputPending api를 이용하여 브라우저가 메인 스레드의 점유가 필요할 때만 작업을 잠시 멈춰 브라우저에게 양보를 하고 그럴 필요가 없다면 VDOM 재조정 작업을 계속해서 동기적으로 진행할 수 있습니다.</p>\n</blockquote>\n<h1 id=\"1-dispatchaction\"><a href=\"#1-dispatchaction\" aria-label=\"1 dispatchaction permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. dispatchAction</h1>\n<p>해당 함수는 Hooks에서 이미 자세히 알아보았습니다. 다만 한가지 꺼림칙한 부분은 render phase에서 호출되는 <code class=\"language-text\">dispatchAction()</code>은 따로 <code class=\"language-text\">scheduleWork()</code>를 통해 Work를 스케줄링하지 않았고 idle 상태에서의 호출일 때만 작업을 스케줄링했습니다. 근데 로직만 보면 idle 상태에서의 매 <code class=\"language-text\">dispatchAction()</code> 호출마다 <code class=\"language-text\">scheduleWork()</code>도 같이 동작합니다. 이러면 같은 컴포넌트에 대한 복수의 Work가 스케줄링 되지 않을까요? 이 부분을 리액트에서는 어떻게 처리했는지 바로 다음 <code class=\"language-text\">scheduleWork</code> 섹션에서 확인해 보도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">dispatchAction</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>render phase update<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// idle update..</span>\n    <span class=\"token function\">scheduleWork</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">,</span> expirationTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"2-schedulework\"><a href=\"#2-schedulework\" aria-label=\"2 schedulework permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. scheduleWork</h1>\n<p>코드는 ReactFiberWorkLoop.js에 <code class=\"language-text\">scheduleUpdateOnFiber()</code> 이름으로 정의되어 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> scheduleWork <span class=\"token operator\">=</span> scheduleUpdateOnFiber</code></pre></div>\n<h2 id=\"reconciler가-해야하는-일\"><a href=\"#reconciler%EA%B0%80-%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%BC\" aria-label=\"reconciler가 해야하는 일 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reconciler가 해야하는 일</h2>\n<p>재조정 작업을 스케줄링하기 전에 reconciler에서 해야 할 일은 다음과 같습니다.</p>\n<ol>\n<li>해당 컴포넌트에서 이벤트가 발생했음을 알리는 expirationTime을 새긴다.</li>\n<li>이벤트가 발생한 컴포넌트의 VDOM root을 가지고 온다.</li>\n<li>스케줄링 정보를 저장한다.</li>\n</ol>\n<p>현 상황에서 root가 왜 필요한지를 먼저 보자면 리액트를 레거시 코드에 도입한다고 했을 때 여러 root를 가지고 있을 수 있습니다. 그리고 그 root마다 개별적으로 VDOM을 생성하겠죠. 제가 하고 싶은 말은 하나의 VDOM을 나타내는 변하지 않는 유일한 값은 root 객체라는 말입니다. 그리고 Work는 VDOM 전체를 관통하는 이벤트로 해당 VDOM과 1:1 의존성을 가지고 있는 작업입니다. 그런데 여기서 하나의 VDOM에 여러 업데이트가 발생하여 복수의 Work가 스케줄링 되어야 하는 상황이 있을 수 있습니다. 이때 교통정리가 필요한데 그 역할을 reconciler가 담당하고, 정리의 기준은 Work를 스케줄링시켰던 정보를 이용하여 판단합니다. 그래서 VDOM을 대표하는 root에 이 스케줄링 정보를 저장합니다. 이 내용이 3번, 스케줄링 정보를 scheduler만 알고 있지 않고 따로 저장해놓는 이유입니다.</p>\n<p>2번의 경우 위 이유로 root가 필요하기도 하고 VDOM 재조정 작업의 시작과 끝은 항상 root이기 때문에 Work 함수를 넘겨줄때 root의 정보가 필요하기도 합니다.</p>\n<p>스케줄링 정보가 필요한 이유가 VDOM 입장에서의 거시적인 느낌이 있다면 expirationTime이 필요한 이유는 컴포넌트와 관련된 미시적인 느낌이 있습니다. fiber에 expirationTime이 새겨졌다는 건 해당 컴포넌트에서 이벤트가 발생했다는 의미로 이 의미를 가지고 리액트 곳곳에서 처리할 수 있는 사례들이 있습니다. 이 부분은 이번 포스트와 다음 포스트인 reconciler에서 차차 알아보도록 하겠습니다.</p>\n<h2 id=\"expirationtime-새기기\"><a href=\"#expirationtime-%EC%83%88%EA%B8%B0%EA%B8%B0\" aria-label=\"expirationtime 새기기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>expirationTime 새기기</h2>\n<p>먼저 expirationTime을 어떻게 새기는지 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber()</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">scheduleUpdateOnFiber</span><span class=\"token punctuation\">(</span>\n  fiber<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 업데이트가 발생한 컴포넌트</span>\n  expirationTime\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// expirationTime을 새기고 root를 가지고 온다.</span>\n  <span class=\"token keyword\">const</span> root <span class=\"token operator\">=</span> <span class=\"token function\">markUpdateTimeFromFiberToRoot</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">,</span> expirationTime<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 업데이트가 발생한 fiber에 <code class=\"language-text\">expirationTime</code>을 새깁니다. 그리고 root를 찾기 위해 fiber의 부모부터 시작해 위로 위로 올라가 root까지 도달하게 된다면 root를 반환할 텐데 이 과정에서 거쳐 가는 fiber에도 시간을 새깁니다. 이 시간을 expirationTime으로 새기지 않고 <code class=\"language-text\">childExpirationTime</code>으로 새깁니다.<br>\n그리고 이 부분은 재조정 작업에서 매우 중요하게 사용됩니다. 자세한 내용은 다음 포스트인 reconciler에서 다루고 지금은 그냥 <u>자식에서 업데이트가 발생하면 자신에게 childExpirationTime이 새겨진다.</u> 라고만 알고 있겠습니다.</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"ts\"><pre style=\"counter-reset: linenumber 0\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber() > markUpdateTimeFromFiberToRoot()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">markUpdateTimeFromFiberToRoot</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber<span class=\"token punctuation\">,</span> expirationTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// expirationTime을 새긴다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">&lt;</span> expirationTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fiber<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">=</span> expirationTime\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> alternate <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>alternate\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>alternate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> alternate<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">&lt;</span> expirationTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    alternate<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">=</span> expirationTime\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// root를 찾아 위로 올라간다.</span>\n  <span class=\"token keyword\">let</span> node <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span><span class=\"token keyword\">return</span>\n  <span class=\"token keyword\">let</span> root <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> fiber<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> HostRoot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    root <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>stateNode</span>  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      alternate <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>alternate\n      <span class=\"token comment\">// 이하 childExpirationTime를 새긴다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">&lt;</span> expirationTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        node<span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">=</span> expirationTime\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n          alternate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n          alternate<span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">&lt;</span> expirationTime\n        <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          alternate<span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">=</span> expirationTime\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n        alternate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n        alternate<span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">&lt;</span> expirationTime\n      <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        alternate<span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">=</span> expirationTime\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// root 라면</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span><span class=\"token keyword\">return</span> <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">===</span> HostRoot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">        root <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>stateNode</span>        <span class=\"token keyword\">break</span>\n      <span class=\"token punctuation\">}</span>\n      node <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> root\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>계속해서 말씀드리는 부분이지만 current와 workInprogress 모두 처리해주고 있습니다. 왜일까요?<br>\n현재 우리는 어떤 함수의 호출부터 시작해서 여기까지 왔습니까? dispatchAction()입니다. 그리고 그 당시에 workInProgress였던 fiber를 bind로 잡아두었습니다. 그 fiber가 지금 여기까지 인자로 넘어오고 있는 것입니다. 이 정도 설명이면 위 질문에 대답할 수 있을 것이고 그렇지 못하다면 <a href=\"/react/in-depth-react-hooks_1/#dispatchAction()\">여기</a>를 다시 읽고 오시면 되겠습니다.</p>\n<p>15, 36 라인이 root를 반환하는 코드입니다. 해당 라인에서의 fiber는 current 혹은 workInProgress의 최상단 fiber(e.g. &#x3C;App/>) 입니다. 그리고 최상단 fiber에서 <code class=\"language-text\">stateNode</code>로 root를 참조하고 있습니다. current와 workInProgress의 stateNode는 같은 root를 바라봅니다. 당연히 VDOM에는 하나의 root만 존재하므로.</p>\n<p>현재 업데이트가 발생한 fiber에는 expirationTime을 부모부터 root까지는 childExpirationTime을 새겼으며 동시에 root를 찾아 반환했습니다.</p>\n<h2 id=\"work를-동기로-처리할-수-있는지-확인하기\"><a href=\"#work%EB%A5%BC-%EB%8F%99%EA%B8%B0%EB%A1%9C-%EC%B2%98%EB%A6%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"work를 동기로 처리할 수 있는지 확인하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Work를 동기로 처리할 수 있는지 확인하기</h2>\n<anchor id=\"flushSyncCallbackQueue()\" />\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber 0\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberHooks.js > ReactFiberWorkLoop.js > scheduleUpdateOnFiber()</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">scheduleUpdateOnFiber</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);</span>\n  <span class=\"token comment\">// 동기</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expirationTime <span class=\"token operator\">===</span> Sync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// VDOM 마운트</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> LegacyUnbatchedContext<span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> NoContext <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>RenderContext <span class=\"token operator\">|</span> CommitContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> NoContext\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">performSyncWorkOnRoot</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// VDOM 업데이트</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">ensureRootIsScheduled</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">===</span> NoContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">flushSyncCallbackQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 비동기</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">ensureRootIsScheduled</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// discrete event 코드 생략..</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>라인별로 알아보겠습니다.<br>\n5에서 먼저 동기로 처리되어야 하는지 판단합니다.<br>\n8, 9의 조건은 VDOM이 처음 생성될 때 충족합니다. 처음 생성될 때는 Work를 굳이 다음 틱으로 넘길 필요 없이 바로 실행해서 VDOM을 완성해줍니다. 동기로 재조정 작업을 수행해줄 함수가 바로 <code class=\"language-text\">performSyncWorkOnRoot()</code><up>11</up>입니다.<br>\n13 <code class=\"language-text\">ensureRootIsScheduled</code>를 통해 업데이트가 발생한 root에 Work를 스케줄링시켜줍니다.<br>\n15번을 통해 리액트가 놀고 있는 걸 확인하면 <code class=\"language-text\">flushSyncCallbackQueue()</code>를 통해 sync queue에 담겨 있는 Work들을 바로 실행시켜 줍니다. 이 부분은 <code class=\"language-text\">ensureRootIsScheduled()</code>에서 동기 Work를 어떻게 처리하는지 확인하면 이해하시기 편하실 겁니다.\n20 비동기 작업도 <code class=\"language-text\">ensureRootIsScheduled()</code>를 이용합니다.</p>\n<p>잠시 혼동을 방지하기 위해 함수들의 역할을 좀 더 구분 지어서 생각하고 넘어가겠습니다.<br>\n스케줄링과 관련된 본격적인 코드는 ensureRootIsScheduled에 다 담겨 있습니다. 함수 이름을 보면 ensure<strong>‘Root’</strong>Is<strong>‘Shceduled’</strong>입니다. root에 Work을 스케줄링하는 코드들이 위치해 있을 법한 이름입니다.</p>\n<p>scheduleWork는 위에서 봤듯이 스케줄링 전과 후에 reconciler 입장에서의 추가 작업 코드들이 존재합니다. 실제 스케줄링 코드는 없습니다. 생략된 discrete event 코드는 SyntheticEvent 포스트에서 다룹니다.</p>\n<h1 id=\"3-ensurerootisscheduled\"><a href=\"#3-ensurerootisscheduled\" aria-label=\"3 ensurerootisscheduled permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ensureRootIsScheduled</h1>\n<p><em>‘Work를 스케줄링하기 전에 reconciler에서 해야 할 일’</em>을 설명할 때 복수의 Work가 들어오면 교통정리 하고 스케줄링 정보를 root에 새긴다고 언급했습니다. 그 일을 Shceduled에서 합니다.</p>\n<p>root에 저장되는 스케줄링 정보는 scheduler가 만든 Task 객체, expirationTime, priority이며 callback*** 이름의 형태로 저장됩니다. 교통정리는 이 정보를 이용하여 판단합니다.</p>\n<h2 id=\"scheduler에게-work를-넘겨주기-전-사전-준비하기\"><a href=\"#scheduler%EC%97%90%EA%B2%8C-work%EB%A5%BC-%EB%84%98%EA%B2%A8%EC%A3%BC%EA%B8%B0-%EC%A0%84-%EC%82%AC%EC%A0%84-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"scheduler에게 work를 넘겨주기 전 사전 준비하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>scheduler에게 Work를 넘겨주기 전 사전 준비하기</h2>\n<p>본격적으로 expirationTime과 priority를 먼저 가져오겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js >scheduleUpdateOnFiber() > ensureRootIsScheduled()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">ensureRootIsScheduled</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> expirationTime <span class=\"token operator\">=</span> <span class=\"token function\">getNextRootExpirationTimeToWorkOn</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> existingCallbackNode <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>callbackNode <span class=\"token comment\">// 스케줄링되어 있는 Task 객체</span>\n  <span class=\"token keyword\">const</span> currentTime <span class=\"token operator\">=</span> <span class=\"token function\">requestCurrentTimeForUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> priorityLevel <span class=\"token operator\">=</span> <span class=\"token function\">inferPriorityFromExpirationTime</span><span class=\"token punctuation\">(</span>\n    currentTime<span class=\"token punctuation\">,</span>\n    expirationTime\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>시간, 우선순위와 관련된 내용은 깊게 들어가지 않습니다.<br>\n<code class=\"language-text\">getNextRootExpirationTimeToWorkOn()</code>는 root가 가지고 있는 정보들을 기반으로(<down>이전 작업이 남아있음을 나타내는 lastExpiredTime, suspend와 관련된 update가 아직 커밋되지 않음을 나타내는 ***PendingTime</down>) 현재 처리해야 될 expirationTime을 가지고 옵니다.</p>\n<p><code class=\"language-text\">currentTime</code>은 이전 포스트의 <a href=\"/react/in-depth-react-hooks_1/#currentTime\">expirationTime 섹션</a>에서 보여드렸던 msToExpirationTime() 함수를 이용하여 구합니다.</p>\n<p>우선순위는 코드를 직접 보는 게 이해하기가 더 편합니다.<br>\ncurrentTime은 ms가 아닌 expirationTime임을 생각하시고 코드를 보시길 바랍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token constant\">HIGH_PRIORITY_EXPIRATION</span> <span class=\"token operator\">=</span> __DEV__ <span class=\"token operator\">?</span> <span class=\"token number\">500</span> <span class=\"token punctuation\">:</span> <span class=\"token number\">150</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">HIGH_PRIORITY_BATCH_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">LOW_PRIORITY_EXPIRATION</span> <span class=\"token operator\">=</span> <span class=\"token number\">5000</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">LOW_PRIORITY_BATCH_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">250</span>\n\n<span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber() > ensureRootIsScheduled() > inferPriorityFromExpirationTime()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">inferPriorityFromExpirationTime</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">currentTime<span class=\"token punctuation\">:</span> ExpirationTime<span class=\"token punctuation\">,</span>\n  expirationTime<span class=\"token punctuation\">:</span> ExpirationTime</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> ReactPriorityLevel <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expirationTime <span class=\"token operator\">===</span> Sync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> ImmediatePriority\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expirationTime <span class=\"token operator\">===</span> Never <span class=\"token operator\">||</span> expirationTime <span class=\"token operator\">===</span> Idle<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> IdlePriority\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> msUntil <span class=\"token operator\">=</span>\n    <span class=\"token function\">expirationTimeToMs</span><span class=\"token punctuation\">(</span>expirationTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">expirationTimeToMs</span><span class=\"token punctuation\">(</span>currentTime<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msUntil <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> ImmediatePriority\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msUntil <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">HIGH_PRIORITY_EXPIRATION</span> <span class=\"token operator\">+</span> <span class=\"token constant\">HIGH_PRIORITY_BATCH_SIZE</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> UserBlockingPriority\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msUntil <span class=\"token operator\">&lt;=</span> <span class=\"token constant\">LOW_PRIORITY_EXPIRATION</span> <span class=\"token operator\">+</span> <span class=\"token constant\">LOW_PRIORITY_BATCH_SIZE</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> NormalPriority\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> IdlePriority\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">msUntil</code>은 <code class=\"language-text\">expirationTime</code>에서 ms를 구한 시간으로 expirationTime은 높은 수가 더 이전 시간을 나타내는 데 반해 ms는 우리가 통상 생각하는 시간으로 큰 수가 더 늦은 시간을 나타냅니다. 이걸 기준으로 expirationTime이 currentTime을 넘기게 되면 빠르게 처리해줘야 하므로 <code class=\"language-text\">ImmediatePriority</code>을 반환해주고 나머지 우선순위는 expirationTime이 얼마나 더 여유가 있지에 따라 다른 우선순위를 반환합니다.</p>\n<h2 id=\"work-교통정리-하기\"><a href=\"#work-%EA%B5%90%ED%86%B5%EC%A0%95%EB%A6%AC-%ED%95%98%EA%B8%B0\" aria-label=\"work 교통정리 하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Work 교통정리 하기</h2>\n<p>스케줄링에 필요한 정보들을 모두 구했고 스케줄링된 내용은 root에 있으므로 이를 이용하여 현재 업데이트를 반영할 Work를 스케줄링해야 할지 판단하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber() > ensureRootIsScheduled()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">ensureRootIsScheduled</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  <span class=\"token comment\">// const priorityLevel = inferPriorityFromExpirationTime(</span>\n  <span class=\"token comment\">//   currentTime,</span>\n  <span class=\"token comment\">//   expirationTime,</span>\n  <span class=\"token comment\">// );</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>existingCallbackNode <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> existingCallbackPriority <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>callbackPriority\n    <span class=\"token keyword\">const</span> existingCallbackExpirationTime <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>callbackExpirationTime\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      existingCallbackExpirationTime <span class=\"token operator\">===</span> expirationTime <span class=\"token operator\">&amp;&amp;</span>\n      existingCallbackPriority <span class=\"token operator\">>=</span> priorityLevel\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Existing callback is sufficient.</span>\n      <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">cancelCallback</span><span class=\"token punctuation\">(</span>existingCallbackNode<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"root에-스케줄링-정보-새기기\"><a href=\"#root%EC%97%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%A0%95%EB%B3%B4-%EC%83%88%EA%B8%B0%EA%B8%B0\" aria-label=\"root에 스케줄링 정보 새기기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>root에 스케줄링 정보 새기기</h2>\n<p>기존 Work를 취소했으므로 새로운 Work를 스케줄링합니다. 여기에서도 마찬가지로 작업을 동기적으로 처리해도 되는지 판단합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber() > ensureRootIsScheduled()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">ensureRootIsScheduled</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">root</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  <span class=\"token comment\">// if (existingCallbackNode !== null) {</span>\n  <span class=\"token comment\">//   생략..</span>\n  <span class=\"token comment\">//   cancelCallback(existingCallbackNode);</span>\n  <span class=\"token comment\">// }</span>\n\n  root<span class=\"token punctuation\">.</span>callbackExpirationTime <span class=\"token operator\">=</span> expirationTime\n  root<span class=\"token punctuation\">.</span>callbackPriority <span class=\"token operator\">=</span> priorityLevel\n\n  <span class=\"token keyword\">let</span> callbackNode\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expirationTime <span class=\"token operator\">===</span> Sync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Sync React callbacks are scheduled on a special internal queue</span>\n    callbackNode <span class=\"token operator\">=</span> <span class=\"token function\">scheduleSyncCallback</span><span class=\"token punctuation\">(</span><span class=\"token function\">performSyncWorkOnRoot</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Task를 반환</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    callbackNode <span class=\"token operator\">=</span> <span class=\"token function\">scheduleCallback</span><span class=\"token punctuation\">(</span>\n      priorityLevel<span class=\"token punctuation\">,</span>\n      <span class=\"token function\">performConcurrentWorkOnRoot</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// Compute a task timeout based on the expiration time. This also affects</span>\n      <span class=\"token comment\">// ordering because tasks are processed in timeout order.</span>\n      <span class=\"token punctuation\">{</span> timeout<span class=\"token punctuation\">:</span> <span class=\"token function\">expirationTimeToMs</span><span class=\"token punctuation\">(</span>expirationTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token comment\">// Task를 반환</span>\n  <span class=\"token punctuation\">}</span>\n\n  root<span class=\"token punctuation\">.</span>callbackNode <span class=\"token operator\">=</span> callbackNode <span class=\"token comment\">// Task를 root에 저장한다.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">performSyncWorkOnRoot()</code>와 <code class=\"language-text\">performConcurrentWorkOnRoot()</code>는 Work를 담당하는 함수이며 후자의 함수는 concurrent mode에서 사용됩니다. 이 함수들이 Task의 callback에 저장됩니다. bind로 root를 물고 있는 걸 기억하기실 바랍니다.</p>\n<p>아직까지도 scheduler와 직접적으로 연관된 코드들이 등장하지 않았습니다. 이 함수에서 scheduler의 모듈을 import해서 Work함수을 스케줄할 수도 있지만 리액트는 reconciler와 scheduler 사이의 의존성을 낮추기 위해 SchedulerWithReactIntegration.js라는 모듈을 따로 두었습니다. 이 모듈에 속한 함수가 <code class=\"language-text\">scheduleSyncCallback()</code>와 <code class=\"language-text\">scheduleCallback()</code>입니다.</p>\n<h1 id=\"4-schedulesynccallback-schedulecallback\"><a href=\"#4-schedulesynccallback-schedulecallback\" aria-label=\"4 schedulesynccallback schedulecallback permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. scheduleSyncCallback, scheduleCallback</h1>\n<h2 id=\"async-work\"><a href=\"#async-work\" aria-label=\"async work permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async work</h2>\n<p>callback과 syncCallback 중에 일반적인 callback을 먼저 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber() > ensureRootIsScheduled() > SchedulerWithReactIntegration.js > scheduleCallback()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">scheduleCallback</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">reactPriorityLevel<span class=\"token punctuation\">:</span> ReactPriorityLevel<span class=\"token punctuation\">,</span>\n  callback<span class=\"token punctuation\">:</span> SchedulerCallback<span class=\"token punctuation\">,</span>\n  options<span class=\"token punctuation\">:</span> SchedulerCallbackOptions <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> priorityLevel <span class=\"token operator\">=</span> <span class=\"token function\">reactPriorityToSchedulerPriority</span><span class=\"token punctuation\">(</span>reactPriorityLevel<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">Scheduler_scheduleCallback</span><span class=\"token punctuation\">(</span>priorityLevel<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>reconciler와 scheduler의 우선순위 내부값이 다르기 때문에(<down>ImmediatePriority = 99, 1</down>) scheduler에게 넘기기 전에 변환합니다.<br>\n이 우선순위와 callback<up>Work함수</up>, options를 넘겨주며 scheduler에게 스케줄링을 요청합니다. 이제 이 Work는 scheduler가 알아서 실행시킬 겁니다. reconciler는 여기까지 왔으면 할 일을 다 한 상태입니다.</p>\n<blockquote>\n<p>options에는 Task의 만료 시간을 나타내는 timeout과 시작 시간을 미룰수 있는 delay가 있습니다.</p>\n</blockquote>\n<h2 id=\"sync-work\"><a href=\"#sync-work\" aria-label=\"sync work permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sync work</h2>\n<p>하지만 syncCallback의 처리는 조금 다릅니다.<br>\n동기적으로 실행한다면 scheduler의 힘을 빌릴 필요 없이 reconciler가 내부적으로 처리하면 됩니다. Work가 곧 reconciler의 행위이기 때문입니다. 그래서 sync 작업들은 내부 queue에 따로 저장해 놓습니다. 그리고 실행하기 적당한 때를 reconciler가 판단해서 queue에 있는 작업들을 동기적으로 모두 실행해줍니다.<br>\n이 행위를 하는 함수가 flushSyncCallbackQueue()이며 scheduleWork()에서 사용했던 <a href=\"#flushSyncCallbackQueue()\">함수</a>가 이 함수였습니다.</p>\n<anchor id=\"scheduleSyncCallback()\">\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction() > ReactFiberWorkLoop.js > scheduleUpdateOnFiber() > ensureRootIsScheduled() > SchedulerWithReactIntegration.js > scheduleSyncCallback()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">scheduleSyncCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback<span class=\"token punctuation\">:</span> SchedulerCallback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Push this callback into an internal queue. We'll flush these either in</span>\n  <span class=\"token comment\">// the next tick, or earlier if something calls `flushSyncCallbackQueue`.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>syncQueue <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    syncQueue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>callback<span class=\"token punctuation\">]</span>\n    <span class=\"token comment\">// Flush the queue in the next tick, at the earliest.</span>\n    immediateQueueCallbackNode <span class=\"token operator\">=</span> <span class=\"token function\">Scheduler_scheduleCallback</span><span class=\"token punctuation\">(</span>\n      Scheduler_ImmediatePriority<span class=\"token punctuation\">,</span>\n      flushSyncCallbackQueueImpl\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Push onto existing queue. Don't need to schedule a callback because</span>\n    <span class=\"token comment\">// we already scheduled one when we created the queue.</span>\n    syncQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> fakeCallbackNode\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>주석으로 너무 잘 설명하고 있어서 일부러 지우지 않았습니다.<br>\n<code class=\"language-text\">callback</code>은 Work를 담당하는 performSyncWorkOnRoot() 입니다. 비동기 작업과는 다르게 callback을 스케줄링하지 않고 내부 큐에 넣습니다. 그리고 대신 이 큐를 flush하는 <code class=\"language-text\">flushSyncCallbackQueueImpl()</code>를 스케줄링해줍니다. 이 부분이 비동기 작업이랑 다른 부분입니다.</p>\n<p>scheduleWork()에서 사용한 flushSyncCallbackQueue() 또한 내부적으로 flushSyncCallbackQueueImpl()를 사용하고 있습니다.</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre style=\"counter-reset: linenumber 0\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberWorkLoop.js > flushSyncCallbackQueue()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">flushSyncCallbackQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>immediateQueueCallbackNode <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> node <span class=\"token operator\">=</span> immediateQueueCallbackNode\n    immediateQueueCallbackNode <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">Scheduler_cancelCallback</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">flushSyncCallbackQueueImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 sync Work를 스케줄링했다면 flushSyncCallbackQueueImpl Task가 스케줄링된 상태로 남아 있을 겁니다. flushSyncCallbackQueue()는 reconciler에서 판단해서 Work 함수를 실행하는 것으로 스케줄링 된 Task와 중복 작업을 하게 됩니다. 이 Task를 취소하는 부분이 6번째 라인입니다.</p>\n<p>마지막으로 실질적으로 sync queue를 flush하는 함수인 <code class=\"language-text\">flushSyncCallbackQueueImpl()</code>만 확인하면 우리는 reconciler가 하는 일을 모두 확인하게 되는 겁니다.</p>\n<h1 id=\"11-flushsynccallbackqueueimpl\"><a href=\"#11-flushsynccallbackqueueimpl\" aria-label=\"11 flushsynccallbackqueueimpl permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>11. flushSyncCallbackQueueImpl</h1>\n<p>이미 알아본바 이 함수는 scheduler에 의해서 비동기로 호출될 수도 있고 reconciler에서 flushSyncCallbackQueue()를 통해 동기적으로 호출될 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > SchedulerWithReactIntegration.js > flushSyncCallbackQueueImpl()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">flushSyncCallbackQueueImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isFlushingSyncQueue <span class=\"token operator\">&amp;&amp;</span> syncQueue <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Prevent re-entrancy.</span>\n    isFlushingSyncQueue <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> isSync <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n      <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> syncQueue\n      <span class=\"token function\">runWithPriority</span><span class=\"token punctuation\">(</span>ImmediatePriority<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">let</span> callback <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n          <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n            callback <span class=\"token operator\">=</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>isSync<span class=\"token punctuation\">)</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>callback <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      syncQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 에러가 발생한 callback만 버린다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>syncQueue <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        syncQueue <span class=\"token operator\">=</span> syncQueue<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// Resume flushing in the next tick</span>\n      <span class=\"token function\">Scheduler_scheduleCallback</span><span class=\"token punctuation\">(</span>\n        Scheduler_ImmediatePriority<span class=\"token punctuation\">,</span>\n        flushSyncCallbackQueue\n      <span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">throw</span> error\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      isFlushingSyncQueue <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>로직은 특별한 게 없으므로 생소한 <code class=\"language-text\">runWithPriority()</code>만 짚고 넘어가겠습니다.<br>\nrunWithPriority()는 shceduler의 컨텍스트 변수인 <code class=\"language-text\">currentPriorityLevel</code>에 실행할 함수의 우선순위를 할당하는 함수입니다.<br>\n이렇게 함으로서 Work와 관련된 작업의 실행과 그 우선순위를 모두 scheduler가 관리하게 되면서 서로 혼재될 수 있는 부분을 확실히 나누게 되었습니다.\n이제 reconciler는 현재 동작하고 있는 Work의 우선순위를 기준으로 추가 작업이 필요할 때 scheduler의 현재 컨텍스트 우선순위만 가지고 오면 됩니다. Work는 순차 실행이 아니며 언제든지 중지되고 재실행 될 수 있기 때문에 reconciler가 더욱이 이 작업들의 우선순위를 가지고 있을 수 없는 겁니다.</p>\n<p>reconciler의 코드는 여기서 끝입니다. 다음 포스트에서는 scheduler의 코드를 확인합니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">목록</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><a href=\"/react/in-depth-react-hooks_2/\">React 톺아보기- 03. Hooks_2</a></td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\"><a href=\"/react/in-depth-react-scheduler_2/\">React 톺아보기- 04. scheduler_2</a></td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"React 톺아보기- 04. Scheduler_1","date":"2020-06-21","keywords":["리액트","react","fiber","hook","hooks","useState","useEffect","useLayoutEffect","useCallback","scheduler"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react/in-depth-react-scheduler_1/","previous":{"fields":{"slug":"/react/in-depth-react-hooks_2/"},"frontmatter":{"title":"React 톺아보기- 03. Hooks_2","category":"react"}},"next":{"fields":{"slug":"/react/in-depth-react-scheduler_2/"},"frontmatter":{"title":"React 톺아보기- 04. Scheduler_2","category":"react"}}}}}