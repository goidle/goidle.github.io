{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react-intro/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"a56fa4fd-e61b-5211-ac1f-bae433ac8677","excerpt":"모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 이번 포스트에서는 사전지식을 좀 더 자세하게 다루도록 하겠습니다. 위 표는 클래스의 라이프 사이클을 나타내는 표이며 오다가다 많이 보셨을 겁니다. 표 왼쪽을 보면 리액트를 개발하면서 접해보지 못한 단어들이 보입니다. “Render phase”, “Commit phase” 표만봐서는 설명에서 언급되는 side effect…","html":"<blockquote>\n<p>모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.</p>\n</blockquote>\n<p>이번 포스트에서는 사전지식을 좀 더 자세하게 다루도록 하겠습니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 790px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 59.05017921146953%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACGUlEQVQoz2VTia6bMBDk/7+vlZp3hCPB3GDjEwKZjp0+6bW1ZK3XZmdnZ5cMXM/nMxrs+w69rpjnGUopOOfgvU9Wa41xHLHyPfpfb6tasSwLpJTpLotgX4AhBIItEKJB38dgDWMMLD9cGFDXAhOTRd8Ym5LE5EIIdF2PlX6Gb8u4gKLz+PHR4b0mI2kRnIaSC7wjwEoWRkMuE5nJVzJrk/XeJZud55moPx4PZg649Q7XWqLqLc8WZaNQiAX1YFC2CmJytBrNsMISIIJEecyfcxYzRMpRH+s8GgbE3c4eda/xeZ9xKUfkjcZVrKhHn0D7OTJ7SRJ1/WKaRWZRC+8DNfTYWKLTMpW6e2rEsq9C4b3s8UbgYTH8RpGdYpz5H/BfDcveI29tstUQzw6XSuKdu+wC7tOBvNvI1BFUp+b8BbhtW3Jiy419ldLPhkxsOg/s4jAI9GOLWtzQdjXladn1KVX2XcPoZxFoGEbMnKUIfjw2BG/x2AP2LeAMPeCuCPINevwJv1xw2g8cvoEPG/bHTvtqaozP4jCrNAIWx+45jCUBcmCrsKs32OkXwQigczwt3/Ya8BVO3+E4Tvy7UlOmaUo67GQnxgJ5fUHVfnBQOdx2RCcrjk2e7u/dZ/KVnWBZyX28oWgK3IYKs55ef0oq9Tiw7Ruq7oZcFOxsDqUVVna7lS3vq3RfcDdLA2kktNUEy3mXc3avGOSA30vklEj6RoQzAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"react lifescycle\" title=\"react lifescycle\" src=\"/static/83aa2072b273a11e7b733979b439d735/c94d1/react-lifescycle.png\" srcset=\"/static/83aa2072b273a11e7b733979b439d735/0780f/react-lifescycle.png 198w,\n/static/83aa2072b273a11e7b733979b439d735/47b26/react-lifescycle.png 395w,\n/static/83aa2072b273a11e7b733979b439d735/c94d1/react-lifescycle.png 790w,\n/static/83aa2072b273a11e7b733979b439d735/32b35/react-lifescycle.png 1116w\" sizes=\"(max-width: 790px) 100vw, 790px\" loading=\"lazy\">\n    </span>\n<p>위 표는 클래스의 라이프 사이클을 나타내는 표이며 오다가다 많이 보셨을 겁니다.<br>\n표 왼쪽을 보면 리액트를 개발하면서 접해보지 못한 단어들이 보입니다.<br>\n<em>“Render phase”</em>, <em>“Commit phase”</em><br>\n표만봐서는 설명에서 언급되는 <em>side effect</em>가 무엇을 뜻하는 것이고 또 무엇이 중지되고 다시 시작될 수 있는지 이해하기가 어렵습니다.</p>\n<h2 id=\"render-phase\"><a href=\"#render-phase\" aria-label=\"render phase permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Render phase</h2>\n<p><em>Render phase</em>는 쉽게 말해 VDOM 조작 단계라고 생각하시면 됩니다.<br>\n리액트는 변경점이 생겼을 때 다르게 말하면 react element가 추가, 수정, 삭제 등이 발생했을 때 이를 VDOM에 반영하기 위해 <u><strong><em>VDOM 재조정 작업(이하 Work)</em></strong></u>을 <em>scheduler</em>을 통해 실행시킵니다.</p>\n<p>이 VDOM을 재조정하는 일련의 과정을 <em>Render phase</em>라고 부릅니다. 재조정을 담당하는 <em>reconciler</em>의 시스템이 stack 기반에서 fiber architecture로 넘어가면서 이 과정을 abort, stop, restart 할 수 있게 되었습니다.<br>\n이 기능은\n<a href=\"https://reactjs.org/docs/concurrent-mode-adoption.html#migration-step-blocking-mode\" target=\"_blank\">concurrent mode</a>\n에서만 비동기로 함께 이루어지며 legacy mode(현재 우리가 일반적으로 사용하는 ReactDOM.render)에서는 위 기능 없이 동기적으로 <em>Render phase</em>가 동작하게 됩니다.</p>\n<p>컴포넌트 실행은 <em>Render phase</em>에서 실행되며 위 내용으로 짐작할 수 있듯이 컴포넌트 실행이 곧 화면에 페인트 된다는 뜻은 아닙니다.\n이전 포스트에서 언급한 용어인 렌더링에 빗대어 보자면 컴포넌트가 리-렌더링 된다는 말은 컴포넌트가 실행되고 그 결과가 VDOM에 반영된다는 거지 DOM에 마운트되어 페인트 된다는 뜻이 아니라는 겁니다.</p>\n<h2 id=\"commit-phase\"><a href=\"#commit-phase\" aria-label=\"commit phase permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Commit phase</h2>\n<p><em>Commit phase</em>는 <em>Render phase</em>에서 재조정된 VDOM을 DOM에 마운트시키고 라이프 사이클을 실행하는 단계입니다.\n여기서도 마찬가지로 DOM에 마운트된다는 것이지 페인트 된다는 건 아닙니다.</p>\n<p>이 단계는 모드와는 상관없이 항상 일관적인 화면 업데이트를 위해 동기적으로 실행 됩니다. 동기적으로 실행된다는 건 DOM 조작을 Call stack을 한 번도 비우지 않고 일괄처리한다는 뜻입니다. 그러므로 <em>Commit phase</em> 중간에 페인트 되지 않습니다. 이 단계가 끝나고 리액트에서 Call stack을 비워줘야지만 브라우저에서 화면을 페인트 할 수 있게 됩니다.</p>\n<p>그 다음은 자주 언급되는 VDOM을 알아보겠습니다.</p>\n<h2 id=\"vdom\"><a href=\"#vdom\" aria-label=\"vdom permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VDOM</h2>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 634px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 143.69085173501577%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAEOElEQVRIx31VaVMbRxDl/1cZCXOksKGAKrv4EmOBDSGxY9kcTkglgSRCEgh0sTr2vne150vPiBUSEnRV1+xcb1/PdL+Zw5ilacpbx3VhOw58f4AoipAkCR8zTQuO40LTDXi+P9qT7WM2Nw6W3E9UqjUcfiriy9cTHBx+xq/FY/zx5zl2Cvu8/2b7R5Qr13wt+9k46NwshsyCIOTs/MGAswvDiPdD8iiOZ+6ZYsjMNE1IkgRRFKEoCndd16Gqw9axbSg0L/V6MKj/OOwpQJ/OxjAM2LSRuWVZvC8IAmzPg0NgSqkEg1qPmM8EzDqP6Y+bS2DMom4XqarOCPkR4HN+cnyMt9vbEGo1pLKMmN082Fx2IckDw6dYZePs3FZXVzE/P4+fDw/xnLE9nKETWhA9AYrfR5zGCOOQPCAWCfpSH4XdAlZfraJyVeEb7cBAz2lDsBvou3foum1Ygf4Qco8GWnaNT+oDGU5igpIF10IVl80SZK+LlnYDLZSh+QrUQIQa99H37yA4DbTtW94mRIYDGoE6Qb3VbOGqegWZUmc4T4wINDPHclD65xK+OxiN2aGBIB4MAfWBwjvMms0mFhYWsJCbx28XJVzrKb7U+9i/buGi5+LvjoN3799jZXkJu3u77GqQkQqT4AGQnRmzer2OxcUl/LCyjOO//kONAE/bIj7V2yhLPm4UD+92drC0soJCoTBiaATaJGCUhKPJi/Nz/Ht6OuprvoaO02GVy/syVc/Rx4+wKOGzFDQfA8Yp5VacQFE1nipUf4hM2hClMEMdktfh4bmuB5nWuO02HaaD+L5azGmGEc+jMAx5/ULTkFICM1IWAcp+lycwUxeLlWSrNVQbtmY24DDkmJTkw4c9HOztkeIML6prK3SWdyOVKVcqeLOxgUaj8XTI2aWUy2Xk8nl+y/vffsdZN8HB9R12SCNPWg6+3hhY39hELpfD1tbWqKKMacAhw77Yx8bmJjbW11BrCdDpPyWqlrNuE307gBumKBaLWHz5EkdHR7MZalQdCWKIsgJR6MAlqXLu1SU7H9F7uGX2BFQq1YlimAJkv5EUFQ4pCqns1GKJKiXhqgIMSMU1ujSm4FliTwDasY6+LKJE+RcrD2UoSiKajRa/5QyQGcuEIAi4z2R4pzTwev0V8vkFfP9+DHhU+MItXq+tIT+fx7ezIsxE4RnwlMxNANZ7NSwuL5Lm5fD5F9K8xELr9hJLy8vIvcjhpyJVRaoSYIRZgjwjZAPlapnf2ngY1WqV1PoUqitRYvdGIY8/GTMBzVDDIPThe/79WxuP3gjXduHEJkS3MwH4mOFEHmq+TC+cRZs9KqVkxNCjuvVsnxjKkPzus/JvkmKPAFVf4sltByaXdyekltyibzbG5lnITObZc2Hfz2fO1qu+iJj0gAOyOnYjG17kcGff7tg3+zNbnI2Pe7YmE+j/AYmfmLxmz5QpAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"VDOM\" title=\"VDOM\" src=\"/static/258b43ce623e7b6340fc6aed969199ed/153fa/VDOM.png\" srcset=\"/static/258b43ce623e7b6340fc6aed969199ed/0780f/VDOM.png 198w,\n/static/258b43ce623e7b6340fc6aed969199ed/47b26/VDOM.png 395w,\n/static/258b43ce623e7b6340fc6aed969199ed/153fa/VDOM.png 634w\" sizes=\"(max-width: 634px) 100vw, 634px\" loading=\"lazy\">\n    </span>\n<p>리액트는 VDOM을 더블 버퍼링 형태로 관리합니다. DOM에 마운트된 <em>current</em>와 <em>Render phase</em>에서 작업 중인 <em>workInProgress</em>로 나뉘어 있습니다. 이 <em>workInProgress</em>는 <em>Commit phase</em>를 지나면 <em>current</em>로 관리됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react-reconciler > ReactFiberWorkLoop.js > commitRootImpl()</span>\nroot<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> finishedWork</code></pre></div>\n<p>이렇듯 더블 버퍼링 형태이기 때문에 리액트는 <em>workInProgress</em>에 작업을 하다가도 언제든지 버리고 처음부터 다시 작업하던지 아니면 중지시켰다가 다시 시작하는 등 작업 우선순위에 맞게 유연하게 대처할 수 있기에 사용자 경험을 최우선적으로 고려할 수 있습니다.</p>\n<p>위 이미지에서 화살표는 생략된 게 없습니다. 자세히 보면 <code class=\"language-text\">root</code>는 <em>current</em>만 참조하고 있습니다. <em>workInProgress</em>가 만들어지는 방식은 <em>current</em>에서 자기 복제하여 서로 <code class=\"language-text\">alternate</code>로 참조하는 방식입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react-reconciler > ReactFiberWorkLoop.js > prepareFreshStack()</span>\n<span class=\"token keyword\">const</span> workInProgress <span class=\"token operator\">=</span> <span class=\"token function\">createWorkInProgress</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> expirationTime<span class=\"token punctuation\">)</span>\nworkInProgress <span class=\"token operator\">===</span> root<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span>alternate <span class=\"token comment\">// true</span></code></pre></div>\n<p>VDOM node(이하 <em>fiber</em>)는 자식을 <code class=\"language-text\">child</code>로 참조하는데 first child만 참조합니다. 나머지 자식들은 이전 형제가 <code class=\"language-text\">sibling</code>으로 참조하고 있습니다. 그리고 모든 자식은 부모를 <code class=\"language-text\">return</code>으로 참조합니다.</p>\n<h2 id=\"reactelement\"><a href=\"#reactelement\" aria-label=\"reactelement permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reactElement</h2>\n<p>일반적으로 개발자 대부분은 react 코어 패키지에 있는 모듈들만 사용하게 됩니다. 그리고 작업 결과물은 <em>reactElement</em>로 만들어집니다. <em>reactElement</em>는 컴포넌트 정보만을 담고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// react > ReactElement.js > createElement()</span>\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// This tag allows us to uniquely identify this as a React Element</span>\n  $$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span> <span class=\"token constant\">REACT_ELEMENT_TYPE</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Built-in properties that belong on the element</span>\n  <span class=\"token keyword\">type</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span>\n  key<span class=\"token punctuation\">:</span> key<span class=\"token punctuation\">,</span>\n  ref<span class=\"token punctuation\">:</span> ref<span class=\"token punctuation\">,</span>\n  props<span class=\"token punctuation\">:</span> props<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Record the component responsible for creating this element.</span>\n  _owner<span class=\"token punctuation\">:</span> owner<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>우리가 작성하는 JSX는 babel을 통해 react.createElement로 변환됩니다.<br>\ntype에 함수형 컴포넌트는 그 함수 자체가 <em>Host Component</em>는 tag 이름이 들어갑니다.<br>\n나머지는 child 포함 죄다 props로 들어갑니다.\n리액트 코어는 이게 끝입니다.</p>\n<h2 id=\"fiber\"><a href=\"#fiber\" aria-label=\"fiber permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>fiber</h2>\n<p><em>reactElement</em>를 VDOM에 올려놓아야 합니다. 그 확장을 fiber가 해줍니다.<br>\nfiber는 VDOM node이며 모든 정보를 담고 있다고 생각하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// react-reconciler > ReactFiber.js > createFiberFromElement()</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">type</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// element === reactElement</span>\n<span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pendingProps <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fiber <span class=\"token operator\">=</span> <span class=\"token function\">createFiberFromTypeAndProps</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span>\n  key<span class=\"token punctuation\">,</span>\n  pendingProps<span class=\"token punctuation\">,</span>\n  owner<span class=\"token punctuation\">,</span>\n  mode<span class=\"token punctuation\">,</span>\n  expirationTime<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// react-reconciler > ReactFiber.js > createFiberFromTypeAndProps()</span>\n<span class=\"token function\">createFiber</span><span class=\"token punctuation\">(</span>fiberTag<span class=\"token punctuation\">,</span> pendingProps<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// react-reconciler > ReactFiber.js > createFiber()</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">FiberNode</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">,</span> pendingProps<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// react-reconciler > ReactFiber.js > FiberNode()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">FiberNode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Instance</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tag <span class=\"token operator\">=</span> tag<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>elementType <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 추후에 reactElement의 type을 할당</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">type</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 추후에 reactElement의 type을 할당</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stateNode <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// DOM에 마운트될 html element</span>\n\n  <span class=\"token comment\">// Fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">return</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 자식 fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sibling <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 형제 fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 자식들 중 자신의 위치</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pendingProps <span class=\"token operator\">=</span> pendingProps<span class=\"token punctuation\">;</span> <span class=\"token comment\">// workInProgress는 아직 작업이 끝난 상태가 아니므로 props를 pending으로 관리</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>memoizedProps <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// render phase가 끝나면 pendingProps는 memoizedProps로 관리</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>updateQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 라이프사이클과 관련된 queue</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// hook 객체 리스트</span>\n\n  <span class=\"token comment\">// Effects</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effectTag <span class=\"token operator\">=</span> NoEffect<span class=\"token punctuation\">;</span> <span class=\"token comment\">// fiber가 가지고 있는 side effect 종류를 기록</span>\n\n  <span class=\"token comment\">// 이하 side effect list 관련</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">=</span> NoWork<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Work의 우선순위와 개별 Work를 나타내는 척도</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">=</span> NoWork<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 자식으로부터 Work가 만들어질 경우 사용됨</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 반대편 fiber를 참조</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>reactElement가 개발자가 작성한 컴포넌트 겉 정보를 담고 있다면 fiber는 컴포넌트 내부에서 사용된 훅, 라이프 사이클 등 실질적으로 컴포넌트를 실행한 후에 발생하는 모든 정보를 담고 있습니다. Work와 관련된 정보도 모두 포함되기 때문에 fiber 자체를 실제 코드에서는 Work라고 표현되기도 합니다.<br>\n너무 많은 정보가 있기 때문에 이런 게 있구나 하고 훑어만 보시면 됩니다. 추후에 하나도 빠짐없이 다루게 될 것입니다.</p>\n<h2 id=\"side-effect\"><a href=\"#side-effect\" aria-label=\"side effect permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>side effect</h2>\n<p>쉽게 생각해서 DOM에 변경점을 만들거나 혹은 변경점을 만들어낼 수도 있는 작업을 side effect라고 생각하면 됩니다(또는 effect).\n아래는 리액트에서 사용되는 side effect tag입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Don't change these two values. They're used by React Dev Tools.</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> NoEffect <span class=\"token operator\">=</span> <span class=\"token comment\">/*              */</span> <span class=\"token number\">0b0000000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PerformedWork <span class=\"token operator\">=</span> <span class=\"token comment\">/*         */</span> <span class=\"token number\">0b0000000000001</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// You can change the rest (and add more).</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Placement <span class=\"token operator\">=</span> <span class=\"token comment\">/*             */</span> <span class=\"token number\">0b0000000000010</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Update <span class=\"token operator\">=</span> <span class=\"token comment\">/*                */</span> <span class=\"token number\">0b0000000000100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PlacementAndUpdate <span class=\"token operator\">=</span> <span class=\"token comment\">/*    */</span> <span class=\"token number\">0b0000000000110</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Deletion <span class=\"token operator\">=</span> <span class=\"token comment\">/*              */</span> <span class=\"token number\">0b0000000001000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ContentReset <span class=\"token operator\">=</span> <span class=\"token comment\">/*          */</span> <span class=\"token number\">0b0000000010000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Passive <span class=\"token operator\">=</span> <span class=\"token comment\">/*               */</span> <span class=\"token number\">0b0001000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span> <span class=\"token punctuation\">.</span> <span class=\"token punctuation\">.</span> 생략</code></pre></div>\n<p>이 tag는 fiber의 <code class=\"language-text\">effectTag</code>에 저장되며 side effect를 가지고 있는 fiber는 side effect list로 관리됩니다.\n좀 더 자세히 설명하자면 side effect는 여러 종류가 있기 때문에 그 모든 걸 담고 있는 fiber 그 자체를 effect로 관리 합니다.</p>\n<p>그리고 이 effect들은 연결리스트로 구성됩니다. 위 fiber 객체의 <code class=\"language-text\">nextEffect</code>, <code class=\"language-text\">firstEffect</code>, <code class=\"language-text\">lastEffect</code>가 이를 위한 속성들입니다. 이 속성들만 봐도 알 수 있듯이 연결 리스트 노드는 fiber 그 자체임을 알 수 있습니다. 그리고 이 정보는 부모로 전달되며 부모는 모든 자식의 effect를 list로 가지고 있게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 자식의 side effect를 부모로 올린다.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>firstEffect\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>lastEffect<span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>firstEffect\n  <span class=\"token punctuation\">}</span>\n  returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>lastEffect\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 자신에게도 side effect가 있다면 자기 자신도 effect list에 추가해준다.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTag <span class=\"token operator\">></span> PerformedWork<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>lastEffect<span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> workInProgress\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> workInProgress\n  <span class=\"token punctuation\">}</span>\n  returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> workInProgress\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>최종적으로 root가 모든 effect를 들고 있게 됩니다.<br>\nroot의 effect 연결 리스트는 <em>Commit phase</em>에서 소비되면서 effect 종류에 맞는 시점에 특정 로직을 통해 처리됩니다.<br>\n로직 순서를 보면 부모로 리스트를 올릴 때 자식을 먼저 연결하고 자신은 맨 마지막에 추가됩니다.<br>\n중요한 부분은 아니지만 <em>Coomit phase</em>에서는 리스트 순서대로 처리되기 때문에 dfs(깊이 우선 탐색)의 순서대로 effect가 적용됨을 알 수 있습니다.</p>\n<p>tag는 Bit Masking으로 관리됩니다. 모르시는 분들을 위해 잠깐만 다루고 가겠습니다.</p>\n<h2 id=\"bit-masking\"><a href=\"#bit-masking\" aria-label=\"bit masking permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bit Masking</h2>\n<p>비트 연산을 통해서 상태를 관리한다고 보시면 됩니다.<br>\n리액트에서는 현재 실행되고 있는 환경을 context로 관리합니다. 이 context를 통해 Bit Masking을 알아보겠습니다.</p>\n<blockquote>\n<p>비트 연산자에 대한 설명은 생략하도록 하겠습니다.</p>\n</blockquote>\n<p>정의된 context를 보면 render context는 16, commit context는 32로 정의되어 있습니다.<br>\n이를 2진수로 변환하면 각각 10000, 100000 입니다.<br>\n즉 2진수로 5번째 자리가 1이면 <em>Render phase</em>란 뜻입니다.<br>\n이제 이 2진수를 통해서 어떻게 상태를 확인하고 추가하는지 알아보겠습니다.</p>\n<p>확인은 and(&#x26;)연산, 추가는 or(|)연산, 삭제는 xor(~)연산을 이용합니다.</p>\n<p>다음과 같이 정의되어 있다고 가정합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> NoContext <span class=\"token operator\">=</span> <span class=\"token number\">0b00</span>\n<span class=\"token keyword\">const</span> RenderContext <span class=\"token operator\">=</span> <span class=\"token number\">0b01</span>\n<span class=\"token keyword\">const</span> CommitContext <span class=\"token operator\">=</span> <span class=\"token number\">0b10</span>\n<span class=\"token keyword\">const</span> executionContext <span class=\"token operator\">=</span> NoContext <span class=\"token comment\">// 0</span></code></pre></div>\n<p><em>Render phase</em>에 접어들어 현재 context에 render context를 추가한다면 다음과 같습니다</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">executionContext <span class=\"token operator\">|=</span> RenderContext <span class=\"token comment\">// 00 | 01 => 01</span></code></pre></div>\n<p>현재 context에 따라서 분기 처리를 해야 한다면 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> RenderContext <span class=\"token operator\">!==</span> NoContext<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 01 &amp; 01 !== 00</span></code></pre></div>\n<p><em>Render phase</em>가 끝나고 <em>Commit phase</em>에 접어들 때는 이전 context를 지우고 다음 context를 추가해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">executionContext <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span>RenderContext <span class=\"token comment\">// 01 &amp;  10 => 00</span>\nexecutionContext <span class=\"token operator\">|=</span> CommitContext <span class=\"token comment\">// 00 | 10 => 10</span></code></pre></div>\n<p>이런식으로 연산은 비트 연산으로 저장은 십진수로 상태 값을 쉽게 관리할 수 있습니다.</p>\n<h4 id=\"리액트-실제-사용-사례\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80\" aria-label=\"리액트 실제 사용 사례 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리액트 실제 사용 사례</h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>RenderContext <span class=\"token operator\">|</span> CommitContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> NoContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//현재 context가 Render phase이거나 Commit phase이면</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">msToExpirationTime</span><span class=\"token punctuation\">(</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>사전 지식은 이 정도면 충분합니다.<br>\n이해되지 않는다고 좌절할 필요는 없습니다. 그냥 이런 게 있구나 하고 기억만 해두시면 됩니다. 우리는 개발자이니 백번 말로 설명하는 것보단 한 번 코드로 보는 게 더 이해하기 쉬울 거라 생각합니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 568px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 21.12676056338028%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAAlklEQVQY001Pyw6EIAz0pDwl3MFIRAkJB/7/57qZburuYTJ9TKft4pwjrTWVUmjOSSkljp/noeu6GL13rt33zXlrjXVg1I0xBJ9932kRw5wzjTFYeBwHD8MIdcTneTLQgyl0WIqatfZnKIlSitZ1ZRZgMyAaALn0t21jlt73QuveAe/9yyEEqrXyS2C8h4tijK9O8H/hB7liY9htm+ykAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"showMeTheCode\" title=\"showMeTheCode\" src=\"/static/e6117eec2a6fedd9a10a636574357cc2/870c3/showMeTheCode.png\" srcset=\"/static/e6117eec2a6fedd9a10a636574357cc2/0780f/showMeTheCode.png 198w,\n/static/e6117eec2a6fedd9a10a636574357cc2/47b26/showMeTheCode.png 395w,\n/static/e6117eec2a6fedd9a10a636574357cc2/870c3/showMeTheCode.png 568w\" sizes=\"(max-width: 568px) 100vw, 568px\" loading=\"lazy\">\n    </span>\n<p>다음 포스트에서 코드와 함께 본격적으로 리액트를 분석해보도록 하겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">목록</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"https://goidle.github.io/react/in-depth-react-preview/\">React 톺아보기- 01. Preview</a></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"https://goidle.github.io/react/in-depth-react-hooks_1/\">React 톺아보기- 03. Hooks_1</a></td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"React 톺아보기- 02. Intro","date":"2020-06-09","keywords":["리액트","react","fiber","scheduler","가상 돔","virtual dom"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react/in-depth-react-intro/","previous":{"fields":{"slug":"/react/in-depth-react-preview/"},"frontmatter":{"title":"React 톺아보기- 01. Preview","category":"react"}},"next":{"fields":{"slug":"/react/in-depth-react-hooks_1/"},"frontmatter":{"title":"React 톺아보기- 03. Hooks_1","category":"react"}}}}}