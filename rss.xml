<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Deep Dive Magic Code]]></title><description><![CDATA[오픈소스를 톺아보며 매직 코드라 생각했던 부분들의 동작 원리와 의미, 의도를 파악해보고 서로의 생각을 나누기 위한 블로그]]></description><link>https://github.com/goidle</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 08 Jul 2020 08:36:46 GMT</lastBuildDate><item><title><![CDATA[React 톺아보기- 05. Reconciler_1]]></title><description><![CDATA[모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 목록  4 React 톺아보기- 04. Scheduler_1 6 React 톺아보기- 0…]]></description><link>https://github.com/goidle/react/in-depth-react-reconciler_1/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-reconciler_1/</guid><pubDate>Wed, 01 Jul 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe
     src=&quot;https://stackblitz.com/edit/react-jr5b3g?ctl=1&amp;embed=1&amp;file=index.js&amp;hideNavigation=1&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;reconciler_example&quot;
   &gt;&lt;/iframe&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-scheduler_1/&quot;&gt;React 톺아보기- 04. Scheduler_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-reconciler/&quot;&gt;React 톺아보기- 05. Reconciler&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 04. Scheduler_2]]></title><description><![CDATA[모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 5. Scheduler_scheduleCallback…]]></description><link>https://github.com/goidle/react/in-depth-react-scheduler_2/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-scheduler_2/</guid><pubDate>Tue, 23 Jun 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 790px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaElEQVQoz6VTXXODMAzj//9KXnq9G6OFUPJta3Io0G3d03KnMwHHluTQqSrewdYwDOj7HpfLBdfrtUV7Z98rISVhGS6YZoecc3vfHQV2AG0vKvhrLTnhI3rMjMdSnAWFG8/ziQ+xVKwlw5XCgxk+JczJCgSM3mN4LJhSxMycWCs8i4ZaUEUaoc44aU2ocaSEFbUEiFQoYbHUzOTaGNu+skgxVTznrSmbWTwLGsM4QZceEgaUMKFEB/H0Ki9stECLZ86dkfuwojweABlnMhYy3W1qkkVKK2L2lcRkPxI31Bwai01B2BqkOxuEVlDdDFA+QjiGqLvkmj0T3WauGU0JBqVX0jzehqQGpti4hBKbFXWzwaCnh/xgndlNJkpbHOL4icDniQ1Gm+pzEI55t+BxsyExOr9ico5Ew/dr0zpbXCnHvCEDJWyCgWxbfE5TD9Z62HJK/nmpd9+eCb/W6+V/80N0u/7XSf0HXxOEYWAsL3OCAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;scheduling flow&quot; title=&quot;scheduling flow&quot; src=&quot;/static/9e327099e752bd46cae5074351cfbe5c/c94d1/scheduling_flow.png&quot; srcset=&quot;/static/9e327099e752bd46cae5074351cfbe5c/0780f/scheduling_flow.png 198w,
/static/9e327099e752bd46cae5074351cfbe5c/47b26/scheduling_flow.png 395w,
/static/9e327099e752bd46cae5074351cfbe5c/c94d1/scheduling_flow.png 790w,
/static/9e327099e752bd46cae5074351cfbe5c/9e288/scheduling_flow.png 1185w,
/static/9e327099e752bd46cae5074351cfbe5c/9adaa/scheduling_flow.png 1580w,
/static/9e327099e752bd46cae5074351cfbe5c/bf7ce/scheduling_flow.png 2560w&quot; sizes=&quot;(max-width: 790px) 100vw, 790px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
&lt;h1 id=&quot;5-scheduler_schedulecallback&quot;&gt;&lt;a href=&quot;#5-scheduler_schedulecallback&quot; aria-label=&quot;5 scheduler_schedulecallback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. Scheduler_scheduleCallback&lt;/h1&gt;
&lt;p&gt;여기서는 스케줄링에 필요한 정보들을 담은 Task를 만듭니다. 그리고 호스트 환경에 따라 구현된 비동기 api에 Task를 실행하는 함수를 전달합니다. 마지막으로 Task를 reconciler가 root에 저장할 수 있도록 반환해줍니다.&lt;/p&gt;
&lt;p&gt;먼저 Task 객체의 생김새부터 확인하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; newTask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  id&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; taskIdCounter&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  startTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  expirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  sortIndex&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scheduler가 넘겨받은 인자는 &lt;code class=&quot;language-text&quot;&gt;callback&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;priorityLevel&lt;/code&gt;입니다. 이 이외에는 scheduler가 추가하는 정보들입니다. 먼저 시간과 관련된 &lt;code class=&quot;language-text&quot;&gt;startTime&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 구하도록 하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;starttime-expirationtime&quot;&gt;&lt;a href=&quot;#starttime-expirationtime&quot; aria-label=&quot;starttime expirationtime permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;startTime, expirationTime&lt;/h2&gt;
&lt;p&gt;reconciler에서는 expirationTime에 추가적인 의미가 있었지만 scheduler에서는 이름 그대로 Task의 시작시간과 만료 시간을 뜻합니다.
넘겨받은 인자 중에 시간과 관련된 인자는 options로 timeout과 delay가 있습니다. delay와 timeout은 각각 startTime, expirationTime에 영향을 줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;unstable_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; startTime
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; timeout

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; options &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;object&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; options &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; delay &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;delay
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; delay &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;number&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; delay &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      startTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; delay
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      startTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTime
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    timeout &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;timeout &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;number&apos;&lt;/span&gt;
        &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;timeout
        &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;timeoutForPriorityLevel&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    timeout &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;timeoutForPriorityLevel&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    startTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTime
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; startTime &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; timeout

  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;options&lt;/code&gt;는 concurrent mode에서 사용합니다. 현재 대부분은 legacy mode를 사용하기 때문에 timeout은 &lt;code class=&quot;language-text&quot;&gt;timeoutForPriorityLevel()&lt;/code&gt;를 통해 구합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Times out immediately&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;IMMEDIATE_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Eventually times out&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;USER_BLOCKING_PRIORITY&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;250&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NORMAL_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5000&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOW_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Never times out&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;IDLE_PRIORITY&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; maxSigned31BitInt &lt;span class=&quot;token comment&quot;&gt;// 1073741823&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback() &gt; timeoutForPriorityLevel()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;timeoutForPriorityLevel&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; ImmediatePriority&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;IMMEDIATE_PRIORITY_TIMEOUT&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; UserBlockingPriority&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;USER_BLOCKING_PRIORITY&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; IdlePriority&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;IDLE_PRIORITY&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; LowPriority&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOW_PRIORITY_TIMEOUT&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;case&lt;/span&gt; NormalPriority&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NORMAL_PRIORITY_TIMEOUT&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;#scheduleSyncCallback()&quot;&gt;scheduleSyncCallback()&lt;/a&gt;에서는 우선순위를 Scheduler&lt;em&gt;ImmediatePriority로 넘겨 주었습니다. Scheduler&lt;/em&gt;ImmediatePriority로 expirationTime을 계산해보자면 현재 시간보다 -1ms이 빠르겠네요. 이 부분을 어떻게 이용하는지 다음 섹션에서 확인합니다.&lt;/p&gt;
&lt;h2 id=&quot;task-생성하기&quot;&gt;&lt;a href=&quot;#task-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0&quot; aria-label=&quot;task 생성하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Task 생성하기&lt;/h2&gt;
&lt;p&gt;사전작업은 모두 끝났습니다. 이제부터 본격적으로 새로운 Task와 기 Task들을 어떻게 관리하고 실행하는지 알아보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;unstable_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// var expirationTime = startTime + timeout&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; newTask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    id&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; taskIdCounter&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    startTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    expirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    sortIndex&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// delayed Task..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;//  general Task..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; newTask
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;큰 틀을 먼저 보자면 Task 실행 시점에 따라 분기처리가 되고 &lt;code class=&quot;language-text&quot;&gt;newTask&lt;/code&gt;를 반환하여 reconciler가 해당 Task를 root의 callbackNode에 저장할 수 있도록 합니다(&lt;down&gt;교통정리를 위해&lt;/down&gt;).&lt;br&gt;
if의 분기처럼 &lt;u&gt;지연된 Task&lt;up&gt;Timer&lt;/up&gt;&lt;/u&gt;의 처리방식은 조금 다릅니다. timer는 최소 startTime은 지나서 실행되어야 하기 때문입니다.&lt;/p&gt;
&lt;p&gt;그리고 Task의 실행 순서는 우선순위에 따라 정해집니다. 인입된 Task를 단순히 배열에 넣어두고 실행 시점마다 매번 우선순위가 높은 Task를 뽑아내 실행하면 매우 비효율적입니다. scheduler는 이 부분에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_heap&quot; target=&quot;_blank&quot;&gt;최소힙&lt;/a&gt; 자료구조를 사용했습니다. 힙의 정렬 기준은 Task의 sortIndex입니다.&lt;/p&gt;
&lt;p&gt;if 문을 뜯어보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;delayed-task&quot;&gt;&lt;a href=&quot;#delayed-task&quot; aria-label=&quot;delayed task permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;delayed Task&lt;/h2&gt;
&lt;p&gt;흐름도를 보면 5에서 6번을 호출하는 코드를 이번 섹션에서 볼 텐데 진행하면서 두 모듈 사이에 역할이 혼동이 와 이해하기 어려울 수도 있습니다. 혼동을 방지하기 위해 scheduler와 scheduler__host__config의 역할에 대해 명확하게 짚고 넘어가는 게 좋을 것 같습니다.&lt;/p&gt;
&lt;p&gt;scheduler__host__config는 브라우저가 동작해야 할 때 리액트가 방해하는 불상사가 발생하지 않도록 하기 위한 모듈입니다. 이를 위한 비동기 api, 틱당 Work에 할당된 시간을 나타내는 deadline, isInputPending api 등 이 위치해 있습니다.&lt;br&gt;
scheduler는 Task를 직접 관리하는 모듈이므로 Task와 연관된 모든 작업을 처리합니다.&lt;/p&gt;
&lt;p&gt;Timer를 어떻게 처리하는지 확인해 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; taskQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; timerQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;unstable_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// var newTask = { ... }&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    newTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sortIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; startTime
    &lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; newTask&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; newTask &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// All tasks are delayed, and this is the task with the earliest delay.&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isHostTimeoutScheduled&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// Cancel an existing timeout.&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;cancelHostTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        isHostTimeoutScheduled &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Schedule a timeout.&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;requestHostTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handleTimeout&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; startTime &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// general Task..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; newTask
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;힙을 사용하는 코드는 8, 9라인입니다. 코드를 보면 대충 heap.push를 생각했던 것과는 달리 행위를 기술하고 주체는 동적으로 주입하고 있습니다. 해당 라인에서 주체는 &lt;code class=&quot;language-text&quot;&gt;timerQueue&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;taskQueue&lt;/code&gt;로 각각 관심사가 다른 저장소입니다. Timer는 timer queue에 실행 대기 Task는 task queue에 저장됩니다.&lt;br&gt;
힙 정렬 기준은 sortIndex로 7번 라인에서 &lt;code class=&quot;language-text&quot;&gt;startTime&lt;/code&gt;을 할당하고 있습니다.&lt;br&gt;
이 내용만 보면 Timer는 시작 시간순으로 정렬됨을 알 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;힙 구현 코드는 따로 분석하지 않고 위치만 알려드리자면 SchedulerMinHeap.js 모듈에 구현되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;13라인 if 문 로직의 의미를 생각해보자면 Timer가 실행되는 상황은 언제일까요? 해당 Timer가 startTime에 도달하면? 만약 이때 task queue에 대기 중인 Task가 있다면?&lt;br&gt;
Web Worker를 제외하면 자바스크립트는 하나의 메인 스레드에서 돌아갑니다. task queue와 timer queue를 동시에 관찰하면서 병렬적으로 처리할 수가 없습니다. 그렇다면 scheduler는 이 두 개의 큐에 우선순위를 부여해야 합니다. 당연히 실행 대기 큐인 task queue가 timer queue보다 우선순위가 높습니다.&lt;/p&gt;
&lt;p&gt;13라인의 조건이 위 내용을 코드로 나타낸 것입니다. 현재 실행 대기 중인 Task가 없고 새롭게 만든 Task의 시작 시간이 Timer중에 가장 빠르다면 해당 Task의 시작시간으로 timeout을 걸어줍니다(&lt;down&gt;22라인&lt;/down&gt;).&lt;br&gt;
당연히 이미 timeout이 걸려 있다면 정리해줍니다(&lt;down&gt;17라인&lt;/down&gt;).&lt;br&gt;
timeout api는 시간이 되면 알아서 &lt;code class=&quot;language-text&quot;&gt;handleTimeout()&lt;/code&gt;을 실행시켜 줄 겁니다.&lt;/p&gt;
&lt;h2 id=&quot;handletimeout&quot;&gt;&lt;a href=&quot;#handletimeout&quot; aria-label=&quot;handletimeout permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;handleTimeout()&lt;/h2&gt;
&lt;p&gt;handleTimeout()이 호출되었다는 건 timer queue의 맨 앞에서 대기하고 있는 timer가 timeout되었음을 나타냅니다. timeout Timer를 어떻게 처리 할 까요?&lt;br&gt;
scheduler는 관심사 별로 저장소를 나누고 최소 힙을 사용했기 때문에 이를 쉽게 처리할 수 있습니다.&lt;br&gt;
timer queue에서 대기 중인 timeout Timer을 하나씩 꺼내어 taskQueue에 추가하기만 하면 끝입니다.&lt;/p&gt;
&lt;p&gt;이 이후 로직은 코드를 보면서 설명하도록 하고 일단 위 내용부터 확인하도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; handleTimeout()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;handleTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  isHostTimeoutScheduled &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 여기에 도달했다는 건 timeout api가 실행된 것이다.&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// timeout Timer를 꺼내어 taskQueue에 추가한다.&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; handleTimeout() &gt; advanceTimers()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Check for tasks that are no longer delayed and add them to the queue.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; timer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timer &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callback &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Timer was cancelled.&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Timer fired. Transfer to the task queue.&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      timer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sortIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; timer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime
      &lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; timer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Remaining timers are pending.&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    timer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;timer queue는 이미 시작 시간 순으로 정렬되어 있으므로 시간이 남아 있는 Timer를 만난다면 timeout Task를 task queue에 추가하는 동작을 중지해도 됩니다. 어차피 뒤에 있는 Timer들도 모두 시간이 남아있기 때문입니다.&lt;/p&gt;
&lt;p&gt;실행 시간이 다 된&lt;up&gt;timeout&lt;/up&gt; Timer들을 task queue에 추가했으므로 빨리 task queue를 소비해야 합니다. 만약 Timer가 취소된 Timer로 여전히 task queue가 비어있다면 다음 Timer의 시작시간으로 timeout api를 실행합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; handleTimeout()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;handleTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// advanceTimers(currentTime)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isHostCallbackScheduled&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      isHostCallbackScheduled &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      &lt;span class=&quot;token function&quot;&gt;requestHostCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;flushWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firstTimer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstTimer &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;        &lt;span class=&quot;token function&quot;&gt;requestHostTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handleTimeout&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; firstTimer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;timeout Timer를 모두 task queue에 추가했으므로 이제 대기 중인 Task를 실행하면 됩니다. &lt;code class=&quot;language-text&quot;&gt;flushWork()&lt;/code&gt;는 handleTimeout()과는 반대로 task queue를 소비하는 함수입니다.&lt;/p&gt;
&lt;h2 id=&quot;general-task&quot;&gt;&lt;a href=&quot;#general-task&quot; aria-label=&quot;general task permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;general Task&lt;/h2&gt;
&lt;p&gt;다시 unstable_scheduleCallback()으로 돌아와서 우리가 분석한 부분을 확인하고 넘어가겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;unstable_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// var newTask = { ... }&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// delayed Task..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// general Task..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; newTask
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리는 delayed Task 처리 로직을 분석했습니다. 이제 general Task를 확인할 텐데 이전 섹션에서 flushWork()을 알아보지 않은 이유는 여기서도 똑같은 호출이 있기 때문에 생략했습니다.&lt;/p&gt;
&lt;p&gt;general Task는 delayed Task에서 이미 확인한 코드의 형태와 크게 다르지 않습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;unstable_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// var newTask = { ... }&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// delayed Task..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    newTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sortIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
    &lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; newTask&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isHostCallbackScheduled &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isPerformingWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      isHostCallbackScheduled &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;requestHostCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;flushWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; newTask
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;task queue의 우선순위는 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;입니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;isPerformingWork&lt;/code&gt;는 무엇을 나타내는 플래그냐면 비동기 api에 넘겨주는 flusthWork()는 실행되면 바로 VDOM 재조정 작업이 들어갑니다. 그리고 concurrent mode에서는 이 작업이 비동기로 동작하기 때문에 중간에 중복으로 flushWork()가 호출될 수 있습니다. 이를 방지하기 위한 장치입니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;requestHostCallback()&lt;/code&gt;의 구현 코드는 &lt;code class=&quot;language-text&quot;&gt;requestHostTimeout()&lt;/code&gt; 처럼 단순하지 않으므로 host config를 분석할 때 다루도록 하겠습니다. 단지 지금은 flushWork()를 비동기로 실행하는 api라고 생각됩니다.&lt;/p&gt;
&lt;p&gt;다음은 flushWork()를 분석할 차례인데 현재 흐름도에서 우리의 위치가 5 -&gt; 6 호출 부분입니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;requestHostCallback()&lt;/code&gt;에 넘겨준 &lt;code class=&quot;language-text&quot;&gt;flushWork()&lt;/code&gt;가 호출 되는 부분이 9이구요. 지금 여기서 순서대로 host config를 넘어갔다가 돌아오기에는 너무 먼 길을 갔다 와야 하므로 잊어버리기 전에 scheduler의 모든 코드를 분석하고 host config로 넘어가도록 하겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;9-flushwork&quot;&gt;&lt;a href=&quot;#9-flushwork&quot; aria-label=&quot;9 flushwork permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. flushWork&lt;/h1&gt;
&lt;p&gt;flushWork()는 task queue를 소비하기 전에 사전작업을 하는 공간이고 &lt;code class=&quot;language-text&quot;&gt;workLoop()&lt;/code&gt;가 task queue를 소비하는 함수입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback() &gt; requestHostCallback() &gt; flushWork()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;flushWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;hasTimeRemaining&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// We&apos;ll need a host callback the next time work is scheduled.&lt;/span&gt;
  isHostCallbackScheduled &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isHostTimeoutScheduled&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// We scheduled a timeout but it&apos;s no longer needed. Cancel it.&lt;/span&gt;
    isHostTimeoutScheduled &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;cancelHostTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  isPerformingWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; previousPriorityLevel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentPriorityLevel
  &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hasTimeRemaining&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    currentTask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
    currentPriorityLevel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; previousPriorityLevel
    isPerformingWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scheduler에서 보았던 모든 플래그 변수들이 여기에 있네요. &lt;code class=&quot;language-text&quot;&gt;workLoop()&lt;/code&gt;가 반환하는 값을 그대로 반환하고 있음을 기억해 둡시다. 이 값은 host config가 받게 됩니다.&lt;br&gt;
그렇다면 이 값은 무엇이냐? concurrent mode에서는 하나의 Work도 중간에 중지될 수 있습니다. 그리고 적절할 때 재실행 되겠죠. workLoop는 추가 Work에 대한 여부를 반환합니다. 그리고 host config에서는 해당 여부에 따라 다음 틱에 Work가 재실행 될 수 있도록 flushWork()를 호출해줍니다.&lt;/p&gt;
&lt;p&gt;task queue를 어떻게 소비하는지 workLoop()을 통해 알아보겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;10-workloop&quot;&gt;&lt;a href=&quot;#10-workloop&quot; aria-label=&quot;10 workloop permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;10. workLoop&lt;/h1&gt;
&lt;p&gt;이해를 돕기 위해 간단한 의사코드로 흐름을 먼저 알아보고 실제 코드를 보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;currentTask = peek(taskQueue)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;while&lt;/strong&gt; currentTask !== null&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;if&lt;/strong&gt; currentTask의 만료 시간이 여유가 있는 와중에 scheduler에게 할당된 시간이 끝났다.&lt;/li&gt;
&lt;li&gt;break&lt;/li&gt;
&lt;li&gt;callback = currentTask.callback;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;if&lt;/strong&gt; callback !== null&lt;/li&gt;
&lt;li&gt;callback을 실행해 재조정 작업을 시작한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; callback이 잔여 작업을 반환했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;currentTask.callback = continuationCallback;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추가 작업이 없다면 currentTask를 task queue에서 꺼낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end if&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;callback이 없다는 건 Task가 취소되었다는 뜻이므로 task queue에서 꺼낸다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end if&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;currentTask = peek(taskQueue);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end while&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt; currentTask !== null&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;currentTask가 null이 아니라면 while 문이 break 된 것이고 또한 Task가 남아 있으므로 config host에게 계속해서 작업을 이어갈 수 있도록 true를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;task queue가 비어있고 timer queue에는 timer가 있다면 timeout을 걸어주고 false를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;end if&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;anchor id=&quot;work_loop&quot;&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; Scheduler.js &gt; unstable_scheduleCallback() &gt; requestHostCallback() &gt; flushWork() &gt; workLoop()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;hasTimeRemaining&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; initialTime
  &lt;span class=&quot;token function&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  currentTask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTask &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;hasTimeRemaining &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;shouldYieldToHost&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// This currentTask hasn&apos;t expired, and we&apos;ve reached the deadline.&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; callback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callback
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;callback &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
      currentPriorityLevel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;priorityLevel
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; didUserCallbackTimeout &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; currentTime
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; continuationCallback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;didUserCallbackTimeout&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; continuationCallback &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;function&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; continuationCallback
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTask &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token function&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    currentTask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Return whether there&apos;s additional work&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTask &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; firstTimer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;timerQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstTimer &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;requestHostTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handleTimeout&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; firstTimer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;추가 설명이 필요한 부분만 짚고 넘어가도록 하겠습니다.&lt;br&gt;
timer queue의 기아상태(starvation)를 방지하기 위해서 3, 29 라인에서 틈틈히 timeout Timer를 꺼내줍니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;callback&lt;/code&gt;은 흐름도에서 4 -&gt; 5를 호출할 때 넘겨준 Work 함수&lt;up&gt;11번&lt;/up&gt; 입니다.&lt;br&gt;
8라인 if 문 조건의 뜻은 현재 Task의 만료시간이 조금이라도 여유가 있으면 꼭 지금 처리해야 되는 게 아니므로 host config에게 물어봅니다. 작업을 계속 동기적으로 처리해도 되는지? 만약 그렇지 않다면 while 문을 중단하고 제어권을 host config에게 넘깁니다. 하지만 Task의 만료시간이 이미 지나버렸다면 바로 처리해야 하므로 제어권을 넘기지 않고 시간이 지난 모든 Task를 동기적으로 처리합니다.&lt;/p&gt;
&lt;p&gt;여기까지가 scheduler가 하는 일입니다. 다음 섹션에서는 host config가 어떻게 비동기 api를 구현했는지 확인합니다.&lt;/p&gt;
&lt;h1 id=&quot;6-requesthosttimeout-requesthostcallback&quot;&gt;&lt;a href=&quot;#6-requesthosttimeout-requesthostcallback&quot; aria-label=&quot;6 requesthosttimeout requesthostcallback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. requestHostTimeout, requestHostCallback&lt;/h1&gt;
&lt;p&gt;간단한 timeout 구현부터 확인하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js &gt; requestHostTimeout(), cancelHostTimeout()&lt;/span&gt;
&lt;span class=&quot;token function-variable function&quot;&gt;requestHostTimeout&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ms&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  taskTimeoutID &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ms&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function-variable function&quot;&gt;cancelHostTimeout&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;clearTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskTimeoutID&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  taskTimeoutID &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리가 브라우저에서 일반적으로 사용하는 형태와 크게 다르지 않습니다. 하지만 requestHostTimeout()과는 다르게 requestHostCallback()은 setTimeout api로 구현되지 않았고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API&quot; target=&quot;_blank&quot;&gt;MessageChannel&lt;/a&gt;을 이용하여 비동기 api를 구현했습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; channel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MessageChannel&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; port &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; channel&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;port2&lt;/span&gt;channel&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;port1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onmessage &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; performWorkUntilDeadline

&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js &gt; requestHostCallback(), cancelHostCallback()&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;requestHostCallback&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  scheduledHostCallback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; callback
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isMessageLoopRunning&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    isMessageLoopRunning &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    port&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function-variable function&quot;&gt;cancelHostCallback&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  scheduledHostCallback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scheduler에서 requestHostCallback()을 호출 할 때 넘겨준 &lt;code class=&quot;language-text&quot;&gt;callback&lt;/code&gt;&lt;up&gt;flushWork&lt;/up&gt;을 6번 라인에서 전역으로 잡아둡니다. 이 callback은 onmessage 핸들러인 &lt;code class=&quot;language-text&quot;&gt;performWorkUntilDeadline()&lt;/code&gt;에서 호출됩니다.&lt;/p&gt;
&lt;p&gt;이제 마지막 하나만 남았습니다. 다음은 흐름도에서 8번에 해당하는 performWorkUntilDeadline()입니다.&lt;/p&gt;
&lt;h1 id=&quot;8-performworkuntildeadline&quot;&gt;&lt;a href=&quot;#8-performworkuntildeadline&quot; aria-label=&quot;8 performworkuntildeadline permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. performWorkUntilDeadline&lt;/h1&gt;
&lt;p&gt;해당 함수에서 callback&lt;up&gt;flushWork&lt;/up&gt;을 실행하는데 이때 callback이 제어권을 performWorkUntilDeadline()에게 반납했을 때의 의미는 다음과 같습니다.&lt;br&gt;
작업을 모두 완료했거나 또는 작업 중 host config가 할당한 시간&lt;up&gt;deadline&lt;/up&gt;을 넘긴 경우를 뜻합니다.&lt;br&gt;
후자의 경우 잔여 작업이 남아 있을 수 있는데 이때는 다음 틱에 deadline을 재설정하여 잔여 작업을 계속 진행할 수 있도록 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; yieldInterval &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ms&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; deadline &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js &gt; performWorkUntilDeadline()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;performWorkUntilDeadline&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;scheduledHostCallback &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    deadline &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; yieldInterval
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hasTimeRemaining &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hasMoreWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduledHostCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hasTimeRemaining&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;hasMoreWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        isMessageLoopRunning &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
        scheduledHostCallback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        port&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      port&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; error
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    isMessageLoopRunning &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  needsPaint &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yieldInterval&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;deadline&lt;/code&gt;은 다음의 주석으로 설명을 대체합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;yieldinterval&quot;&gt;&lt;a href=&quot;#yieldinterval&quot; aria-label=&quot;yieldinterval permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;yieldInterval&lt;/h3&gt;
&lt;p&gt;Scheduler periodically yields in case there is other work on the main thread, like user events. By default, it yields multiple times per frame.&lt;br&gt;
It does not attempt to align with frame boundaries, since most tasks don’t need to be frame aligned; for those that do, use requestAnimationFrame.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;deadline&quot;&gt;&lt;a href=&quot;#deadline&quot; aria-label=&quot;deadline permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;deadline&lt;/h3&gt;
&lt;p&gt;Yield after &lt;code class=&quot;language-text&quot;&gt;yieldInterval&lt;/code&gt; ms, regardless of where we are in the vsync cycle. This means there’s always time remaining at the beginning of the message event.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1초에 60프레임을 뽑으려면 대충 16ms에 렌더링 파이프라인을 통과해야 합니다. 리액트는 비동기 함수의 실행을 vsync에 맞출 필요가 없다고 생각했습니다. Work는 메모리 작업이지 렌더링과 관련된 작업이 아니므로 한 프레임에 여러 번(&lt;down&gt;5ms&lt;/down&gt;) 브라우저에 양보한다면 자바스크립트가 렌더링에 큰 영향을 미치지 않는다고 판단하는 것 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;needsPaint&lt;/code&gt;와 shouldYieldToHost() 등 언급은 되었지만 아직 확인하지 않은 부분들은 다음 섹션에서 한 번에 다루도록 하겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;브라우저에게-양보하기-위한-시스템&quot;&gt;&lt;a href=&quot;#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EA%B2%8C-%EC%96%91%EB%B3%B4%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C&quot; aria-label=&quot;브라우저에게 양보하기 위한 시스템 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;브라우저에게 양보하기 위한 시스템&lt;/h1&gt;
&lt;p&gt;host config는 호스트 환경에 따라서 사용하는 구현체가 다른데 그중 하나가 shouldYieldToHost()입니다.
해당 함수는 제어권을 반납해야 하는지 다른 모듈들에게 알려줍니다. 분석은 이 함수부터 시작하겠습니다.&lt;/p&gt;
&lt;p&gt;양보하는 이유는 자바스크립트가 브라우저의 사용자 이벤트 처리나 페인트 작업을 방해하지 않게 하기 위함입니다.
포스트 시작 부분에서 &lt;a href=&quot;#is-input-pending&quot;&gt;isInputPending&lt;/a&gt;에 대해 언급한 내용을 기억하시나요? 해당 api는 유저 이벤트가 대기 중인지 자바스크립트에서 알 수 있습니다. shouldYieldToHost()는 이 api에 따라서 구현 코드가 다릅니다.&lt;/p&gt;
&lt;h2 id=&quot;isinputpending를-지원하는-환경&quot;&gt;&lt;a href=&quot;#isinputpending%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%ED%99%98%EA%B2%BD&quot; aria-label=&quot;isinputpending를 지원하는 환경 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;isInputPending를 지원하는 환경&lt;/h2&gt;
&lt;p&gt;이 환경에서는 사용자 이벤트와 페인트 두 가지를 각각 따로 확인할 수 있습니다.&lt;br&gt;
리액트는 위 두 가지 모두 처리 대기 중이 아니라면 굳이 브라우저에 양보할 필요가 없이 부지런히 재조정 작업을 하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; maxYieldInterval &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; needsPaint &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; deadline &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  enableIsInputPending &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
  navigator &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
  navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;scheduling &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
  navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;scheduling&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isInputPending &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; scheduling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;scheduling

&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token function-variable function&quot;&gt;shouldYieldToHost&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTime &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; deadline&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;needsPaint &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; scheduling&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isInputPending&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;/span&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; maxYieldInterval
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;&lt;/span&gt;  &lt;span class=&quot;token function-variable function&quot;&gt;requestPaint&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    needsPaint &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// isInputPending를 지원하지 않는 환경..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;14 deadline을 넘겼다면 1차 신호입니다.&lt;br&gt;
15 페인트나 사용자 이벤트가 대기 중이라면 바로 브라우저를 위해 콜스택을 비워줘야 합니다.&lt;br&gt;
18 15라인에 해당하지 않는다면? 최대 &lt;code class=&quot;language-text&quot;&gt;maxYieldInterval&lt;/code&gt;&lt;up&gt;300ms&lt;/up&gt;까지 동기적으로 작업을 계속해서 진행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;사용자 이벤트 여부를 알려주는 isInputPending()의 경우 브라우저 api입니다. 그렇다면 페인트가 필요한지에 대한 여부는 어디서 알 수 있을까요? 이 부분은 리액트의 VDOM 결과물을 반영하기 위한 페인트 여부만 알 수 있습니다. 이 부분은 &lt;code class=&quot;language-text&quot;&gt;requestPaint()&lt;/code&gt;을 통해 commit phase에서 설정합니다. commit phase가 끝났다면 브라우저가 화면을 페인트 할 차례이기 때문입니다.&lt;/p&gt;
&lt;h2 id=&quot;isinputpending를-지원하지-않는-환경&quot;&gt;&lt;a href=&quot;#isinputpending%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%ED%99%98%EA%B2%BD&quot; aria-label=&quot;isinputpending를 지원하지 않는 환경 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;isInputPending를 지원하지 않는 환경&lt;/h2&gt;
&lt;p&gt;이전 환경과는 다르게 여기서는 페인트 여부만 알 수 있지 사용자의 이벤트 여부는 모릅니다. 그렇다는 건 어쩔 수 없이 주기적으로 콜스택을 비워줘야 합니다. 그래서 굳이 페인트 여부도 관리할 필요가 없습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// scheduler &gt; SchedulerHostConfig.default.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; maxYieldInterval &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; needsPaint &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; deadline &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isInputPending &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// isInputPending를 지원하는 환경..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;shouldYieldToHost&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; deadline
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;requestPaint&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;isInputPending을 사용하던 shouldYieldToHost()에서는 maxYieldInterval를 비교했지만 한 프레임에 짧은 기간 주기적으로 양보를 해야 되는 환경에서는 &lt;code class=&quot;language-text&quot;&gt;deadline&lt;/code&gt;으로 비교합니다.&lt;/p&gt;
&lt;p&gt;deadline은 기본적으로 5ms입니다. 왜냐면 deadline을 계산하는 피연산자 중 하나인 yieldInterval가 숫자가 5였었습니다. 리액트는 이 주기를 변경할 수 있는 함수를 제공합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function-variable function&quot;&gt;forceFrameRate&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fps &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; fps &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;125&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&apos;forceFrameRate takes a positive int between 0 and 125, &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;token string&quot;&gt;&apos;forcing framerates higher than 125 fps is not unsupported&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fps &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    yieldInterval &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; fps&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// reset the framerate&lt;/span&gt;
    yieldInterval &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;shouldyieldtohost을-사용하는-위치&quot;&gt;&lt;a href=&quot;#shouldyieldtohost%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9C%84%EC%B9%98&quot; aria-label=&quot;shouldyieldtohost을 사용하는 위치 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;shouldYieldToHost을 사용하는 위치&lt;/h2&gt;
&lt;p&gt;우리는 이미 한군데는 알고 있습니다. 바로 scheduler에서 task queue를 소비하는 workLoop() 입니다. shceduler에는 한군데 더 있습니다.&lt;br&gt;
scheduler 내부가 아닌 외부에 있는 reconciler에게 제공하는 함수에서 사용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;unstable_shouldYield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token function&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firstTask &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstTask &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; currentTask &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;/span&gt;      currentTask &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      firstTask &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      firstTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callback &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      firstTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;startTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      firstTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; currentTask&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token function&quot;&gt;shouldYieldToHost&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reconciler에서 concurrent mode의 Work는 중간에 중지할 수 있다고 했습니다. 중지할 수 있는 근거가 바로 위 코드에 나와 있습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;shouldYieldToHost()&lt;/code&gt;는 당연하게 브라우저를 위해 중지합니다. 이때는 잔여 작업이 있음을 나타내는 &lt;a href=&quot;#work_loop&quot;&gt;callback을 반환&lt;up&gt;21라인&lt;/up&gt;&lt;/a&gt; 함으로서 다음 틱에 잔여 작업을 계속해서 처리할 수 있도록 했습니다.&lt;br&gt;
이 함수는 그렇다 치고 옆에 있는 조건은 무엇을 뜻하는지 하나씩 뜯어보면서 확인해보겠습니다.&lt;/p&gt;
&lt;p&gt;3 timeout Timer를 task queue로 옮깁니다.&lt;br&gt;
4 task queue가 3으로 인해 재정렬 되었을 수도 있으므로 가장 우선순위가 높은 Task를 task queue에서 꺼내옵니다.&lt;br&gt;
6 ~ 11 현재 처리되고 있는 Task보다 우선순위가 높은 새로운 Task가 새롭게 task queue에 들어왔기 때문에 현재 Task를 잠시 중단하고 새로운 Task를 먼저 처리하기 위한 조건입니다.&lt;/p&gt;
&lt;p&gt;마지막으로 reconciler에서 위 함수를 사용하는 코드를 확인하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberWorkLoop.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Scheduler_shouldYield &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; shouldYield &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;...&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoopSync&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Already timed out, so perform work without checking if we need to yield.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgress &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    workInProgress &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgress&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoopConcurrent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Perform work until Scheduler asks us to yield&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgress &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;shouldYield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    workInProgress &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgress&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 함수들은 컴포넌트 단위의 재조정 작업을 진행하는 함수입니다.&lt;br&gt;
첫 번째 함수는 legacy mode, blocking mode에서 사용하고 두번째는 concurrent mode에서 사용합니다.&lt;br&gt;
while문의 조건을 자세히 보면 concurrent mode에서만 &lt;code class=&quot;language-text&quot;&gt;shouldYield()&lt;/code&gt;를 사용하고 있습니다. 이 모드에서는 작업을 특정 컴포넌트까지 진행하다 중지시킬 수 있음을 해당 코드를 보고 알 수 있습니다. 여기서 중지된 Work는 추가 작업을 알리는 callback을 반환해야 하는데 이 부분은 다음 포스트인 reconciler에서 재조정 작업과 함께 알아보도록 하겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-scheduler_1/&quot;&gt;React 톺아보기- 04. Scheduler_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-reconciler/&quot;&gt;React 톺아보기- 05. Reconciler&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 04. Scheduler_1]]></title><description><![CDATA[모든 설명은 v16.12.…]]></description><link>https://github.com/goidle/react/in-depth-react-scheduler_1/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-scheduler_1/</guid><pubDate>Sun, 21 Jun 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;사용자가 컴포넌트의 상태를 업데이트하기 위해 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;를 사용했을 때 이 함수에서 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;update&lt;/code&gt;를 연결하고 마지막에 업데이트를 반영하기 위해 Work를 &lt;code class=&quot;language-text&quot;&gt;scheduleWork()&lt;/code&gt;로 스케줄링시켰습니다. 이번 포스트에서는 &lt;code class=&quot;language-text&quot;&gt;shceduleWork()&lt;/code&gt;를 시작으로 scheduler의 전반적인 흐름을 알아볼 것입니다.&lt;/p&gt;
&lt;p&gt;리액트의 scheduler는 push 방식이 아닌 pull 방식입니다. 이 말이 무슨 뜻이냐면 Work의 실행 제어권을 좀 더 똑똑한 scheduler에게 위임하는 겁니다. reconciler가 스스로 판단해서 Work를 실행하는 게 아닌 이 부분에서 좀 더 똑똑한 scheduler가 브라우저의 상태와 여러 조건을 기반으로 실행하기 적절할 때 스스로 판단해서 Work를 실행하는 걸 뜻합니다.&lt;/p&gt;
&lt;p&gt;다음은 우리가 알아볼 스케줄링 흐름도입니다.&lt;/p&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 790px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaElEQVQoz6VTXXODMAzj//9KXnq9G6OFUPJta3Io0G3d03KnMwHHluTQqSrewdYwDOj7HpfLBdfrtUV7Z98rISVhGS6YZoecc3vfHQV2AG0vKvhrLTnhI3rMjMdSnAWFG8/ziQ+xVKwlw5XCgxk+JczJCgSM3mN4LJhSxMycWCs8i4ZaUEUaoc44aU2ocaSEFbUEiFQoYbHUzOTaGNu+skgxVTznrSmbWTwLGsM4QZceEgaUMKFEB/H0Ki9stECLZ86dkfuwojweABlnMhYy3W1qkkVKK2L2lcRkPxI31Bwai01B2BqkOxuEVlDdDFA+QjiGqLvkmj0T3WauGU0JBqVX0jzehqQGpti4hBKbFXWzwaCnh/xgndlNJkpbHOL4icDniQ1Gm+pzEI55t+BxsyExOr9ico5Ew/dr0zpbXCnHvCEDJWyCgWxbfE5TD9Z62HJK/nmpd9+eCb/W6+V/80N0u/7XSf0HXxOEYWAsL3OCAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;scheduling flow&quot; title=&quot;scheduling flow&quot; src=&quot;/static/9e327099e752bd46cae5074351cfbe5c/c94d1/scheduling_flow.png&quot; srcset=&quot;/static/9e327099e752bd46cae5074351cfbe5c/0780f/scheduling_flow.png 198w,
/static/9e327099e752bd46cae5074351cfbe5c/47b26/scheduling_flow.png 395w,
/static/9e327099e752bd46cae5074351cfbe5c/c94d1/scheduling_flow.png 790w,
/static/9e327099e752bd46cae5074351cfbe5c/9e288/scheduling_flow.png 1185w,
/static/9e327099e752bd46cae5074351cfbe5c/9adaa/scheduling_flow.png 1580w,
/static/9e327099e752bd46cae5074351cfbe5c/bf7ce/scheduling_flow.png 2560w&quot; sizes=&quot;(max-width: 790px) 100vw, 790px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
&lt;p&gt;흐름도를 보면 함수들이 같은 패키지에 있는 게 아닙니다. 패키지가 다르다는 건 하는 일이 완전히 다르다는 걸 뜻합니다.&lt;br&gt;
들어가기 전 이 부분을 미리 생각해서 각 섹션을 시작하시면 좀 더 따라가기 편하실 것 같습니다.&lt;br&gt;
reconciler는 VDOM 재조정 작업 전에 설정해줘야 하는 부분들이 주를 이룰 것이고 scheduler는 스케줄링 된 Task에 우선순위 반영과 실행하기 적절한 때를 판단하고 작업의 진행과 중단을 담당하는 코드들이 주를 이룰 것입니다.&lt;/p&gt;
&lt;p&gt;추가로 scheduler 중에 host config가 있는데 이 부분은 사용자의 호스트 환경에 맞는 api를 사용하기 위한 모듈입니다. 여기에는 비동기 api, performance, &lt;a href=&quot;https://wicg.github.io/is-input-pending/&quot; target=&quot;_blank&quot;&gt;isInputPending&lt;/a&gt; 등이 있습니다.&lt;/p&gt;
&lt;a id=&quot;is-input-pending&quot;&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;isinputpending&quot;&gt;&lt;a href=&quot;#isinputpending&quot; aria-label=&quot;isinputpending permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;isInputPending&lt;/h3&gt;
&lt;p&gt;Facebook이 처음으로 기여한 브라우저 API로 이름 그대로 자바스크립트에서 알 수 없었던 대기 중인 input event가 있는지 확인할 수 있습니다. 이를 이용하여 자바스크립트가 메인 스레드를 계속해서 점유하고 있어도 되는지 판단할 수 있습니다.&lt;br&gt;
리액트는 이 API가 어떤 상황일 때 필요했냐면 concurrent mode에서 VDOM 재조정 작업을 할 때 혹시 있을지 모를 브라우저의 페인트 작업이나 사용자의 input event를 처리하기 위해 할당된 시간이 지나면 잠시 콜스택을 비워주었습니다. 굳이 브라우저가 필요하지 않은 상황인데도 이런 불필요한 동작을 계속할 수 밖에 없었습니다.&lt;br&gt;
이제 isInputPending api를 이용하여 브라우저가 메인 스레드의 점유가 필요할 때만 작업을 잠시 멈춰 브라우저에게 양보를 하고 그럴 필요가 없다면 VDOM 재조정 작업을 계속해서 동기적으로 진행할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-dispatchaction&quot;&gt;&lt;a href=&quot;#1-dispatchaction&quot; aria-label=&quot;1 dispatchaction permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. dispatchAction&lt;/h1&gt;
&lt;p&gt;해당 함수는 Hooks에서 이미 자세히 알아보았습니다. 다만 한가지 꺼림칙한 부분은 render phase에서 호출되는 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;은 따로 &lt;code class=&quot;language-text&quot;&gt;scheduleWork()&lt;/code&gt;를 통해 Work를 스케줄링하지 않았고 idle 상태에서의 호출일 때만 작업을 스케줄링했습니다. 근데 로직만 보면 idle 상태에서의 매 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt; 호출마다 &lt;code class=&quot;language-text&quot;&gt;scheduleWork()&lt;/code&gt;도 같이 동작합니다. 이러면 같은 컴포넌트에 대한 복수의 Work가 스케줄링 되지 않을까요? 이 부분을 리액트에서는 어떻게 처리했는지 바로 다음 &lt;code class=&quot;language-text&quot;&gt;scheduleWork&lt;/code&gt; 섹션에서 확인해 보도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;render phase update&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// idle update..&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;scheduleWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-schedulework&quot;&gt;&lt;a href=&quot;#2-schedulework&quot; aria-label=&quot;2 schedulework permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. scheduleWork&lt;/h1&gt;
&lt;p&gt;코드는 ReactFiberWorkLoop.js에 &lt;code class=&quot;language-text&quot;&gt;scheduleUpdateOnFiber()&lt;/code&gt; 이름으로 정의되어 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; scheduleWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; scheduleUpdateOnFiber&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;reconciler가-해야하는-일&quot;&gt;&lt;a href=&quot;#reconciler%EA%B0%80-%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%BC&quot; aria-label=&quot;reconciler가 해야하는 일 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;reconciler가 해야하는 일&lt;/h2&gt;
&lt;p&gt;재조정 작업을 스케줄링하기 전에 reconciler에서 해야 할 일은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;해당 컴포넌트에서 이벤트가 발생했음을 알리는 expirationTime을 새긴다.&lt;/li&gt;
&lt;li&gt;이벤트가 발생한 컴포넌트의 VDOM root을 가지고 온다.&lt;/li&gt;
&lt;li&gt;스케줄링 정보를 저장한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;현 상황에서 root가 왜 필요한지를 먼저 보자면 리액트를 레거시 코드에 도입한다고 했을 때 여러 root를 가지고 있을 수 있습니다. 그리고 그 root마다 개별적으로 VDOM을 생성하겠죠. 제가 하고 싶은 말은 하나의 VDOM을 나타내는 변하지 않는 유일한 값은 root 객체라는 말입니다. 그리고 Work는 VDOM 전체를 관통하는 이벤트로 해당 VDOM과 1:1 의존성을 가지고 있는 작업입니다. 그런데 여기서 하나의 VDOM에 여러 업데이트가 발생하여 복수의 Work가 스케줄링 되어야 하는 상황이 있을 수 있습니다. 이때 교통정리가 필요한데 그 역할을 reconciler가 담당하고, 정리의 기준은 Work를 스케줄링시켰던 정보를 이용하여 판단합니다. 그래서 VDOM을 대표하는 root에 이 스케줄링 정보를 저장합니다. 이 내용이 3번, 스케줄링 정보를 scheduler만 알고 있지 않고 따로 저장해놓는 이유입니다.&lt;/p&gt;
&lt;p&gt;2번의 경우 위 이유로 root가 필요하기도 하고 VDOM 재조정 작업의 시작과 끝은 항상 root이기 때문에 Work 함수를 넘겨줄때 root의 정보가 필요하기도 합니다.&lt;/p&gt;
&lt;p&gt;스케줄링 정보가 필요한 이유가 VDOM 입장에서의 거시적인 느낌이 있다면 expirationTime이 필요한 이유는 컴포넌트와 관련된 미시적인 느낌이 있습니다. fiber에 expirationTime이 새겨졌다는 건 해당 컴포넌트에서 이벤트가 발생했다는 의미로 이 의미를 가지고 리액트 곳곳에서 처리할 수 있는 사례들이 있습니다. 이 부분은 이번 포스트와 다음 포스트인 reconciler에서 차차 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;expirationtime-새기기&quot;&gt;&lt;a href=&quot;#expirationtime-%EC%83%88%EA%B8%B0%EA%B8%B0&quot; aria-label=&quot;expirationtime 새기기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;expirationTime 새기기&lt;/h2&gt;
&lt;p&gt;먼저 expirationTime을 어떻게 새기는지 알아보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduleUpdateOnFiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 업데이트가 발생한 컴포넌트&lt;/span&gt;
  expirationTime
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// expirationTime을 새기고 root를 가지고 온다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;markUpdateTimeFromFiberToRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;먼저 업데이트가 발생한 fiber에 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 새깁니다. 그리고 root를 찾기 위해 fiber의 부모부터 시작해 위로 위로 올라가 root까지 도달하게 된다면 root를 반환할 텐데 이 과정에서 거쳐 가는 fiber에도 시간을 새깁니다. 이 시간을 expirationTime으로 새기지 않고 &lt;code class=&quot;language-text&quot;&gt;childExpirationTime&lt;/code&gt;으로 새깁니다.&lt;br&gt;
그리고 이 부분은 재조정 작업에서 매우 중요하게 사용됩니다. 자세한 내용은 다음 포스트인 reconciler에서 다루고 지금은 그냥 &lt;u&gt;자식에서 업데이트가 발생하면 자신에게 childExpirationTime이 새겨진다.&lt;/u&gt; 라고만 알고 있겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber() &gt; markUpdateTimeFromFiberToRoot()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;markUpdateTimeFromFiberToRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// expirationTime을 새긴다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; alternate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// root를 찾아 위로 올라간다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tag &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; HostRoot&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stateNode&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      alternate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate
      &lt;span class=&quot;token comment&quot;&gt;// 이하 childExpirationTime를 새긴다.&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
          alternate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
          alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; expirationTime
        &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        alternate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; expirationTime
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// root 라면&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tag &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; HostRoot&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;        root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stateNode&lt;/span&gt;        &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; root
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;계속해서 말씀드리는 부분이지만 current와 workInprogress 모두 처리해주고 있습니다. 왜일까요?&lt;br&gt;
현재 우리는 어떤 함수의 호출부터 시작해서 여기까지 왔습니까? dispatchAction()입니다. 그리고 그 당시에 workInProgress였던 fiber를 bind로 잡아두었습니다. 그 fiber가 지금 여기까지 인자로 넘어오고 있는 것입니다. 이 정도 설명이면 위 질문에 대답할 수 있을 것이고 그렇지 못하다면 &lt;a href=&quot;/react/in-depth-react-hooks_1/#dispatchAction()&quot;&gt;여기&lt;/a&gt;를 다시 읽고 오시면 되겠습니다.&lt;/p&gt;
&lt;p&gt;15, 36 라인이 root를 반환하는 코드입니다. 해당 라인에서의 fiber는 current 혹은 workInProgress의 최상단 fiber(e.g. &amp;#x3C;App/&gt;) 입니다. 그리고 최상단 fiber에서 &lt;code class=&quot;language-text&quot;&gt;stateNode&lt;/code&gt;로 root를 참조하고 있습니다. current와 workInProgress의 stateNode는 같은 root를 바라봅니다. 당연히 VDOM에는 하나의 root만 존재하므로.&lt;/p&gt;
&lt;p&gt;현재 업데이트가 발생한 fiber에는 expirationTime을 부모부터 root까지는 childExpirationTime을 새겼으며 동시에 root를 찾아 반환했습니다.&lt;/p&gt;
&lt;h2 id=&quot;work를-동기로-처리할-수-있는지-확인하기&quot;&gt;&lt;a href=&quot;#work%EB%A5%BC-%EB%8F%99%EA%B8%B0%EB%A1%9C-%EC%B2%98%EB%A6%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0&quot; aria-label=&quot;work를 동기로 처리할 수 있는지 확인하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Work를 동기로 처리할 수 있는지 확인하기&lt;/h2&gt;
&lt;anchor id=&quot;flushSyncCallbackQueue()&quot; /&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberHooks.js &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduleUpdateOnFiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 동기&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; Sync&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// VDOM 마운트&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; LegacyUnbatchedContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; NoContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;RenderContext &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CommitContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; NoContext
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;performSyncWorkOnRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// VDOM 업데이트&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; NoContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;flushSyncCallbackQueue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 비동기&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// discrete event 코드 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;라인별로 알아보겠습니다.&lt;br&gt;
5에서 먼저 동기로 처리되어야 하는지 판단합니다.&lt;br&gt;
8, 9의 조건은 VDOM이 처음 생성될 때 충족합니다. 처음 생성될 때는 Work를 굳이 다음 틱으로 넘길 필요 없이 바로 실행해서 VDOM을 완성해줍니다. 동기로 재조정 작업을 수행해줄 함수가 바로 &lt;code class=&quot;language-text&quot;&gt;performSyncWorkOnRoot()&lt;/code&gt;&lt;up&gt;11&lt;/up&gt;입니다.&lt;br&gt;
13 &lt;code class=&quot;language-text&quot;&gt;ensureRootIsScheduled&lt;/code&gt;를 통해 업데이트가 발생한 root에 Work를 스케줄링시켜줍니다.&lt;br&gt;
15번을 통해 리액트가 놀고 있는 걸 확인하면 &lt;code class=&quot;language-text&quot;&gt;flushSyncCallbackQueue()&lt;/code&gt;를 통해 sync queue에 담겨 있는 Work들을 바로 실행시켜 줍니다. 이 부분은 &lt;code class=&quot;language-text&quot;&gt;ensureRootIsScheduled()&lt;/code&gt;에서 동기 Work를 어떻게 처리하는지 확인하면 이해하시기 편하실 겁니다.
20 비동기 작업도 &lt;code class=&quot;language-text&quot;&gt;ensureRootIsScheduled()&lt;/code&gt;를 이용합니다.&lt;/p&gt;
&lt;p&gt;잠시 혼동을 방지하기 위해 함수들의 역할을 좀 더 구분 지어서 생각하고 넘어가겠습니다.&lt;br&gt;
스케줄링과 관련된 본격적인 코드는 ensureRootIsScheduled에 다 담겨 있습니다. 함수 이름을 보면 ensure&lt;strong&gt;‘Root’&lt;/strong&gt;Is&lt;strong&gt;‘Shceduled’&lt;/strong&gt;입니다. root에 Work을 스케줄링하는 코드들이 위치해 있을 법한 이름입니다.&lt;/p&gt;
&lt;p&gt;scheduleWork는 위에서 봤듯이 스케줄링 전과 후에 reconciler 입장에서의 추가 작업 코드들이 존재합니다. 실제 스케줄링 코드는 없습니다. 생략된 discrete event 코드는 SyntheticEvent 포스트에서 다룹니다.&lt;/p&gt;
&lt;h1 id=&quot;3-ensurerootisscheduled&quot;&gt;&lt;a href=&quot;#3-ensurerootisscheduled&quot; aria-label=&quot;3 ensurerootisscheduled permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. ensureRootIsScheduled&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;‘Work를 스케줄링하기 전에 reconciler에서 해야 할 일’&lt;/em&gt;을 설명할 때 복수의 Work가 들어오면 교통정리 하고 스케줄링 정보를 root에 새긴다고 언급했습니다. 그 일을 Shceduled에서 합니다.&lt;/p&gt;
&lt;p&gt;root에 저장되는 스케줄링 정보는 scheduler가 만든 Task 객체, expirationTime, priority이며 callback*** 이름의 형태로 저장됩니다. 교통정리는 이 정보를 이용하여 판단합니다.&lt;/p&gt;
&lt;h2 id=&quot;scheduler에게-work를-넘겨주기-전-사전-준비하기&quot;&gt;&lt;a href=&quot;#scheduler%EC%97%90%EA%B2%8C-work%EB%A5%BC-%EB%84%98%EA%B2%A8%EC%A3%BC%EA%B8%B0-%EC%A0%84-%EC%82%AC%EC%A0%84-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0&quot; aria-label=&quot;scheduler에게 work를 넘겨주기 전 사전 준비하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;scheduler에게 Work를 넘겨주기 전 사전 준비하기&lt;/h2&gt;
&lt;p&gt;본격적으로 expirationTime과 priority를 먼저 가져오겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt;scheduleUpdateOnFiber() &gt; ensureRootIsScheduled()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getNextRootExpirationTimeToWorkOn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; existingCallbackNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callbackNode &lt;span class=&quot;token comment&quot;&gt;// 스케줄링되어 있는 Task 객체&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;requestCurrentTimeForUpdate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; priorityLevel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;inferPriorityFromExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    currentTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    expirationTime
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;시간, 우선순위와 관련된 내용은 깊게 들어가지 않습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;getNextRootExpirationTimeToWorkOn()&lt;/code&gt;는 root가 가지고 있는 정보들을 기반으로(&lt;down&gt;이전 작업이 남아있음을 나타내는 lastExpiredTime, suspend와 관련된 update가 아직 커밋되지 않음을 나타내는 ***PendingTime&lt;/down&gt;) 현재 처리해야 될 expirationTime을 가지고 옵니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;currentTime&lt;/code&gt;은 이전 포스트의 &lt;a href=&quot;/react/in-depth-react-hooks_1/#currentTime&quot;&gt;expirationTime 섹션&lt;/a&gt;에서 보여드렸던 msToExpirationTime() 함수를 이용하여 구합니다.&lt;/p&gt;
&lt;p&gt;우선순위는 코드를 직접 보는 게 이해하기가 더 편합니다.&lt;br&gt;
currentTime은 ms가 아닌 expirationTime임을 생각하시고 코드를 보시길 바랍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;HIGH_PRIORITY_EXPIRATION&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; __DEV__ &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;500&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;150&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;HIGH_PRIORITY_BATCH_SIZE&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOW_PRIORITY_EXPIRATION&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5000&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOW_PRIORITY_BATCH_SIZE&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;250&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber() &gt; ensureRootIsScheduled() &gt; inferPriorityFromExpirationTime()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;inferPriorityFromExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;currentTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  expirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ReactPriorityLevel &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; Sync&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; ImmediatePriority
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; Never &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; Idle&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; IdlePriority
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; msUntil &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;expirationTimeToMs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;expirationTimeToMs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msUntil &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; ImmediatePriority
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msUntil &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;HIGH_PRIORITY_EXPIRATION&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;HIGH_PRIORITY_BATCH_SIZE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; UserBlockingPriority
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msUntil &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOW_PRIORITY_EXPIRATION&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;LOW_PRIORITY_BATCH_SIZE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; NormalPriority
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; IdlePriority
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;msUntil&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에서 ms를 구한 시간으로 expirationTime은 높은 수가 더 이전 시간을 나타내는 데 반해 ms는 우리가 통상 생각하는 시간으로 큰 수가 더 늦은 시간을 나타냅니다. 이걸 기준으로 expirationTime이 currentTime을 넘기게 되면 빠르게 처리해줘야 하므로 &lt;code class=&quot;language-text&quot;&gt;ImmediatePriority&lt;/code&gt;을 반환해주고 나머지 우선순위는 expirationTime이 얼마나 더 여유가 있지에 따라 다른 우선순위를 반환합니다.&lt;/p&gt;
&lt;h2 id=&quot;work-교통정리-하기&quot;&gt;&lt;a href=&quot;#work-%EA%B5%90%ED%86%B5%EC%A0%95%EB%A6%AC-%ED%95%98%EA%B8%B0&quot; aria-label=&quot;work 교통정리 하기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Work 교통정리 하기&lt;/h2&gt;
&lt;p&gt;스케줄링에 필요한 정보들을 모두 구했고 스케줄링된 내용은 root에 있으므로 이를 이용하여 현재 업데이트를 반영할 Work를 스케줄링해야 할지 판단하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber() &gt; ensureRootIsScheduled()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const priorityLevel = inferPriorityFromExpirationTime(&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//   currentTime,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//   expirationTime,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// );&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;existingCallbackNode &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; existingCallbackPriority &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callbackPriority
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; existingCallbackExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callbackExpirationTime
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      existingCallbackExpirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; expirationTime &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      existingCallbackPriority &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; priorityLevel
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Existing callback is sufficient.&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;cancelCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;existingCallbackNode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;root에-스케줄링-정보-새기기&quot;&gt;&lt;a href=&quot;#root%EC%97%90-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%A0%95%EB%B3%B4-%EC%83%88%EA%B8%B0%EA%B8%B0&quot; aria-label=&quot;root에 스케줄링 정보 새기기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;root에 스케줄링 정보 새기기&lt;/h2&gt;
&lt;p&gt;기존 Work를 취소했으므로 새로운 Work를 스케줄링합니다. 여기에서도 마찬가지로 작업을 동기적으로 처리해도 되는지 판단합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber() &gt; ensureRootIsScheduled()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (existingCallbackNode !== null) {&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//   생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//   cancelCallback(existingCallbackNode);&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// }&lt;/span&gt;

  root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callbackExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; expirationTime
  root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callbackPriority &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; priorityLevel

  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; callbackNode
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; Sync&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Sync React callbacks are scheduled on a special internal queue&lt;/span&gt;
    callbackNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduleSyncCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;performSyncWorkOnRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Task를 반환&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    callbackNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Compute a task timeout based on the expiration time. This also affects&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// ordering because tasks are processed in timeout order.&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; timeout&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;expirationTimeToMs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Task를 반환&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callbackNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; callbackNode &lt;span class=&quot;token comment&quot;&gt;// Task를 root에 저장한다.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;performSyncWorkOnRoot()&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;performConcurrentWorkOnRoot()&lt;/code&gt;는 Work를 담당하는 함수이며 후자의 함수는 concurrent mode에서 사용됩니다. 이 함수들이 Task의 callback에 저장됩니다. bind로 root를 물고 있는 걸 기억하기실 바랍니다.&lt;/p&gt;
&lt;p&gt;아직까지도 scheduler와 직접적으로 연관된 코드들이 등장하지 않았습니다. 이 함수에서 scheduler의 모듈을 import해서 Work함수을 스케줄할 수도 있지만 리액트는 reconciler와 scheduler 사이의 의존성을 낮추기 위해 SchedulerWithReactIntegration.js라는 모듈을 따로 두었습니다. 이 모듈에 속한 함수가 &lt;code class=&quot;language-text&quot;&gt;scheduleSyncCallback()&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;scheduleCallback()&lt;/code&gt;입니다.&lt;/p&gt;
&lt;h1 id=&quot;4-schedulesynccallback-schedulecallback&quot;&gt;&lt;a href=&quot;#4-schedulesynccallback-schedulecallback&quot; aria-label=&quot;4 schedulesynccallback schedulecallback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. scheduleSyncCallback, scheduleCallback&lt;/h1&gt;
&lt;h2 id=&quot;async-work&quot;&gt;&lt;a href=&quot;#async-work&quot; aria-label=&quot;async work permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;async work&lt;/h2&gt;
&lt;p&gt;callback과 syncCallback 중에 일반적인 callback을 먼저 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber() &gt; ensureRootIsScheduled() &gt; SchedulerWithReactIntegration.js &gt; scheduleCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;reactPriorityLevel&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ReactPriorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  callback&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; SchedulerCallback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  options&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; SchedulerCallbackOptions &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; priorityLevel &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reactPriorityToSchedulerPriority&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;reactPriorityLevel&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Scheduler_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;priorityLevel&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; callback&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reconciler와 scheduler의 우선순위 내부값이 다르기 때문에(&lt;down&gt;ImmediatePriority = 99, 1&lt;/down&gt;) scheduler에게 넘기기 전에 변환합니다.&lt;br&gt;
이 우선순위와 callback&lt;up&gt;Work함수&lt;/up&gt;, options를 넘겨주며 scheduler에게 스케줄링을 요청합니다. 이제 이 Work는 scheduler가 알아서 실행시킬 겁니다. reconciler는 여기까지 왔으면 할 일을 다 한 상태입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;options에는 Task의 만료 시간을 나타내는 timeout과 시작 시간을 미룰수 있는 delay가 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;sync-work&quot;&gt;&lt;a href=&quot;#sync-work&quot; aria-label=&quot;sync work permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;sync work&lt;/h2&gt;
&lt;p&gt;하지만 syncCallback의 처리는 조금 다릅니다.&lt;br&gt;
동기적으로 실행한다면 scheduler의 힘을 빌릴 필요 없이 reconciler가 내부적으로 처리하면 됩니다. Work가 곧 reconciler의 행위이기 때문입니다. 그래서 sync 작업들은 내부 queue에 따로 저장해 놓습니다. 그리고 실행하기 적당한 때를 reconciler가 판단해서 queue에 있는 작업들을 동기적으로 모두 실행해줍니다.&lt;br&gt;
이 행위를 하는 함수가 flushSyncCallbackQueue()이며 scheduleWork()에서 사용했던 &lt;a href=&quot;#flushSyncCallbackQueue()&quot;&gt;함수&lt;/a&gt;가 이 함수였습니다.&lt;/p&gt;
&lt;anchor id=&quot;scheduleSyncCallback()&quot;&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction() &gt; ReactFiberWorkLoop.js &gt; scheduleUpdateOnFiber() &gt; ensureRootIsScheduled() &gt; SchedulerWithReactIntegration.js &gt; scheduleSyncCallback()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;scheduleSyncCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;callback&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; SchedulerCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Push this callback into an internal queue. We&apos;ll flush these either in&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// the next tick, or earlier if something calls `flushSyncCallbackQueue`.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;syncQueue &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    syncQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;callback&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Flush the queue in the next tick, at the earliest.&lt;/span&gt;
    immediateQueueCallbackNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Scheduler_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      Scheduler_ImmediatePriority&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      flushSyncCallbackQueueImpl
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Push onto existing queue. Don&apos;t need to schedule a callback because&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// we already scheduled one when we created the queue.&lt;/span&gt;
    syncQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;callback&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; fakeCallbackNode
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;주석으로 너무 잘 설명하고 있어서 일부러 지우지 않았습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;callback&lt;/code&gt;은 Work를 담당하는 performSyncWorkOnRoot() 입니다. 비동기 작업과는 다르게 callback을 스케줄링하지 않고 내부 큐에 넣습니다. 그리고 대신 이 큐를 flush하는 &lt;code class=&quot;language-text&quot;&gt;flushSyncCallbackQueueImpl()&lt;/code&gt;를 스케줄링해줍니다. 이 부분이 비동기 작업이랑 다른 부분입니다.&lt;/p&gt;
&lt;p&gt;scheduleWork()에서 사용한 flushSyncCallbackQueue() 또한 내부적으로 flushSyncCallbackQueueImpl()를 사용하고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-js line-numbers&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberWorkLoop.js &gt; flushSyncCallbackQueue()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;flushSyncCallbackQueue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;immediateQueueCallbackNode &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; immediateQueueCallbackNode
    immediateQueueCallbackNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token function&quot;&gt;Scheduler_cancelCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;flushSyncCallbackQueueImpl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 sync Work를 스케줄링했다면 flushSyncCallbackQueueImpl Task가 스케줄링된 상태로 남아 있을 겁니다. flushSyncCallbackQueue()는 reconciler에서 판단해서 Work 함수를 실행하는 것으로 스케줄링 된 Task와 중복 작업을 하게 됩니다. 이 Task를 취소하는 부분이 6번째 라인입니다.&lt;/p&gt;
&lt;p&gt;마지막으로 실질적으로 sync queue를 flush하는 함수인 &lt;code class=&quot;language-text&quot;&gt;flushSyncCallbackQueueImpl()&lt;/code&gt;만 확인하면 우리는 reconciler가 하는 일을 모두 확인하게 되는 겁니다.&lt;/p&gt;
&lt;h1 id=&quot;11-flushsynccallbackqueueimpl&quot;&gt;&lt;a href=&quot;#11-flushsynccallbackqueueimpl&quot; aria-label=&quot;11 flushsynccallbackqueueimpl permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;11. flushSyncCallbackQueueImpl&lt;/h1&gt;
&lt;p&gt;이미 알아본바 이 함수는 scheduler에 의해서 비동기로 호출될 수도 있고 reconciler에서 flushSyncCallbackQueue()를 통해 동기적으로 호출될 수도 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; SchedulerWithReactIntegration.js &gt; flushSyncCallbackQueueImpl()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;flushSyncCallbackQueueImpl&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isFlushingSyncQueue &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; syncQueue &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Prevent re-entrancy.&lt;/span&gt;
    isFlushingSyncQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isSync &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syncQueue
      &lt;span class=&quot;token function&quot;&gt;runWithPriority&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ImmediatePriority&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; callback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            callback &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isSync&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;callback &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      syncQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 에러가 발생한 callback만 버린다.&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;syncQueue &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        syncQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; syncQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Resume flushing in the next tick&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;Scheduler_scheduleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        Scheduler_ImmediatePriority&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        flushSyncCallbackQueue
      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; error
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      isFlushingSyncQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;로직은 특별한 게 없으므로 생소한 &lt;code class=&quot;language-text&quot;&gt;runWithPriority()&lt;/code&gt;만 짚고 넘어가겠습니다.&lt;br&gt;
runWithPriority()는 shceduler의 컨텍스트 변수인 &lt;code class=&quot;language-text&quot;&gt;currentPriorityLevel&lt;/code&gt;에 실행할 함수의 우선순위를 할당하는 함수입니다.&lt;br&gt;
이렇게 함으로서 Work와 관련된 작업의 실행과 그 우선순위를 모두 scheduler가 관리하게 되면서 서로 혼재될 수 있는 부분을 확실히 나누게 되었습니다.
이제 reconciler는 현재 동작하고 있는 Work의 우선순위를 기준으로 추가 작업이 필요할 때 scheduler의 현재 컨텍스트 우선순위만 가지고 오면 됩니다. Work는 순차 실행이 아니며 언제든지 중지되고 재실행 될 수 있기 때문에 reconciler가 더욱이 이 작업들의 우선순위를 가지고 있을 수 없는 겁니다.&lt;/p&gt;
&lt;p&gt;reconciler의 코드는 여기서 끝입니다. 다음 포스트에서는 scheduler의 코드를 확인합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-hooks_2/&quot;&gt;React 톺아보기- 03. Hooks_2&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-scheduler_2/&quot;&gt;React 톺아보기- 04. scheduler_2&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 03. Hooks_2]]></title><description><![CDATA[모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 3. Hook은 어떻게 구현되어 있을까? 이전 포스트에 이어서 다음은 update…]]></description><link>https://github.com/goidle/react/in-depth-react-hooks_2/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-hooks_2/</guid><pubDate>Mon, 15 Jun 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3-hook은-어떻게-구현되어-있을까&quot;&gt;&lt;a href=&quot;#3-hook%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;3 hook은 어떻게 구현되어 있을까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Hook은 어떻게 구현되어 있을까?&lt;/h1&gt;
&lt;p&gt;이전 포스트에 이어서 다음은 update 구현체를 보도록 하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;update-구현체&quot;&gt;&lt;a href=&quot;#update-%EA%B5%AC%ED%98%84%EC%B2%B4&quot; aria-label=&quot;update 구현체 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;update 구현체&lt;/h2&gt;
&lt;h3 id=&quot;1-훅-객체-가지고-오기&quot;&gt;&lt;a href=&quot;#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%98%A4%EA%B8%B0&quot; aria-label=&quot;1 훅 객체 가지고 오기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 훅 객체 가지고 오기&lt;/h3&gt;
&lt;p&gt;훅의 구현체는 컴포넌트가 마운트된 이후에는 항상 update 구현체를 사용합니다. 구현체를 갈아 끼우는 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;를 다시 한 번 더 확인해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderWithHooks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 훅이 사용되었다면 memoizedState에 훅 리스트가 존재&lt;/span&gt;
  nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// mount, update 여부에 따라 구현체 주입&lt;/span&gt;
  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; HooksDispatcherOnMount &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HooksDispatcherOnUpdate

  &lt;span class=&quot;token comment&quot;&gt;// let children = Component(props, refOrContext)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트 실행 후 처리된 훅 리스트를 저장&lt;/span&gt;
  renderedWork&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook
  &lt;span class=&quot;token comment&quot;&gt;// 비동기로 훅을 사용할 경우를 대비한 error throw 구현체&lt;/span&gt;
  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ContextOnlyDispatcher
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;마운트 이후 컴포넌트가 실행될 때마다 우리가 작성한 &lt;code class=&quot;language-text&quot;&gt;useState()&lt;/code&gt;는 다음의 &lt;code class=&quot;language-text&quot;&gt;updateState()&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;basicStateReducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;updateState()&lt;/code&gt;는 그저 &lt;code class=&quot;language-text&quot;&gt;updateReducer()&lt;/code&gt;로 포워딩하는 함수입니다. 그리고 함수 이름에서 알 수 있듯이 &lt;code class=&quot;language-text&quot;&gt;useReducer()&lt;/code&gt;의 update 구현체입니다. &lt;code class=&quot;language-text&quot;&gt;useState()&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt;을 처리하는 reducer가 &lt;code class=&quot;language-text&quot;&gt;basicStateReducer&lt;/code&gt;로 고정된 훅입니다. 두 개의 차이는 reducer를 사용자가 넘겨준 reducer를 사용하느냐 아니면 basic을 사용하느냐의 차이만 있습니다.&lt;/p&gt;
&lt;p&gt;첫 시작을 마운트는 훅을 만들었고 업데이트는 이전에 만들어논 훅을 가지고 옵니다. 훅의 head는 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 미리 꺼내 놓았던 &lt;code class=&quot;language-text&quot;&gt;nextCurrentHook&lt;/code&gt;을 사용합니다. 그리고 모든 훅은 이 타이밍에 이전 훅을 바로 사용하지 않고 VDOM처럼 작업용 훅 객체 만들어서 사용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateState() &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer() &gt; updateWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (nextWorkInProgressHook !== null) {&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 리-렌더링시 아래에서 만들어논 객체를 재사용하는 로직..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// } else {&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// current의 훅 head&lt;/span&gt;
  currentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextCurrentHook
  &lt;span class=&quot;token comment&quot;&gt;// 작업용 훅 객체를 만든다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newHook&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    memoizedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

    baseState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgressHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// This is the first hook in the list.&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newHook
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Append to the end of the list.&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newHook
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next
  &lt;span class=&quot;token comment&quot;&gt;// }&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;컴포넌트는 실행될 때마다 추가적인 업데이트가 발생할 수 있었습니다. 이때 재실행마다 매번 작업용 훅 객체를 새로만들 필요가 없기 때문에 위에서 만들어놓은 훅 객체를 재사용합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer() &gt; updateWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// nextWorkInProgressHook를 통해 컴포넌트 재실행으로 인한 호출인지 판단&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// There&apos;s already a work-in-progress. Reuse it.&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextWorkInProgressHook
    nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next
    &lt;span class=&quot;token comment&quot;&gt;// current hook&lt;/span&gt;
    currentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextCurrentHook
    nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentHook &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 훅 연결 리스트의 head&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// currentHook = nextCurrentHook;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; workInProgressHook
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 컴포넌트를 재실행시켜주는 로직을 보면 컴포넌트 실행 직전에 다음과 같이 전역변수를 셋팅했었습니다.
&lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;은 작업용 훅을 만들때 전역으로 잡아 두었고 &lt;code class=&quot;language-text&quot;&gt;nextCurrentHook&lt;/code&gt;은 current fiber에서 꺼내옵니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook
&lt;span class=&quot;token comment&quot;&gt;// children = Component(props, refOrContext);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-code-classlanguage-textbaseupdatecode와-circular-linked-list&quot;&gt;&lt;a href=&quot;#2-code-classlanguage-textbaseupdatecode%EC%99%80-circular-linked-list&quot; aria-label=&quot;2 code classlanguage textbaseupdatecode와 circular linked list permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;와 &lt;em&gt;Circular Linked List&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;훅 객체를 만들 때 설명을 생략했던 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;, 그리고 update가 왜 &lt;em&gt;Circular Linked List&lt;/em&gt;인지 알아볼 차례가 왔습니다. 기억나지 않을 수 있으니 해당 부분만 뜯어오겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState() &gt; mountWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  memoizedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트에 적용된 마지막 상태값&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 훅이 여러 번 실행될 때 update들을 queue에 연결리스트로 저장한다.&lt;/span&gt;
  next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 다음 훅을 가리키는 노드 포인터&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 이하 update 구현체에서 설명&lt;/span&gt;
  baseState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// update를 queue에 연결리스트로 추가&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// This is the first update. Create a circular list.&lt;/span&gt;
  update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;first &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Still circular.&lt;/span&gt;
    update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; first
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;훅과 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 대해서 한 번 더 개념을 잡고 가겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;는 update를 담고 있습니다. 우리는 항상 update를 이 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 연결 리스트로 추가해줍니다. 그리고 컴포넌트 업데이트일 때 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에서 update 리스트를 꺼내와 적용시킵니다. 문제는 update를 적용시킬 때 항상 head부터 시작하게 되면 중복 적용될 수가 있습니다.&lt;br&gt;
그래서 적용된 부분과 아직 적용되지 않은 부분의 경계선을 정해줄 필요가 있습니다. 그래야 이 경계선을 기준으로 적용되지 않은 부분의 update들만 소비할 수 있으며 이미 적용된, 더는 사용하지 않을 update 객체를 건너뛰고 동시에 gc를 위해 참조도 끊어줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;그럼 이 경계선에 대한 지식은 누가 알고 있어야 할까요? 리액트는 이 지식을 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;가 아닌 훅 객체가 알고 있어야 한다고 생각했습니다. 그리고 그 정보는 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;에 담기게 됩니다. &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;는 적용된 update의 tail 포인터이며 &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;는 tail update를 실행한 괏값입니다. 이제 이 base를 기준으로 next는 모두 적용되지 않은 훅 리스트입니다.&lt;/p&gt;
&lt;p&gt;근데 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;last&lt;/code&gt;에 마지막 update만 담고 있습니다. 이러면 tail만 알 수 있지 head는 모릅니다. 더군다나 훅 객체의 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;도 처음에는 적용된 update가 없으므로 null입니다.&lt;/p&gt;
&lt;p&gt;이러한 케이스 때문에 컴포넌트가 첫 업데이트를 실행하기 전까지는 head를 어딘가에서 물고 있어야 하므로 &lt;code class=&quot;language-text&quot;&gt;update&lt;/code&gt;가 저장되는 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 &lt;em&gt;Circular Linked List&lt;/em&gt;로 만들어 tail update의 next가 head를 물고 있게 해준겁니다.&lt;/p&gt;
&lt;p&gt;컴포넌트가 한번이라도 업데이트 되면 이 &lt;em&gt;Circular Linked List&lt;/em&gt;를 끊어주고 모든 update를 적용시킨 후 &lt;u&gt;tail update와 그 결괏값&lt;/u&gt;을 훅의 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;에 할당합니다.&lt;/p&gt;
&lt;p&gt;이 이유 때문에 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;에서 update를 연결 리스트로 추가하는 로직을 보면 &lt;code class=&quot;language-text&quot;&gt;last&lt;/code&gt;의 next가 있는지 확인하는 부분이 바로 head를 훅의 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;에서 물고 있는지 아니면 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에서&lt;em&gt;Circular Linked List&lt;/em&gt;를 통해 물고 있는지 확인하는 의미가 되겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;3-update-적용-시키기&quot;&gt;&lt;a href=&quot;#3-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0&quot; aria-label=&quot;3 update 적용 시키기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. update 적용 시키기&lt;/h3&gt;
&lt;p&gt;render phase update에서 모든 update을 &lt;code class=&quot;language-text&quot;&gt;renderPhaseUpdates&lt;/code&gt; 맵에 담아두었던 걸 기억하시나요? 이 맵에 있는 update 리스트를 소비하는 로직이 다음 하이라이트 부분입니다. 해당 로직은 &lt;code class=&quot;language-text&quot;&gt;updateReducer()&lt;/code&gt; 의 나머지 로직을 먼저 보고 난 후에 확인하도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const hook = updateWorkInProgressHook();&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue
  queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedReducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reducer &lt;span class=&quot;token comment&quot;&gt;// updateState는 basicStateReducer&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트 재실행 판단&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// renderPhaseUpdates 소비 로직..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 훅을 가지고 왔으니 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 있는 update를 적용시킬 차례입니다. 로직은 간단합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;적용시킬 update의 head를 가지고 온다.&lt;/li&gt;
&lt;li&gt;훅의 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;last.next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Circular Linked List&lt;/em&gt; 라면 더이상 head를 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;가 알고 있을 필요가 없으니 last의 next에 null을 할당하여 연결을 끊어준다.&lt;/li&gt;
&lt;li&gt;head부터 tail까지 순회하면서 &lt;code class=&quot;language-text&quot;&gt;reducer&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt;을 던져 결괏값을 취한다.&lt;/li&gt;
&lt;li&gt;update를 모두 실행했다면 결과를 저장한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트 재실행 판단&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (numberOfReRenders &gt; 0) {&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// renderPhaseUpdates 소비 로직..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// }&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; baseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate &lt;span class=&quot;token comment&quot;&gt;// 적용된 리스트의 tail update&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState

  &lt;span class=&quot;token comment&quot;&gt;// 1. 적용시킬 update의 head를 가지고 온다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; first
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;baseUpdate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 첫 업데이트가 커밋된 이후에는 baseUpdate가 존재하기 때문에&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 더 이상 Circular Linked List는 필요가 없다. 다음 컴포넌트 업데이트 부터는 연결을 끊어준다.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token comment&quot;&gt;// baseUpdate의 head 참조&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Circular Linked List의 head 참조&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 2. head부터 tail까지 순회하면서  reducer에 action을 던져 결괏값을 취한다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;first &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; baseState
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; prevUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; baseUpdate
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; first
    &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; action &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;action
      newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      prevUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update
      update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;update &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; first&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// 3. update를 모두 실행했다면 결과를 저장한다.&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; prevUpdate &lt;span class=&quot;token comment&quot;&gt;// 적용된 tail update&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다음은 생략했던 &lt;code class=&quot;language-text&quot;&gt;renderPhaseUpdates&lt;/code&gt;을 사용하여 update를 적용시키는 방법을 알아보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;4-render-phase-update-적용-시키기&quot;&gt;&lt;a href=&quot;#4-render-phase-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0&quot; aria-label=&quot;4 render phase update 적용 시키기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. render phase update 적용 시키기&lt;/h3&gt;
&lt;p&gt;update를 소비하는 로직은 바로 위에서 본 로직과 별 다르지 않기 때문에 설명은 생략합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const hook = updateWorkInProgressHook();&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const queue = hook.queue;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// queue.lastRenderedReducer = reducer;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstRenderPhaseUpdate

        &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; action &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;action
          newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
          update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;update &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

        hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token comment&quot;&gt;// queue의 마지막이 이미 다 적용된 update라면&lt;/span&gt;
          &lt;span class=&quot;token comment&quot;&gt;// 처리해야 할 update가 남아 있지 않은 것이기 때문에 여기서 처리된 state를 할당해도 된다.&lt;/span&gt;
          hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState

        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;newState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지가 훅 update 구현체 전부입니다.&lt;br&gt;
다음의 리액트 흐름 중 1번과 3번의 일부분(&lt;down&gt;재조정 작업 중 컴포넌트를 실행해서 update를 적용 시켜주는 부분&lt;/down&gt;)을 보았습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;훅을 통해 컴포넌트 상태를 업데이트한다.&lt;/li&gt;
&lt;li&gt;VDOM 재조정을 해줄 Work를 scheduler에게 스케줄링 시키고 scheduler가 스케줄링된 Task를 꺼내 실행한다&lt;/li&gt;
&lt;li&gt;Work을 통해 VDOM 재조정 작업을 진행한다.&lt;/li&gt;
&lt;li&gt;완성된 VDOM을 commit phase에서 처리하여 DOM에 적용시킨다.&lt;/li&gt;
&lt;li&gt;사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;useReducer는 useState와 같은 구현체 쓰고 useEffect는 commit phase 때 추가 적으로 확인하게 될 것으로 이를 제외한 나머지 훅들도 궁금하신 분들은 직접 한번 분석해보시길 추천해 드립니다.&lt;/p&gt;
&lt;p&gt;다음 포스트는 2번 scheduler를 분석합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-hooks_1/&quot;&gt;React 톺아보기- 03. Hooks_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-scheduler_1/&quot;&gt;React 톺아보기- 04. Scheduler_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 03. Hooks_1]]></title><description><![CDATA[모든 설명은 v16.12.…]]></description><link>https://github.com/goidle/react/in-depth-react-hooks_1/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-hooks_1/</guid><pubDate>Fri, 12 Jun 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;각 포스트의 주제는 다음과 같이 리액트의 일반적인 흐름을 따라가도록 구성되었습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;훅을 통해 컴포넌트 상태를 업데이트한다.&lt;/li&gt;
&lt;li&gt;VDOM 재조정을 해줄 Work를 scheduler에게 스케줄링 시키고 scheduler가 스케줄링된 Task를 꺼내 실행한다&lt;/li&gt;
&lt;li&gt;Work을 통해 VDOM 재조정 작업을 진행한다.&lt;/li&gt;
&lt;li&gt;완성된 VDOM을 commit phase에서 처리하여 DOM에 적용한다.&lt;/li&gt;
&lt;li&gt;사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 흐름의 내용만 제대로 이해하게 된다면 이 이외의 케이스들에 대해서는 굳이 설명하지 않아도 혼자서 충분히 알아볼 수 있지 않을까 기대해봅니다.&lt;/p&gt;
&lt;p&gt;이번 포스트에서는 첫 번째인 훅을 다룹니다. 훅이 어떻게 컴포넌트를 업데이트하는지 알아보도록 하겠습니다.&lt;br&gt;
목차는 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;훅 가져오기&lt;/li&gt;
&lt;li&gt;컴포넌트가 처음 마운트될 때 훅이 어떻게 같이 만들어지는가?&lt;/li&gt;
&lt;li&gt;훅을 통해 컴포넌트를 업데이트 했을 때 컴포넌트 렌더링 과정에서 어떻게 업데이트된 값을 가지고 와서 적용시키는가?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;훅은 리액트 코어에 구현되어 있지 않고 외부 모듈에서 가지고 옵니다. 그래서 훅을 사용하는 코드를 바로 찾아가서 시작하지 않고 어떠한 방식으로 개발자에게 전달하는지부터 확인하겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;1-hook의-구현체는-어디에-있을까&quot;&gt;&lt;a href=&quot;#1-hook%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;1 hook의 구현체는 어디에 있을까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Hook의 구현체는 어디에 있을까?&lt;/h1&gt;
&lt;p&gt;분석을 시작하기 가장 좋은 방법은 분석할 함수를 어디서 어떻게 가져오는지 먼저 확인하는 것입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; React.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; useState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; useEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactHooks&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactSharedInternals &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactSharedInternals&apos;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 의존성을 주입받는 징검다리&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; React &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ReactSharedInternals&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; React&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;개발자가 코어를 통해 가져오는 훅은 &lt;code class=&quot;language-text&quot;&gt;ReactHooks.js&lt;/code&gt; 모듈에서 가져오고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactHooks.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactCurrentDispatcher &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactCurrentDispatcher&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolveDispatcher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initialState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;create&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; inputs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolveDispatcher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;create&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; inputs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolveDispatcher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dispatcher
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher.js&lt;/code&gt; 모듈에서 &lt;code class=&quot;language-text&quot;&gt;dispatcher&lt;/code&gt;를 가지고 오네요. 훅의 구현체는 &lt;code class=&quot;language-text&quot;&gt;dispatcher&lt;/code&gt;가 가지고 있나 봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactCurrentDispatcher.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ReactCurrentDispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; ReactCurrentDispatcher&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아무것도 없습니다.. 그냥 객체 하나가 끝입니다.&lt;/p&gt;
&lt;p&gt;훅에 대해서 좀만 더 생각해보자면 훅은 컴포넌트의 상태를 업데이트하는데 코어에서는 컴포넌트의 겉 정보인 react element만을 관리합니다. 인스턴스화 되기 전인 클래스라고 생각하시면 편할것 같습니다.&lt;br&gt;
컴포넌트의 상태는 VDOM의 fiber에 저장되는데 이 fiber를 업데이트할 수 있는 권한은 fiber를 만들어내는 reconciler에게 있습니다. 그러므로 상태를 변경 시킬 수 있는 훅의 구현체 또한 reconciler에 위치해 있습니다.&lt;/p&gt;
&lt;p&gt;근데 위 리액트 코어를 보면 어디에도 reconciler에서 훅을 가져오는 부분을 보지 못했습니다. 그렇다는 말은 반대로 훅 객체를 밖에서 안으로 누군가가 &lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher.current&lt;/code&gt;에 주입해준다는 말이 됩니다.&lt;br&gt;
코어가 다른 패키지의 기능을 개발자에게 제공해 줄 때 의존성을 자기가 만들지 않고 외부에서 주입 받습니다. 스프링의 DI(Dependency Injection)와 같습니다.&lt;/p&gt;
&lt;p&gt;그리고 한발 더 나아가서 리액트는 외부에서 의존성을 주입할 때 코어에 직접적으로 주입하지 않습니다. 중간자를 하나 더 두게 되는데 그게 코어에서는 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt; 모듈이고 더 넓게 패키지로 보면 Shared라는 패키지가 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;의존성을-관리하는-code-classlanguage-textreactsharedinternalsjscode-shared-패키지&quot;&gt;&lt;a href=&quot;#%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-code-classlanguage-textreactsharedinternalsjscode-shared-%ED%8C%A8%ED%82%A4%EC%A7%80&quot; aria-label=&quot;의존성을 관리하는 code classlanguage textreactsharedinternalsjscode shared 패키지 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;의존성을 관리하는 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt;, Shared 패키지&lt;/h3&gt;
&lt;p&gt;먼저 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt;부터 보면 여기에 있는 모든 모듈은 외부에서 주입받아 개발자에게 제공되는 모듈입니다. &lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher&lt;/code&gt;도 여기에서 훅을 주입받길 기다리고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactSharedInternals.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactCurrentDispatcher &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactCurrentDispatcher&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactCurrentBatchConfig &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactCurrentBatchConfig&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactCurrentOwner &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactCurrentOwner&apos;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ReactSharedInternals &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  ReactCurrentBatchConfig&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  ReactCurrentOwner&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; ReactSharedInternals&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shared는 모든 패키지들이 공유하는 정보들을 가지고 있는데 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt;가 여기에서 import되어 reconciler에서 사용할 수 있게 해줍니다.&lt;br&gt;
이 내용의 모듈은 shared의 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt;입니다. 코어의 모듈과 같은 이름이기 때문에 헷갈릴수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// shared &gt; ReactSharedInternals.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ReactSharedInternals &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
  React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;ReactSharedInternals&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasOwnProperty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;ReactCurrentDispatcher&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  ReactSharedInternals&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ReactCurrentDispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; ReactSharedInternals&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;맨 처음 React 선언 코드에서 본 &lt;code class=&quot;language-text&quot;&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt;를 통해 코어의 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt;을 가져와서 다른 패키지들이 코어에 의존성을 주입할 수 있도록 해줍니다. 이제 reconciler는 shared의 &lt;code class=&quot;language-text&quot;&gt;ReactSharedInternals.js&lt;/code&gt;을 이용하여 코어에 훅을 마음대로 주입할 수 있습니다.&lt;/p&gt;
&lt;p&gt;개발자에게 도달되는 흐름은 다음과 같습니다.
reconciler -&gt; shared/ReactSharedInternal -&gt; react/ReactSharedInternal -&gt; react/ReactCurrentDispatcher -&gt; react/ReactHooks -&gt; react -&gt; 개발자의 형태가 됩니다. 다시 코드를 한 번 쭉 훑어 보시면서 흐름을 느껴 보시길 바랍니다.&lt;/p&gt;
&lt;p&gt;이제 우리는 훅이 어디에 있는지 shared/ReactSharedInternal.js를 import하고 &lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher&lt;/code&gt;를 사용하고 있는 곳을 찾아가면 확인할 수 있습니다.&lt;br&gt;
훅은 reconciler/ReactFiberHooks.js에 위치해 있습니다.&lt;/p&gt;
&lt;h1 id=&quot;2-hook은-내부에서-어떻게-사용되는가&quot;&gt;&lt;a href=&quot;#2-hook%EC%9D%80-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;2 hook은 내부에서 어떻게 사용되는가 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Hook은 내부에서 어떻게 사용되는가?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;본격적으로 들어가기에 전에 알려드립니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 내부에서 선언된 지역변수인지 모듈 최상단에 선언된 전역변수인지 잘 확인하시길 바랍니다.&lt;/li&gt;
&lt;li&gt;설명하지 않고 넘어가는 코드는 크게 신경 쓰지 않으셔도 됩니다. 복잡하니 그때는 생략되고 사용되는 뒷부분에서 다룹니다.&lt;/li&gt;
&lt;li&gt;실제 코드를 보면 __DEV__로 감싸진 코드들을 많이 보실 텐데 개발 모드에서만 사용됨을 뜻하므로 산뜻하게 무시해주시면 됩니다.&lt;/li&gt;
&lt;li&gt;분석하기에 type이 있으면 좋을 부분들은 type를 제거하지 않고 그대로 사용하도록 하겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;훅을 &lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher.current&lt;/code&gt;에 주입하는 곳은 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;입니다. 함수 이름에서 느껴지시나요? 컴포넌트 실행을 여기서 합니다. 이 함수의 주목적은 훅을 넘겨주는 게 아니라 함수 실행이고 훅 주입은 부수적으로 따라오는 부분입니다. 이 함수는 render phase에서 호출되는데 그때 가서 자세히 다루고 지금은 훅과 관련된 코드들만 뜯어와서 보도록 하겠습니다.&lt;/p&gt;
&lt;anchor id=&quot;renderWithHooks()&quot; /&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderWithHooks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  workInProgress&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  Component&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  refOrContext&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  nextRenderExpirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  currentlyRenderingFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress &lt;span class=&quot;token comment&quot;&gt;// 현재 작업 중인 fiber를 전역으로 잡아둠&lt;/span&gt;
  nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;

  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; HooksDispatcherOnMount &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HooksDispatcherOnUpdate

  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; refOrContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트 재실행 로직 생략..&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderedWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentlyRenderingFiber
  renderedWork&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook

  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ContextOnlyDispatcher
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;reconciler 패키지의 여러 모듈들은 자신의 컨텍스트을 현재 작업 중인 컴포넌트 전용으로 사용합니다. 이 말이 무슨 뜻이냐면 해당 모듈에서 선언되는
모든 전역 변수들(&lt;down&gt;firstWorkInProgressHook, nextCurrentHook..&lt;/down&gt;)은 작업중인 컴포넌트에만 국한되는 상태값으로 관리한다는 뜻입니다.&lt;br&gt;
컴포넌트의 작업이 끝나게 되면 모두 초기화시켜 다음 컴포넌트에서 사용할 수 있도록 준비시켜 놓습니다.&lt;br&gt;
그렇기 때문에 전역변수인지 지역변수인지 유심히 살펴보시길 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;17&lt;/strong&gt;, &lt;strong&gt;20&lt;/strong&gt; 라인을 먼저 확인하겠습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Component&lt;/code&gt;는 fiber의 type에서 꺼낸 온 것인데 여기에는 개발자가 작성한 컴포넌트 함수가 저장되어 있습니다.
&lt;strong&gt;17&lt;/strong&gt; 라인을 통해 훅을 사용하고 있는 컴포넌트를 실행하면 전역변수 &lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;에 hook 객체가 저장됩니다.
이 변수를 fiber의 &lt;code class=&quot;language-text&quot;&gt;memoizedState&lt;/code&gt;에 저장해 놓음으로서 훅을 컴포넌트와 매핑시켜 줍니다.&lt;/p&gt;
&lt;p&gt;이제 &lt;strong&gt;12&lt;/strong&gt;번 라인을 이해할 수 있습니다. &lt;code class=&quot;language-text&quot;&gt;memoizedState&lt;/code&gt;가 null이 아니라면 이전 컴포넌트 렌더에서 훅이 사용되었다는 뜻이 됩니다.&lt;br&gt;
그리고 &lt;strong&gt;15&lt;/strong&gt; 라인에서 &lt;code class=&quot;language-text&quot;&gt;nextCurrentHook&lt;/code&gt;을 이용하여 훅이 마운트인지 업데이트인지 판단을 하게 됩니다. 그리고 거기에 맞게 훅 구현체를 다르게 사용합니다.&lt;br&gt;
즉 컴포넌트가 마운트 될 때 훅은 마운트용 구현체를 사용할 것이고 그 이후에는 컴포넌트가 언마운트되지 않는 한 계속 업데이트용 구현체를 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;strong&gt;22&lt;/strong&gt;번 라인에서 한 번 더 다른 훅 구현체 &lt;code class=&quot;language-text&quot;&gt;ContextOnlyDispatcher&lt;/code&gt;를 사용합니다. 이는 컴포넌트 실행이 모두 끝난 다음 혹시나 훅을 호출하는 상황이 발생할 때
에러를 던져 개발자가 올바르게 훅을 사용할 수 있도록 해주는 장치입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// mount&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; HooksDispatcherOnMount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; mountState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; mountEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// update&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; HooksDispatcherOnUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; updateState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; updateEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// invalid hook call&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ContextOnlyDispatcher&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; throwInvalidHookError&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; throwInvalidHookError&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;center&gt;상황별 훅 구현체&lt;/center&gt;
&lt;h1 id=&quot;3-hook은-어떻게-구현되어-있을까&quot;&gt;&lt;a href=&quot;#3-hook%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;3 hook은 어떻게 구현되어 있을까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Hook은 어떻게 구현되어 있을까?&lt;/h1&gt;
&lt;p&gt;목차의 2번 &lt;strong&gt;&lt;em&gt;‘컴포넌트가 처음 마운트될 때 훅은 어떻게 같이 만들어지는가?’&lt;/em&gt;&lt;/strong&gt;는 마운트 구현체를 통해 확인할 것이고 3번 &lt;strong&gt;&lt;em&gt;‘훅을 통해 컴포넌트를 업데이트 했을 때 컴포넌트 렌더링 과정에서 어떻게 업데이트된 값을 가지고 와서 적용시키는가?’&lt;/em&gt;&lt;/strong&gt;는 업데이트 구현체를 통해 확인하면서 훅 분석을 마무리 합니다.&lt;/p&gt;
&lt;h2 id=&quot;mount-구현체&quot;&gt;&lt;a href=&quot;#mount-%EA%B5%AC%ED%98%84%EC%B2%B4&quot; aria-label=&quot;mount 구현체 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;mount 구현체&lt;/h2&gt;
&lt;h3 id=&quot;1-훅-객체-만들기&quot;&gt;&lt;a href=&quot;#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0&quot; aria-label=&quot;1 훅 객체 만들기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 훅 객체 만들기&lt;/h3&gt;
&lt;p&gt;컴포넌트가 마운트될 때 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 마운트 훅 구현체를 주입했습니다. useState()의 경우 아래의 &lt;code class=&quot;language-text&quot;&gt;mountState()&lt;/code&gt;를 사용하게 됩니다. 가장 먼저 훅 객체를 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 훅 객체를 생성한다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState() &gt; mountWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// hook 객체에 대해서는 update에서 더욱 자세히 다루게 됩니다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    memoizedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트에 적용된 마지막 상태값&lt;/span&gt;
    queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 훅이 여러 번 실행될 때 update들을 queue에 연결리스트로 저장한다.&lt;/span&gt;
    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 다음 훅을 가리키는 노드 포인터&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// 이하 update 구현체에서 설명&lt;/span&gt;
    baseState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 맨 처음 실행되는 훅인 경우 연결 리스트의 head로 잡아둠&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgressHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    firstWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 두번 째부터는 연결 리스트에 추가&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; workInProgressHook
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 변수명에서 first만 보면 바로 연결 리스트로 생각 하셔도됩니다. 리액트는 많은 곳에서 built-in collection 대신 연결 리스트를 이용하여 구현했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;built-in collection이 아닌 연결리스트로 구현된 이유는 탐색할 때 제어하기가 매우 쉽기 때문입니다. 탐색 조건이나 중지, 노드의 삭제 등 제어가 간편합니다.&lt;br&gt;
또 다른 이점 하나는 연결 리스트끼리 이어 붙이는데 많은 리소스가 들지 않는다는 겁니다. tail 포인터만 연결할 리스트의 head를 가리키기만 하면 됩니다. 더불어 리액트에서는 랜덤 엑세스가 필요한 부분이 없으므로 더욱이 연결리스트를 쓰지 않을 이유가 없어 많은 곳에서 사용되고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 이미 봤듯이 컴포넌트 실행이 끝났을 때 &lt;code class=&quot;language-text&quot;&gt;renderedWork.memoizedState = firstWorkInProgressHook;&lt;/code&gt;으로 fiber에 head를 저장하는데 사용되고
&lt;code class=&quot;language-text&quot;&gt;workInProgressHook&lt;/code&gt;은 연결 리스트에서 현재 처리되고 있는 훅의 tail 포인터로 사용합니다.&lt;br&gt;
여러 블로그에서 훅 구현체를 설명할 때 index와 배열을 이용하여 설명하지만 우리는 이제 실제 코드를 통해 연결 리스트로 되어 있다는 걸 알 수 있습니다.
그리고 왜 훅의 순서가 항상 같아야 하는지는 업데이트 구현체를 보면 명확하게 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;다음으로 훅을 사용할 때 넘겨받은 초기값인 &lt;code class=&quot;language-text&quot;&gt;initialState&lt;/code&gt;가 함수이면 바로 실행해서 결괏값을 얻어옵니다. 이 이후 &lt;code class=&quot;language-text&quot;&gt;initialState&lt;/code&gt;가 실행되는 일은 없습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const hook = mountWorkInProgressHook();&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; initialState &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;function&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 생성자 함수일 경우&lt;/span&gt;
    initialState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; initialState
  &lt;span class=&quot;token comment&quot;&gt;//생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-update를-담을-queue-생성&quot;&gt;&lt;a href=&quot;#2-update%EB%A5%BC-%EB%8B%B4%EC%9D%84-queue-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;2 update를 담을 queue 생성 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. update를 담을 queue 생성&lt;/h3&gt;
&lt;p&gt;다음은 useState()가 반환하는 상태 업데이트 함수&lt;up&gt;setState&lt;/up&gt; 를 호출할 때 넘겨주는 인자&lt;up&gt;action&lt;/up&gt; 를 저장해놓을 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 만듭니다.
한 번의 컴포넌트 실행에서 여러 번의 setState()가 호출되면 이 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 다가 쌓아 놓습니다.
그리고 컴포넌트가 리-렌더링 될 때 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 저장되어 있던 action들을 차례대로 꺼내서 실행해 최종 state를 도출합니다.
&lt;anchor id=&quot;create_queue&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// hook.memoizedState = hook.baseState = initialState;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    last&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 마지막 update&lt;/span&gt;
    dispatch&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// push 함수&lt;/span&gt;

    lastRenderedReducer&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; basicStateReducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// return typeof action === &apos;function&apos; ? action(state) : action;&lt;/span&gt;
    lastRenderedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; initialState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    currentlyRenderingFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;의 push 함수입니다. &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt; 할당을 자세히 보면 bind를 통해서 인자를 잡아둔 상태로 외부에 노출시키고 있습니다. 여기서 인자들에 대해 생각해 볼 부분은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;훅을 잡지 않고 queue를 잡아둔 것이고&lt;/li&gt;
&lt;li&gt;다른 하나는 현재 작업중인 fiber를 잡아둔 것입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번 &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;의 push 함수이기 때문에 그렇습니다. &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;는 훅 객체를 알 필요가 없습니다. 단지 배열처럼 this를 통해 자신만 알면 됩니다. 그리고 이 this를 위 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 잡아둔 방법으로 해결합니다.&lt;/p&gt;
&lt;p&gt;2번 fiber에는 모든 정보가 있습니다. 그래서 update나 side effect, VDOM 재조정 작업을 나타내는 Work를 다룰 때 관련된 값만 따로 전달하지 않고 fiber 그 자체를 상황에 맞게 인식하는 방법으로 복잡도를 줄였습니다. &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;를 사용할 때 우리에게 필요한 정보가 fiber에 모두 존재하기 때문에 잡아둡니다. 이 fiber를 이용하여 &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;에서 어떠한 정보들을 뽑아내는지 바로 다음 섹션에서 알아보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;마지막에 반환하는 배열 &lt;code class=&quot;language-text&quot;&gt;return [hook.memoizedState, dispatch]&lt;/code&gt;이 우리가 사용하고 있는 &lt;code class=&quot;language-text&quot;&gt;const [a, setA] = useState(0);&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;훅과 update에 대해 혹시나 혼동될까 봐 한 번 더 설명하자면 하나의 컴포넌트에서 여러 훅이 실행될 때는 훅 자체의 연결 리스트로 저장하고 그 중 하나의 훅이 여러 번 호출될 때는 호출되는 훅 객체의 queue에 update를 연결 리스트로 저장합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;FC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setA&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// aHook&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setB&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// bHook&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// firstUpdate&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// secondUpdate&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// thirdUpdate&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// hook linked list&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// fiber.memoizedState =&gt; aHook.next =&gt; bHook.next =&gt; null&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// update circular linked list in queue of aHook&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// fiber.memoizedState =&gt; aHook.queue.last =&gt; thirdUpdate.next&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// firstUpdate.next =&gt; secondUpdate.next =&gt; thirdUpdate.next =&gt; firstUpdate&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;마지막으로 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 push 해줄 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;를 알아보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;3-훅-상태를-업데이트하는-dispatchaction&quot;&gt;&lt;a href=&quot;#3-%ED%9B%85-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EB%8A%94-dispatchaction&quot; aria-label=&quot;3 훅 상태를 업데이트하는 dispatchaction permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 훅 상태를 업데이트하는 dispatchAction&lt;/h3&gt;
&lt;p&gt;VDOM 재조정 작업과 관련된 reconciler 코드를 보면 항상 render phase가 진행 중일 때 발생한 것인지 아니면 idle 상태에서 발생한 것인지에 따라 로직이 나뉩니다.&lt;br&gt;
두 케이스 모두 처리해야 할 방법과 최적화 방식이 조금씩 다르므로 현재 분석하고 있는 코드가 어떤 상황에서 사용되고 있는지 확실히 알고 가야 이해하기가 편합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;render phase update란?&lt;br&gt;
컴포넌트가 렌더링 되고 있는 상황에서 추가적으로 업데이트가 발생할 경우를 말합니다.&lt;br&gt;
다음 코드에서 버튼을 클릭했을 때 컴포넌트는 변경된 상태값을 반영하기 위해 실행되는데 &lt;code class=&quot;language-text&quot;&gt;setA(2)&lt;/code&gt;로 인해 추가적인 업데이트가 발생한 경우입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;FC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setA&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;button&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;dispatchAction&lt;/code&gt; 함수는 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 update를 push함과 동시에 컴포넌트를 리-렌더링 시키기 위해 scheduler에게 Work를 스케줄링 시키는 함수입니다.&lt;br&gt;
&lt;anchor id=&quot;dispatchAction()&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// fiber와 queue는 이미 bind를 통해 currentlyRenderingFiber, queue로 인자가 잡혀있음을 유의하세요.&lt;/span&gt;
  fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  action
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; alternate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    fiber &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; currentlyRenderingFiber &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; alternate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; currentlyRenderingFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// render phase update&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// idle update&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if문의 조건이 무엇을 뜻하는지 알아보겠습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt;는 &lt;a href=&quot;#renderWithHooks()&quot;&gt;renderWithHooks()&lt;/a&gt;에서 할당되었었습니다. &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;는 VDOM 재조정 작업 중 일때 호출됩니다. 즉 &lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt;가 비어있지 않다는건 render phase가 진행 중인 상황임을 뜻합니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;11&lt;/em&gt;번 라인 bind로 잡아 두었던 &lt;code class=&quot;language-text&quot;&gt;fiber&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt; 가 같다면 이는 현재 컴포넌트가 render phase에서 작업중인 컴포넌트이며 동시에 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;가 호출 되었으므로 업데이트가 발생한 상황임을 나타냅니다.&lt;/p&gt;
&lt;p&gt;한가지 더 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;도 비교를 하는데 VDOM 트리는 두 개가 있다고 했습니다(&lt;down&gt;current, workInProgress&lt;/down&gt;).&lt;br&gt;
하지만 우리는 &lt;code class=&quot;language-text&quot;&gt;fiber&lt;/code&gt;를 bind로 고정시켜 놨습니다. 문제는 current와 workInProgress는 고정이 아닌 commit이 되면 서로 교체가 되기 때문에 현재 작업 중인 &lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt;가 두 개의 트리 중 어느 트리인지 알 수가 없습니다. 그래서 &lt;code class=&quot;language-text&quot;&gt;fiber&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;를 모두 비교를 해야 현재 컴포넌트가 작업 중인지 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;if문의 분기된 로직 중 render phase update 코드는 idle update를 먼저 보고 난 후에 확인해 보도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;3-1-유휴-상태에서의-dispatchaction&quot;&gt;&lt;a href=&quot;#3-1-%EC%9C%A0%ED%9C%B4-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C%EC%9D%98-dispatchaction&quot; aria-label=&quot;3 1 유휴 상태에서의 dispatchaction permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-1. 유휴 상태에서의 dispatchAction&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;이 하는일을 미리 나열하면 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;사용자의 업데이트 정보를 담은 &lt;code class=&quot;language-text&quot;&gt;update&lt;/code&gt;객체를 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;update&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 저장한다.&lt;/li&gt;
&lt;li&gt;불필요한 렌더링이 발생하지 않도록 최적화를 한다.&lt;/li&gt;
&lt;li&gt;업데이트를 적용시키기 위해 Work를 스케줄링 시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 순서는 idle update의 경우에 해당하고 render phase update는 4번을 제외하고는 다른 로직을 가지고 있으므로 추후에 가서 알아봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (render phase update) {&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// } else {&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// idle update&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 아래 만료 시간을 구하는 부분은 잠시 설명을 생략 합니다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;requestCurrentTimeForUpdate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; suspenseConfig &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;requestCurrentSuspenseConfig&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;computeExpirationForFiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    currentTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    suspenseConfig
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// update 생성&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    expirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// setState의 인자&lt;/span&gt;
    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 연결 리스트&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 이하 최적화에 사용되는 속성&lt;/span&gt;
    eagerReducer&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    eagerState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// update를 queue에 연결리스트로 추가&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// This is the first update. Create a circular list.&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;first &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      &lt;span class=&quot;token comment&quot;&gt;// Still circular.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; first&lt;/span&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;update를 큐에 추가할 때 연결 리스트로 추가합니다. 로직을 보면 &lt;em&gt;Circular Linked List&lt;/em&gt;로 만들어 주는 부분(&lt;down&gt;하이라이트&lt;/down&gt;)이 있는데 왜 이렇게 만들어 주는지는 update 구현체에서 설명하도록 하겠습니다. 그리고 만들어진 update를 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;의 tail pointer(&lt;code class=&quot;language-text&quot;&gt;last&lt;/code&gt;)에 추가해줍니다.&lt;/p&gt;
&lt;h3 id=&quot;3-2-불필요한-컴포넌트-리-렌더링-방지&quot;&gt;&lt;a href=&quot;#3-2-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A6%AC-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%A7%80&quot; aria-label=&quot;3 2 불필요한 컴포넌트 리 렌더링 방지 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-2. 불필요한 컴포넌트 리-렌더링 방지&lt;/h3&gt;
&lt;p&gt;리액트는 이 시점에(&lt;down&gt;&lt;em&gt;idle&lt;/em&gt; 상태에서 업데이트가 발생한 상황&lt;/down&gt;) 성능 최적화를 위한 한가지 선택지가 있습니다.&lt;br&gt;
다음과 같이 가정을 해보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;현재 컴포넌트에 대한 Work가 스케줄링 되어있지 않은 상태이고&lt;/li&gt;
&lt;li&gt;넘겨받은 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt;의 결괏값이 현재 state와 같다면?
이때는 state가 변경된게 없으므로 더 이상 진행하지 않고 &lt;strong&gt;bail out&lt;/strong&gt;할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// queue.last = update;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트가 유휴 상태인지 확인&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; NoWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; NoWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 최적화 로직..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if문에서 현재 컴포넌트가 idle 상태인지 확인합니다. &lt;code class=&quot;language-text&quot;&gt;fiber&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;를 모두 비교하는 이유를 우리는 이제 알고 있습니다.
여기서 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;은 업데이트가 발생한 컴포넌트에서 Work가 스케줄링 되면 해당 컴포넌트&lt;up&gt;fiber&lt;/up&gt;에 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;를 새깁니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//     fiber.expirationTime === NoWork &amp;amp;&amp;amp;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//     (alternate === null || alternate.expirationTime === NoWork)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//   ) {&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; lastRenderedReducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedReducer
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lastRenderedReducer &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedState &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트에 적용된 상태값&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; eagerState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lastRenderedReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;eagerReducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; lastRenderedReducer
    update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;eagerState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eagerState
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eagerState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; currentState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//  }&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;scheduleWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 만들 때 &lt;code class=&quot;language-text&quot;&gt;lastRenderedReducer&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;basicStateReducer&lt;/code&gt;를 &lt;a href=&quot;#create_queue&quot;&gt;할당&lt;/a&gt;했었습니다.
&lt;code class=&quot;language-text&quot;&gt;basicStateReducer&lt;/code&gt;의 로직은 간단합니다(&lt;down&gt;return typeof action === ‘function’ ? action(state) : action;&lt;/down&gt;).&lt;br&gt;
추가로 말씀드자면 &lt;code class=&quot;language-text&quot;&gt;lastRenderedReducer&lt;/code&gt;에는 &lt;code class=&quot;language-text&quot;&gt;useReduer&lt;/code&gt;를 사용할 때 넘겨주는 reducer 함수가 할당되기도 합니다.
&lt;code class=&quot;language-text&quot;&gt;useState()&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;useReducer&lt;/code&gt;와 같은 update 구현체를 공유합니다. 그러므로 &lt;code class=&quot;language-text&quot;&gt;useState()&lt;/code&gt; 하나를 분석하면 &lt;code class=&quot;language-text&quot;&gt;useReducer&lt;/code&gt;도 함께 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;현재 state와 같지 않다면 VDOM을 재조정해줄 Work를 스케줄링합니다. 여러 번 setState()를 호출해도 한 번만 스케줄링 되기 때문에 중복으로 Work가 중복으로 스케줄링 되지 않습니다. &lt;code class=&quot;language-text&quot;&gt;scheduleWork()&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;scheduler&lt;/code&gt;에 대한 자세한 내용은 다음 포스트에서 다룹니다.&lt;/p&gt;
&lt;p&gt;이제 생략했던 render phase update를 확인하도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;4-render-phase에서의-dispatchaction&quot;&gt;&lt;a href=&quot;#4-render-phase%EC%97%90%EC%84%9C%EC%9D%98-dispatchaction&quot; aria-label=&quot;4 render phase에서의 dispatchaction permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. render phase에서의 dispatchAction&lt;/h3&gt;
&lt;p&gt;render phase는 VDOM 재조정 작업 중인 상황입니다. 이 상황에서 컴포넌트를 실행하는 목적은 DOM에 마운트할 자식 react element를 얻기 위해서 인데 이 실행에서 추가적으로 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;가 호출되어 업데이트가 발생하면 idle update에서 처리해주었던(&lt;down&gt;schedule a work, bail out ..&lt;/down&gt;) 작업없이 바로 컴포넌트를 재실행해 업데이트를 소비하여 반영된 react element를 얻어오면 됩니다.&lt;/p&gt;
&lt;p&gt;render phase update를 바로 소비하기 위해서 이 업데이트를 잠깐 담아둘 임시 저장소가 필요합니다. 그래야 다음 컴포넌트 실행때 이 저장소에서 업데이트를 꺼내 적용시킬 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// if (&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   fiber === currentlyRenderingFiber ||&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   (alternate !== null &amp;amp;&amp;amp; alternate === currentlyRenderingFiber)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ) {&lt;/span&gt;
  didScheduleRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// renderWithHooks()에게 컴포넌트 재실행을 알려줄 플래그&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    expirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; renderExpirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    suspenseConfig&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    eagerReducer&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    eagerState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 업데이트를 저장할 맵&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; undefined&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Append the update to the end of the list.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; lastRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lastRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      lastRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; lastRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    lastRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// else {&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   idle update..&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   scheduleWork(fiber, expirationTime);&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;업데이트를 알고 있는 건 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;이기 때문에 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;로 키를 잡아 업데이트를 저장합니다.&lt;br&gt;
이 맵을 소비하기 위해서는 컴포넌트를 재실행해주어야 하는데 컴포넌트 실행은 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 해주었습니다. 이제 이 함수에서 컴포넌트 재실행과 관련된 생략된 로직을 확인하도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;render phase update가 발생했을 때 &lt;code class=&quot;language-text&quot;&gt;didScheduleRenderPhaseUpdate&lt;/code&gt; 플래그를 활성화시켜 주었습니다. &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;는 이 플래그를 통해 render phase update가 발생했는지 판단합니다. 그리고 컴포넌트를 재실행했는데 또 render phase update가 발생할 수도 있습니다. 이때는 발생하지 않을 때까지 재실행 로직을 반복하게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderWithHooks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// let children = Component(props, refOrContext)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;didScheduleRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      didScheduleRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 재실행 플래그 초기화&lt;/span&gt;
      numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 무한 루프 방지&lt;/span&gt;

      &lt;span class=&quot;token comment&quot;&gt;//이하 update 구현체에서 현재 컴포넌트가 재실행되는 상황인지 확인하는데 사용됨&lt;/span&gt;
      nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
      nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook

      &lt;span class=&quot;token comment&quot;&gt;// 필요한 전역 변수 초기화&lt;/span&gt;
      currentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
      workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;

      ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; HooksDispatcherOnUpdate &lt;span class=&quot;token comment&quot;&gt;// update 구현체 사용&lt;/span&gt;

      children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; refOrContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;didScheduleRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// render phase update 저장소 초기화&lt;/span&gt;
    numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// const renderedWork = currentlyRenderingFiber&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ReactCurrentDispatcher.current = ContextOnlyDispatcher&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;훅을 사용하면서 많이 보셨을 메시지인 &lt;strong&gt;&lt;em&gt;“Too many re-renders. React limits the number of renders to prevent an infinite loop.”&lt;/em&gt;&lt;/strong&gt;는 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;numberOfReRenders&lt;/code&gt;을 기준으로 출력됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; dispatchAction&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  fiber&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; UpdateQueue&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  action&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;invariant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;RE_RENDER_LIMIT&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Too many re-renders. React limits the number of renders to prevent &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&apos;an infinite loop.&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지가 mount 구현체 입니다. 글이 너무 길기 때문에 update 구현체는 다음 포스트에 작성합니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;renderPhaseUpdates&lt;/code&gt;에 저장된 업데이트 소비는 컴포넌트가 재실행될 때 update 구현체에서 소비되므로 다음 포스트에서 다룹니다.&lt;/p&gt;
&lt;h2 id=&quot;정리&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정리&lt;/h2&gt;
&lt;p&gt;이제 여러분은 다음과 같은 질문에 대답할 수 있어야 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;를 한번에 여러 번 실행하면 매 실행마다 렌더링 되나요?&lt;/li&gt;
&lt;li&gt;클릭을 통해 컴포넌트 상태를 업데이트시켰습니다. 그리고 변경된 상태를 기준으로 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;를 호출했어요. 그러면 클릭을 통한 상태 업데이트 때 한번, 추가적인 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt; 때 또 한 번. 이렇게 매번 렌더링 되나요?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이런 질문이 들어오면 일단 가장 먼저 질문자에게 해주어야 할 부분은 렌더링 단어의 의미를 명확하게 인식시키는 겁니다. 이 부분만 제대로 이해해도 개발자의 입장에서만 바라보던 것들을 리액트의 입장에서 바라볼 수 있도록 시야를 트여줍니다.&lt;/p&gt;
&lt;p&gt;이제 하나씩 답변을 해보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;복수개의 훅 실행이 현재 state와 같다면 아무 일도 일어나지 않는다. 그게 아니면 한데 묶어서 다음 프레임 때 한 번만 컴포넌트가 재실행된다. 화면에 그려지는 것 또한 한 번이다.(&lt;down&gt;스케줄링도 한번&lt;/down&gt;)&lt;/li&gt;
&lt;li&gt;클릭을 통한 업데이트로 컴포넌트가 재실행 된다. 그리고 그 재실행에서 발생하는 추가적인 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;는 1번처럼 묶어서 한 번만 실행한다.&lt;br&gt;
여기서 업데이트가 발생하지 않을 때까지 계속해서 함수를 재실행한다. 결국, 최소 2번 최대 25번(&lt;down&gt;RE&lt;em&gt;RENDER&lt;/em&gt;LIMIT = 25&lt;/down&gt;) 컴포넌트가 재 실행될 수 있다. 그리고 화면은 1번과 마찬가지로 한 번만 그려진다.&lt;br&gt;
이 사이클은 render phase임을 유의해라. commit phase가 아니면 단지 in-memory 객체만 끄적인 것이지 아무 변화도 일어나지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기까지 이해가 가시나요? 그러면 다행이지만 그렇지 않다면 가장 이해하기 쉬운 방법은 위 내용을 토대로 직접 코드를 작성해서 디버깅을 해보는 것입니다.&lt;/p&gt;
&lt;p&gt;다음은 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;를 통해 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 저장해두었던 update을 훅이 어떻게 소비하는지 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;번외&quot;&gt;&lt;a href=&quot;#%EB%B2%88%EC%99%B8&quot; aria-label=&quot;번외 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;번외&lt;/h2&gt;
&lt;h3 id=&quot;4-code-classlanguage-textexpirationtimecode&quot;&gt;&lt;a href=&quot;#4-code-classlanguage-textexpirationtimecode&quot; aria-label=&quot;4 code classlanguage textexpirationtimecode permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;생략된 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에 대해 조금만 알아보겠습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에 대해서는 깊이 들어가지는 않지만 reconciler에서 전반적으로 사용되므로 아주 기본만 알고 넘어가겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;는 scheduler와 reconciler에서 사용하는데 살짝 다른 뜻으로 쓰이지 않으며 구현도 다릅니다. scheduler에서는 이름 그대로 Task의 만료시간만을 나타내는 데 비해 reconciler에서는 이벤트를 구분하는 기준으로도 쓰입니다. 같은 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에서 발생한 연속적인 이벤트는 하나의 이벤트로 간주하기 위함입니다. &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;이 달라야 개별 이벤트로 판단합니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;의 가장 큰 수는 32-bit 시스템인 v8에서 처리할 수 있는 부호 있는 31bit 값입니다. 이 값을 Sync로 다룹니다.
이렇게 다룰 수 있는 이유는 위에서 설명한 것처럼 개별 업데이트를 구분하는 기준으로 사용하기 때문입니다.
그리고 &lt;code class=&quot;language-text&quot;&gt;legacy mode&lt;/code&gt;에서는 모든 게 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;로 처리된다고 생각하시면 됩니다. 여기서 나오는 대부분은 &lt;code class=&quot;language-text&quot;&gt;concurrent mode&lt;/code&gt;에서 사용됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberExpirationTime.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; NoWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Never &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Idle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Sync &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;MAX_SIGNED_31_BIT_INT&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1073741823&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Batched &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Sync &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Batched &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 시간을 구할 때 형식은 &lt;code class=&quot;language-text&quot;&gt;Date.now()&lt;/code&gt;가 아닌 &lt;code class=&quot;language-text&quot;&gt;performance.now()&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;performance.now는 브라우저가 시작되고 현재까지의 경과시간을 나타냅니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이걸 바로 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;로 사용하지 않고 다음의 계산식을 이용합니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;() =&amp;gt; MAX_SIGNED_31_BIT_INT - now()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;now()&lt;/code&gt;가 오른쪽 피연산자에 있다는 건 나중에 발생한 작업일수록 더 작은 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt; 값을 가지게 된다는 뜻입니다.
이 부분은 나중에 코드에서 fiber에 새겨진 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;를 가지고 대소비교를 할 때 헷갈릴 수 있으므로 기억해두시길 바랍니다.&lt;/p&gt;
&lt;p&gt;근데 &lt;code class=&quot;language-text&quot;&gt;performance.now()&lt;/code&gt;로(&lt;down&gt;브라우저 경과시간&lt;/down&gt;) 현재 시간을 표현하기 때문에 그럴 일은 없겠지만 이론상으로는 발생 시간이 0이 나올 수도 있습니다. 이렇게 되면 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Batched&lt;/code&gt;와 시간이 겹칠 수 있어서 기존 상수들과 겹치지 않기 위해 offset 값이 필요한데 그게 바로 &lt;code class=&quot;language-text&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;이 이유 때문에 계산식을 다시 작성하자면 &lt;code class=&quot;language-text&quot;&gt;() =&amp;gt; MAGIC_NUMBER_OFFSET - now()&lt;/code&gt;가 됩니다. 이제 브라우저가 뜨자마자 바로 이벤트가 발생해도 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;Batched&lt;/code&gt;와 겹칠일은 없습니다.&lt;/p&gt;
&lt;p&gt;다음 코드가 발생시간에서 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에서 다시 발생시간을 구하는 계산식입니다.&lt;/p&gt;
&lt;anchor id=&quot;currentTime&quot;&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberExpirationTime.js&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// const MAGIC_NUMBER_OFFSET = Batched - 1&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UNIT_SIZE&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 1 unit of expiration time represents 10ms.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;msToExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;ms&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ms &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UNIT_SIZE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;expirationTimeToMs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;expirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UNIT_SIZE&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다시 간략하게 정리하자면 fiber의 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;NoWork&lt;/code&gt;이면 작업 중인게 없다는 뜻이고 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;는 동기적으로 작업이 처리될 것이며 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 대소로 비교하는 조건문이 있을 때는 큰 숫자가 더 옛날에 먼저 발생한 작업이다. 라고만 생각하고 넘어가시면 분석할 때 큰 무리 없이 이해할 수 있을 것입니다.&lt;br&gt;
시간과 관련된 부분은 &lt;code class=&quot;language-text&quot;&gt;concurrent mode&lt;/code&gt;가 일반적으로 사용이 되면 그때 깊이 있게 알아보도록 하겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-intro/&quot;&gt;React 톺아보기- 02. Intro&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-hooks_2/&quot;&gt;React 톺아보기- 03. Hooks_2&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 02. Intro]]></title><description><![CDATA[모든 설명은 v16.12.…]]></description><link>https://github.com/goidle/react/in-depth-react-intro/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-intro/</guid><pubDate>Tue, 09 Jun 2020 09:20:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 포스트에서는 사전지식을 좀 더 자세하게 다루도록 하겠습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 790px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 59.05017921146953%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACGUlEQVQoz2VTia6bMBDk/7+vlZp3hCPB3GDjEwKZjp0+6bW1ZK3XZmdnZ5cMXM/nMxrs+w69rpjnGUopOOfgvU9Wa41xHLHyPfpfb6tasSwLpJTpLotgX4AhBIItEKJB38dgDWMMLD9cGFDXAhOTRd8Ym5LE5EIIdF2PlX6Gb8u4gKLz+PHR4b0mI2kRnIaSC7wjwEoWRkMuE5nJVzJrk/XeJZud55moPx4PZg649Q7XWqLqLc8WZaNQiAX1YFC2CmJytBrNsMISIIJEecyfcxYzRMpRH+s8GgbE3c4eda/xeZ9xKUfkjcZVrKhHn0D7OTJ7SRJ1/WKaRWZRC+8DNfTYWKLTMpW6e2rEsq9C4b3s8UbgYTH8RpGdYpz5H/BfDcveI29tstUQzw6XSuKdu+wC7tOBvNvI1BFUp+b8BbhtW3Jiy419ldLPhkxsOg/s4jAI9GOLWtzQdjXladn1KVX2XcPoZxFoGEbMnKUIfjw2BG/x2AP2LeAMPeCuCPINevwJv1xw2g8cvoEPG/bHTvtqaozP4jCrNAIWx+45jCUBcmCrsKs32OkXwQigczwt3/Ya8BVO3+E4Tvy7UlOmaUo67GQnxgJ5fUHVfnBQOdx2RCcrjk2e7u/dZ/KVnWBZyX28oWgK3IYKs55ef0oq9Tiw7Ruq7oZcFOxsDqUVVna7lS3vq3RfcDdLA2kktNUEy3mXc3avGOSA30vklEj6RoQzAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;react lifescycle&quot; title=&quot;react lifescycle&quot; src=&quot;/static/83aa2072b273a11e7b733979b439d735/c94d1/react-lifescycle.png&quot; srcset=&quot;/static/83aa2072b273a11e7b733979b439d735/0780f/react-lifescycle.png 198w,
/static/83aa2072b273a11e7b733979b439d735/47b26/react-lifescycle.png 395w,
/static/83aa2072b273a11e7b733979b439d735/c94d1/react-lifescycle.png 790w,
/static/83aa2072b273a11e7b733979b439d735/32b35/react-lifescycle.png 1116w&quot; sizes=&quot;(max-width: 790px) 100vw, 790px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
  &lt;figcaption&gt;React lifecycle&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;위 표는 클래스의 라이프 사이클을 나타내는 표이며 오다가다 많이 보셨을 겁니다.&lt;br&gt;
표 왼쪽을 보면 리액트를 개발하면서 접해보지 못한 단어들이 보입니다.&lt;br&gt;
&lt;em&gt;“Render phase”&lt;/em&gt;, &lt;em&gt;“Commit phase”&lt;/em&gt;&lt;br&gt;
표만봐서는 설명에서 언급되는 side effect가 무엇을 뜻하는 것이고 또 무엇이 중지되고 다시 시작될 수 있는지 이해하기가 어렵습니다.&lt;/p&gt;
&lt;h2 id=&quot;render-phase&quot;&gt;&lt;a href=&quot;#render-phase&quot; aria-label=&quot;render phase permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Render phase&lt;/h2&gt;
&lt;p&gt;Render phase는 쉽게 말해 VDOM 조작 단계라고 생각하시면 됩니다.&lt;br&gt;
리액트는 변경점이 생겼을 때(&lt;down&gt;react element가 추가, 수정, 삭제..&lt;/down&gt;) 이를 VDOM에 반영하기 위해 VDOM 재조정 작업(&lt;down&gt;Work라고 명칭하며 자주 등장하기 때문에 기억해두세요&lt;/down&gt;)을 scheduler을 통해 실행시킵니다.&lt;/p&gt;
&lt;p&gt;이 VDOM을 재조정하는 일련의 과정을 Render phase라고 부릅니다. 재조정을 담당하는 reconciler의 시스템이 stack 기반에서 fiber architecture로 넘어가면서 이 과정을 abort, stop, restart 할 수 있게 되었습니다.&lt;br&gt;
이 기능은
&lt;a href=&quot;https://reactjs.org/docs/concurrent-mode-adoption.html#migration-step-blocking-mode&quot; target=&quot;_blank&quot;&gt;concurrent mode&lt;/a&gt;
에서만 비동기로 함께 이루어지며 legacy mode(현재 우리가 일반적으로 사용하는 ReactDOM.render)에서는 위 기능 없이 동기적으로 Render phase가 동작하게 됩니다.&lt;/p&gt;
&lt;p&gt;컴포넌트 실행은 Render phase에서 실행되며 컴포넌트 실행이 곧 화면에 페인트 된다는 뜻이 아님을 알려드렸습니다.
이전 포스트에서 언급한 용어인 렌더링에 빗대어 보자면 컴포넌트가 리-렌더링 된다는 말은 컴포넌트가 실행되고 그 결과가 VDOM에 반영된다는 거지 DOM에 마운트되어 페인트 된다는 뜻이 아닙니다.&lt;/p&gt;
&lt;h2 id=&quot;commit-phase&quot;&gt;&lt;a href=&quot;#commit-phase&quot; aria-label=&quot;commit phase permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Commit phase&lt;/h2&gt;
&lt;p&gt;Commit phase는 Render phase에서 재조정된 VDOM을 DOM에 마운트시키고 라이프 사이클을 실행하는 단계입니다.
여기서도 마찬가지로 DOM에 마운트된다는 것이지 페인트 된다는 건 아닙니다.&lt;/p&gt;
&lt;p&gt;이 단계는 모드와는 상관없이 항상 일관적인 화면 업데이트를 위해 동기적으로 실행 됩니다. 동기적으로 실행된다는 건 DOM 조작을 call stack을 한 번도 비우지 않고 일괄처리한다는 뜻입니다. 그러므로 Commit phase 중간에 페인트 되지 않습니다. 이 단계가 끝나고 리액트에서 call stack을 비워줘야지만 브라우저에서 화면을 페인트 할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;그 다음은 자주 언급되는 VDOM을 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;vdom&quot;&gt;&lt;a href=&quot;#vdom&quot; aria-label=&quot;vdom permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;VDOM&lt;/h2&gt;
&lt;figure&gt;
 &lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 634px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 143.69085173501577%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAEOElEQVRIx31VaVMbRxDl/1cZCXOksKGAKrv4EmOBDSGxY9kcTkglgSRCEgh0sTr2vne150vPiBUSEnRV1+xcb1/PdL+Zw5ilacpbx3VhOw58f4AoipAkCR8zTQuO40LTDXi+P9qT7WM2Nw6W3E9UqjUcfiriy9cTHBx+xq/FY/zx5zl2Cvu8/2b7R5Qr13wt+9k46NwshsyCIOTs/MGAswvDiPdD8iiOZ+6ZYsjMNE1IkgRRFKEoCndd16Gqw9axbSg0L/V6MKj/OOwpQJ/OxjAM2LSRuWVZvC8IAmzPg0NgSqkEg1qPmM8EzDqP6Y+bS2DMom4XqarOCPkR4HN+cnyMt9vbEGo1pLKMmN082Fx2IckDw6dYZePs3FZXVzE/P4+fDw/xnLE9nKETWhA9AYrfR5zGCOOQPCAWCfpSH4XdAlZfraJyVeEb7cBAz2lDsBvou3foum1Ygf4Qco8GWnaNT+oDGU5igpIF10IVl80SZK+LlnYDLZSh+QrUQIQa99H37yA4DbTtW94mRIYDGoE6Qb3VbOGqegWZUmc4T4wINDPHclD65xK+OxiN2aGBIB4MAfWBwjvMms0mFhYWsJCbx28XJVzrKb7U+9i/buGi5+LvjoN3799jZXkJu3u77GqQkQqT4AGQnRmzer2OxcUl/LCyjOO//kONAE/bIj7V2yhLPm4UD+92drC0soJCoTBiaATaJGCUhKPJi/Nz/Ht6OuprvoaO02GVy/syVc/Rx4+wKOGzFDQfA8Yp5VacQFE1nipUf4hM2hClMEMdktfh4bmuB5nWuO02HaaD+L5azGmGEc+jMAx5/ULTkFICM1IWAcp+lycwUxeLlWSrNVQbtmY24DDkmJTkw4c9HOztkeIML6prK3SWdyOVKVcqeLOxgUaj8XTI2aWUy2Xk8nl+y/vffsdZN8HB9R12SCNPWg6+3hhY39hELpfD1tbWqKKMacAhw77Yx8bmJjbW11BrCdDpPyWqlrNuE307gBumKBaLWHz5EkdHR7MZalQdCWKIsgJR6MAlqXLu1SU7H9F7uGX2BFQq1YlimAJkv5EUFQ4pCqns1GKJKiXhqgIMSMU1ujSm4FliTwDasY6+LKJE+RcrD2UoSiKajRa/5QyQGcuEIAi4z2R4pzTwev0V8vkFfP9+DHhU+MItXq+tIT+fx7ezIsxE4RnwlMxNANZ7NSwuL5Lm5fD5F9K8xELr9hJLy8vIvcjhpyJVRaoSYIRZgjwjZAPlapnf2ngY1WqV1PoUqitRYvdGIY8/GTMBzVDDIPThe/79WxuP3gjXduHEJkS3MwH4mOFEHmq+TC+cRZs9KqVkxNCjuvVsnxjKkPzus/JvkmKPAFVf4sltByaXdyekltyibzbG5lnITObZc2Hfz2fO1qu+iJj0gAOyOnYjG17kcGff7tg3+zNbnI2Pe7YmE+j/AYmfmLxmz5QpAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;vDOM&quot; title=&quot;vDOM&quot; src=&quot;/static/258b43ce623e7b6340fc6aed969199ed/153fa/vDOM.png&quot; srcset=&quot;/static/258b43ce623e7b6340fc6aed969199ed/0780f/vDOM.png 198w,
/static/258b43ce623e7b6340fc6aed969199ed/47b26/vDOM.png 395w,
/static/258b43ce623e7b6340fc6aed969199ed/153fa/vDOM.png 634w&quot; sizes=&quot;(max-width: 634px) 100vw, 634px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
  &lt;figcaption&gt;Virtual DOM&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;리액트는 VDOM을 더블 버퍼링 형태로 관리합니다. DOM에 마운트된 current와 Render phase에서 작업 중인 workInProgress로 나뉘어 있습니다. 이 workInProgress는 Commit phase를 지나면 current로 관리됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiberWorkLoop.js &gt; commitRootImpl()&lt;/span&gt;
root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; finishedWork&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇듯 더블 버퍼링 형태이기 때문에 리액트는 workInProgress에 작업을 하다가도 언제든지 버리고 처음부터 다시 작업하던지 아니면 중지시켰다가 다시 시작하는 등 작업 우선순위에 맞게 유연하게 대처할 수 있기에 사용자 경험을 최우선적으로 고려할 수 있습니다.&lt;/p&gt;
&lt;p&gt;위 이미지에서 화살표는 생략된 게 없습니다. 자세히 보면 Root Node는 current만 참조하고 있습니다. workInProgress가 만들어지는 방식은 current에서 자기 복제하여 서로 alternate로 참조하는 방식입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiberWorkLoop.js &gt; prepareFreshStack()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; workInProgress &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createWorkInProgress&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
workInProgress &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token comment&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;VDOM 노드&lt;up&gt;fiber&lt;/up&gt;는 자식을 child로 참조하는데 first child만 참조합니다. 나머지 자식들은 이전 형제가 sibling으로 참조하고 있습니다. 그리고 모든 자식은 부모를 return으로 참조합니다.&lt;/p&gt;
&lt;h2 id=&quot;reactelement&quot;&gt;&lt;a href=&quot;#reactelement&quot; aria-label=&quot;reactelement permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;reactElement&lt;/h2&gt;
&lt;p&gt;react element는 컴포넌트의 겉 정보만을 담고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; content &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;App&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;1&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;deep dive react&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; container&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactElement.js &gt; createElement()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// This tag allows us to uniquely identify this as a React Element&lt;/span&gt;
  $$&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;REACT_ELEMENT_TYPE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Built-in properties that belong on the element&lt;/span&gt;
  type&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// function App()&lt;/span&gt;
  key&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
  props&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// { content: &apos;deep dive react&apos; }&lt;/span&gt;
  ref&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ref&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리가 작성하는 JSX는 babel을 통해 react.createElement로 변환됩니다.&lt;br&gt;
type에 함수형 컴포넌트는 그 함수 자체가 Host Component는 tag 이름이 들어갑니다.&lt;br&gt;
나머지는 child 포함 죄다 props로 들어갑니다.&lt;/p&gt;
&lt;h2 id=&quot;fiber&quot;&gt;&lt;a href=&quot;#fiber&quot; aria-label=&quot;fiber permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;fiber&lt;/h2&gt;
&lt;p&gt;react element를 VDOM에 올려놓아야 합니다. 그 확장을 fiber가 해줍니다. fiber는 VDOM 노드이며 모든 정보를 담고 있습니다.&lt;br&gt;
다음은 react element에서 fiber로 확장하는 코드입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiber.js &gt; createFiberFromElement()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// element = reactElement&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; pendingProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createFiberFromTypeAndProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  pendingProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  owner&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  mode&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  expirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;FiberNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tag&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 추후에 reactElement의 type을 할당&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stateNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// DOM에 마운트될 html element&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;return &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 부모 fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자식 fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 형제 fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자식들 중 자신의 위치&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pendingProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pendingProps&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// workInProgress는 아직 작업이 끝난 상태가 아니므로 props를 pending으로 관리&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// render phase가 끝나면 pendingProps는 memoizedProps로 관리&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;updateQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 라이프사이클과 관련된 queue&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// hook 객체 리스트&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Effects&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoEffect&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// fiber가 가지고 있는 side effect 종류를 기록&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// side effect linked list 관련&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nextEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoWork&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Work의 우선순위와 개별 Work를 나타내는 척도&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoWork&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자식으로부터 Work가 만들어질 경우 사용됨&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 반대편 fiber를 참조&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;react element가 개발자가 작성한 컴포넌트 겉 정보를 담고 있다면 fiber는 컴포넌트 내부에서 사용된 훅, 라이프 사이클 등 실질적으로 컴포넌트를 실행한 후에 발생하는 모든 정보를 담고 있습니다. Work와 관련된 정보도 모두 포함되기 때문에 fiber 자체를 실제 코드에서는 Work라고 표현하기도 합니다.&lt;br&gt;
fiber에는 너무 많은 정보가 있기 때문에 이런 게 있구나 하고 훑어만 보시면 됩니다. 추후에 하나도 빠짐없이 다루게 될 것입니다.&lt;/p&gt;
&lt;h2 id=&quot;side-effect&quot;&gt;&lt;a href=&quot;#side-effect&quot; aria-label=&quot;side effect permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;side effect&lt;/h2&gt;
&lt;p&gt;쉽게 생각해서 DOM에 변경점을 만들거나 혹은 변경점을 만들어낼 수도 있는 작업을 side effect라고 생각하면 됩니다(&lt;down&gt;또는 effect&lt;/down&gt;).
아래는 리액트에서 사용되는 side effect tag입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; NoEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;                &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; PerformedWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;           &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000001&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Placement &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;               &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000010&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;                  &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; PlacementAndUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;      &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000110&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Deletion &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;                &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000001000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ContentReset &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;            &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000010000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Passive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;                 &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0001000000000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 tag는 fiber의 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt;에 저장되며 side effect를 가지고 있는 fiber는 side effect list로 관리됩니다.
좀 더 자세히 설명하자면 side effect는 여러 종류가 있기 때문에 그 모든 걸 담고 있는 fiber 그 자체를 effect로 취급하여 관리 합니다.&lt;/p&gt;
&lt;p&gt;그리고 이 effect들은 연결리스트로 구성됩니다. 위 fiber 객체의 &lt;code class=&quot;language-text&quot;&gt;nextEffect&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;firstEffect&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;lastEffect&lt;/code&gt;가 이를 위한 속성들입니다. 이 속성들만 봐도 알 수 있듯이 연결 리스트 노드는 fiber 그 자체임을 알 수 있습니다. 그리고 이 정보는 부모로 전달되며 부모는 모든 자식의 effect를 list로 가지고 있게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 자식의 side effect를 부모로 올린다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nextEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 자신에게도 side effect가 있다면 자기 자신도 effect list에 추가해준다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; PerformedWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nextEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;최종적으로 root가 모든 effect를 들고 있게 됩니다.&lt;br&gt;
root의 effect 연결 리스트는 Commit phase에서 소비되면서 effect 종류에 맞는 시점에 특정 로직을 통해 처리됩니다.&lt;br&gt;
로직 순서를 보면 부모로 리스트를 올릴 때 자식을 먼저 연결하고 자신은 맨 마지막에 추가됩니다.&lt;br&gt;
중요한 부분은 아니지만 Coomit phase에서는 리스트 순서대로 처리되기 때문에 dfs(깊이 우선 탐색)의 순서대로 effect가 적용됨을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;!!!!!!!!!!!!!!!!!!!!!!!!! 여기에 이펙트 리스트 이미지 작성하기!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&lt;/p&gt;
&lt;p&gt;리액트에서는 effect tag나 여러 상태값들을 Bit Masking으로 관리합니다. 분석하기에 앞서 Bit Masking에 대해서 알고 있어야 하기 때문에 모르시는 분들을 위해 잠깐만 다루고 가겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;bit-masking&quot;&gt;&lt;a href=&quot;#bit-masking&quot; aria-label=&quot;bit masking permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Bit Masking&lt;/h2&gt;
&lt;p&gt;비트 연산을 통해서 상태를 관리한다고 보시면 됩니다.&lt;br&gt;
리액트에서는 현재 실행되고 있는 환경을 context로 관리합니다. 이 context를 통해 Bit Masking을 알아보겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;비트 연산자에 대한 설명은 생략하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정의된 context를 보면 render context는 16, commit context는 32로 정의되어 있습니다.&lt;br&gt;
이를 2진수로 변환하면 각각 10000, 100000 입니다.&lt;br&gt;
즉 2진수로 5번째 자리가 1이면 Render phase 란 뜻입니다.&lt;br&gt;
이제 이 2진수를 통해서 어떻게 상태를 확인하고 추가하는지 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;확인은 and(&amp;#x26;)연산, 추가는 or(|)연산, 삭제는 xor(~)연산을 이용합니다.&lt;/p&gt;
&lt;p&gt;다음과 같이 정의되어 있다고 가정합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; NoContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b00&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; RenderContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b01&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; CommitContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b10&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; executionContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoContext &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Render phase에 접어들어 현재 context에 render context를 추가한다면 다음과 같습니다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;|=&lt;/span&gt; RenderContext &lt;span class=&quot;token comment&quot;&gt;// 00 | 01 =&gt; 01&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 context에 따라서 분기 처리를 해야 한다면 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; RenderContext &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; NoContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 01 &amp;amp; 01 !== 00&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Render phase가 끝나고 Commit phase에 접어들 때는 이전 context를 지우고 다음 context를 추가해야 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;~&lt;/span&gt;RenderContext &lt;span class=&quot;token comment&quot;&gt;// 01 &amp;amp;  10 =&gt; 00&lt;/span&gt;
executionContext &lt;span class=&quot;token operator&quot;&gt;|=&lt;/span&gt; CommitContext &lt;span class=&quot;token comment&quot;&gt;// 00 | 10 =&gt; 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런식으로 연산은 비트 연산으로 저장은 십진수로 상태 값을 쉽게 관리할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;리액트-실제-사용-사례&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80&quot; aria-label=&quot;리액트 실제 사용 사례 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리액트 실제 사용 사례&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;RenderContext &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CommitContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; NoContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//현재 context가 Render phase이거나 Commit phase이면&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;msToExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사전 지식은 이 정도면 충분합니다.&lt;br&gt;
이해되지 않는다고 좌절할 필요는 없습니다. 그냥 이런 게 있구나 하고 기억만 해두시면 됩니다. 우리는 개발자이니 백번 말로 설명하는 것보단 한 번 코드로 보는 게 더 이해하기 쉬울 거라 생각합니다.&lt;/p&gt;
&lt;figure&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 568px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 21.12676056338028%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAAlklEQVQY001Pyw6EIAz0pDwl3MFIRAkJB/7/57qZburuYTJ9TKft4pwjrTWVUmjOSSkljp/noeu6GL13rt33zXlrjXVg1I0xBJ9932kRw5wzjTFYeBwHD8MIdcTneTLQgyl0WIqatfZnKIlSitZ1ZRZgMyAaALn0t21jlt73QuveAe/9yyEEqrXyS2C8h4tijK9O8H/hB7liY9htm+ykAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;showMeTheCode&quot; title=&quot;showMeTheCode&quot; src=&quot;/static/e6117eec2a6fedd9a10a636574357cc2/870c3/showMeTheCode.png&quot; srcset=&quot;/static/e6117eec2a6fedd9a10a636574357cc2/0780f/showMeTheCode.png 198w,
/static/e6117eec2a6fedd9a10a636574357cc2/47b26/showMeTheCode.png 395w,
/static/e6117eec2a6fedd9a10a636574357cc2/870c3/showMeTheCode.png 568w&quot; sizes=&quot;(max-width: 568px) 100vw, 568px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;이제 본격적으로 다음 포스트에서 코드와 함께 리액트 분석을 시작하도록 하겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-preview/&quot;&gt;React 톺아보기- 01. Preview&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;/react/in-depth-react-hooks_1/&quot;&gt;React 톺아보기- 03. Hooks_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 01. Preview]]></title><description><![CDATA[모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.…]]></description><link>https://github.com/goidle/react/in-depth-react-preview/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-preview/</guid><pubDate>Tue, 09 Jun 2020 09:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-들어가기에-앞서&quot;&gt;&lt;a href=&quot;#1-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C&quot; aria-label=&quot;1 들어가기에 앞서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 들어가기에 앞서&lt;/h1&gt;
&lt;p&gt;먼저 이 시리즈는 리액트 사용법에 대한 글이 아닙니다.&lt;br&gt;
리액트를 통해 프로젝트를 진행한 경험이 있고 동작 방식을 어렴풋이 이해하기는 하지만 여전히 리액트가 마법처럼 느껴지고 응용, 에러 디버깅 등에 어려움을 겪는 사람들을 위해 작성하였습니다.&lt;/p&gt;
&lt;p&gt;시리즈의 내용은 사용자의 상호작용으로부터 훅을 통해 컴포넌트가 업데이트되고 DOM에 마운트되기 까지의 일련의 과정을 실제 코드를 통해 분석해 나가게 될 것입니다. 친절히 요약해서 전달해 드리지 않습니다. 코드에 변형을 가하지 않고 코드 그대로 변수 하나하나 무엇을 위해 선언되었는지 A-Z까지 알아볼 것입니다.&lt;/p&gt;
&lt;p&gt;시리즈를 끝내고 나면 Virtual DOM이 무엇인지, 컴포넌트 상태가 바뀌었을 때 리액트는 어떻게 해당 컴포넌트를 리-렌더링시키는지, 어떻게 변경된 부분만 DOM에 마운트 되는지, hook은 컴포넌트와 어떤 방식으로 매핑되어 사용되는지, 이벤트 구현은 어떻게 되어 있는지 등 리액트의 전반적인 큰 줄기의 흐름을 알게 될 것입니다.&lt;/p&gt;
&lt;p&gt;들어가기에 앞서 당부 드리고 싶은 말씀은 코드를 분석할 때 필히 분석 대상이 어떤 패키지 밑에 있는 것이고 모듈과 함수 이름은 무엇인지 먼저 보고 머리에 담아둔 상태로 코드를 보시기 바랍니다.
리액트는 역할별로 많은 모듈과 동작에 맞는 함수들을 만들어 놓았습니다. 코드만 보고 넘어가게 된다면 리액트의 구조로 코드를 바라보기가 어려우며 이는 추후에 지금 내가 어디를 보고 있으며 어떠한 흐름으로 여기까지 왔는지 이해하기가 힘듭니다. 이해도 제대로 못 한 상태로 시간은 시간대로 날리고 가장 큰 걱정은 혼자 궁금한 부분을 분석하고 싶을 때 많은 어려움을 겪게 될 것입니다.&lt;/p&gt;
&lt;p&gt;여기서 언급되는 내용을 몰라도 리액트 프로젝트를 진행하는데 아무런 영향이 없지만, 이 시리즈를 통해 리액트에 대한 막연한 인식의 허들을 낮추고 궁금증을 가지고 있는 부분을 거기서 멈추지 않고 혼자 코드를 보면서 분석해보려는 의지를 심어 드리기 위하여 이 글을 작성해 봅니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;리액트 공식 홈페이지의 &lt;a href=&quot;https://reactjs.org/docs/getting-started.html&quot; target=&quot;_blank&quot;&gt;Docs&lt;/a&gt;을 정독하지 않으신 분이 혹시라도 계신다면 먼저 모든 글을 읽고 오시길 바랍니다. 리액트 뿐만 아니라 모든 것이 공홈을 먼저 보고 이해하고 난 후에 시작하는 게 순서입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;2-패키지-구조&quot;&gt;&lt;a href=&quot;#2-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;2 패키지 구조 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 패키지 구조&lt;/h1&gt;
&lt;p&gt;리액트는 react 코어, 플랫폼과 관련된 renderer, VDOM과 관련된 reconciler, Task 실행기인 scheduler 그리고 event로 나눌 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;react&quot;&gt;&lt;a href=&quot;#react&quot; aria-label=&quot;react permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;react&lt;/h3&gt;
&lt;p&gt;컴포넌트 정의와 관련된 API가 있는 패키지입니다.&lt;br&gt;
대표적으로 React element를 만드는 &lt;code class=&quot;language-text&quot;&gt;createElement()&lt;/code&gt;가 있으며 개발자에게 다른 패키지의 모듈을 제공할 수 있도록 중간 다리 역할을 하는 모듈들만 위치해 있습니다.&lt;br&gt;
이 코어는 다른 패키지에 의존성을 가지고 있지 않기 때문에 여러 플랫폼에 올려서 사용할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;renderer&quot;&gt;&lt;a href=&quot;#renderer&quot; aria-label=&quot;renderer permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;renderer&lt;/h3&gt;
&lt;p&gt;플랫폼과 관련된 네이티브 모듈이 위치해 있습니다. react-dom, react-native-renderer가 여기에 해당합니다.&lt;br&gt;
플랫폼과 react를 연결하며 실질적으로 플랫폼에 컴포넌트를 마운트합니다. reconciler와 lagacy-event 패키지에 의존성을 가지고 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;eventlegacy-events&quot;&gt;&lt;a href=&quot;#eventlegacy-events&quot; aria-label=&quot;eventlegacy events permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;event(legacy-events)&lt;/h3&gt;
&lt;p&gt;SyntheticEvent라는 이름으로 구현되어 있습니다. native event를 wrapping하며 개발자가 native event를 사용하기 전 리액트에서 추가적인 제어를 하기 위해 따로 개발된 이벤트 시스템입니다.&lt;br&gt;
현재 리액트에서 제일 바꾸고 싶어 하는 영역으로 보이며 구현을 변경하다 중단된 걸 보아하니 쉽지 않아 보입니다.&lt;/p&gt;
&lt;h3 id=&quot;scheduler&quot;&gt;&lt;a href=&quot;#scheduler&quot; aria-label=&quot;scheduler permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;scheduler&lt;/h3&gt;
&lt;p&gt;리액트는 여러가지 이유로 작업을 비동기로 실행시켜야 합니다. 이 작업은 Task란 이름으로 우선순위에 따라 스케줄링 됩니다.&lt;br&gt;
그리고 이 Task를 실행하기에 가장 적기인 때를 알고 있는 것이 scheduler이므로 리액트는 스켈줄링만 시키고 나머지 제어권은 scheduler에게 위임합니다.&lt;br&gt;
scheduler는 여러가지 기준을 바탕으로 Task를 최소 힙 자료구조에서 꺼내 실행합니다.&lt;br&gt;
이 패키지는 플랫폼에 의존적입니다.&lt;/p&gt;
&lt;h3 id=&quot;reconciler&quot;&gt;&lt;a href=&quot;#reconciler&quot; aria-label=&quot;reconciler permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;reconciler&lt;/h3&gt;
&lt;p&gt;리액트의 핵심 패키지입니다.&lt;br&gt;
그만큼 여러 고민과 노력이 들어가 있고 이 시리즈에서 가장 많은 시간을 보내게 될 패키지입니다.&lt;br&gt;
v15 이전에는 stack기반 구현이었다면 v16부터는 몇 년간의 연구 끝에 fiber architecture를 도입했습니다.&lt;br&gt;
VDOM 노드에 해당하는 fiber, VDOM 생성과 순회, diff 알고리즘 등 중요한 로직들이 위치해 있습니다.&lt;/p&gt;
&lt;figure&gt;
  &lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 216px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 297.6851851851852%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAA8CAYAAABmdppWAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAI20lEQVRYw5VYV3sb1xXU75AtCiRBlMWi9w4s+qIXVhXKsiz5i00rX+Ka+D0v+c+TmbtEIyjJeVgucbm4O3fOOXPm8EksXUM2V0Ok/Rr56Qfkiy00OlO0+zNUnRHqrRHShQYiiSLsZOmL15NYpoZCoY7o+A6ju/+i051jfvEWk/kNVtfvcf3iO2SKTQQiGYRiOYSiOQTtrLmvP+tl6+vJScDmYhrhkI22O0Wu2kYklkU6X+FGdSSSeaRzVSQyZaSyZcRSBWTyVSSzFSTTRfP5NBjFScC7nhyfWYjE+XYrgcXr93CGC1RrXcyWlzz2GJ2Wi747x3hyjl53jHSxhsFoBqc7hNPso9Of4Ixgnp9a8PktIjyLIGSnuBhDuT1EPFdBMJLiS7KIp/IIR1P8exrZYhU2XxxLFpAQsiSPHkng2XEQx9xjfRmEdiIHy07i+v1P6EwvUSg5GAxnmM4uUG920OyMMJuv0O25XF9hNrvEaDInHRl87QsSXdhcZsOTABFGkvCTB/FnJ8WJbWgIWHGcEnnITuCYXPvDcXOS01AUft4tniLI7+rZYCSO5zryLsKbDx/RnV2h0epjcfUC/QE55DVerrB6eYuBO0HDGWCyuCCPU1SbPSK9IN/naHX7PH7IQ6i3CFWm3ORbcwgQiXgNcF13K5pBlC8NWEn+nkKYa5GYTpAwx1wHZMOhHo7wwdsff4a7eslcHGM0XaBcH2A0nvNaoOn00WUGiMvJeIXl6pJIlzgloPVmPn9kjTBhECbzNcOLuAuRAvHkD8U3J1iTrw3El8+/ReZtKA75I8rkjTC53/z0KwYG4QhDIqswHyfLK0Z2QuLThqPdFNndaJM2qhQh1F05qKqxyY/QHZ/ZOCOfQSthquEszAjzuYeodNTNhr4dhN98/A3u+Su0WB3Lq1eM3oWJuKphyt+nzL9KrXmQzHuJLWSKliomlikZhEKnl9jxbSS1ploV0l2EBxvqjzGWmB1L47uf/8Tw/DWro4/56oZcDgwVvp0AbCNqfRmhnSqaOtbDWlcGrEvqU0F4FKE5HhG+/fsfJg9rRDhjdJ2OayLcGww3G39uswOE0XTJIFRkw+RSuagc1GeTe6fWAVLf5xC++8e/yeErVOodjGfnaHddtgCinS+NPiazRRydhDa8PobYy0MhDCjKZcq6F1nVqtaFcB3t9Uba9FMBesDh7xgsX6BEGXPHSy8HB1MsFpdUHjYuKo/THsCdLtHqjwxNjyJcc5hg7wjfI5RgCJ24jCay5qXJbMn8TWkmDXz0yB7CHGx+8fbuF/TmVwbhYLSg9vUMQnc4ZgObEOEUHUb+OY+8SaeHpbfhkB+kNhEiCTHScXYzizSot4hPITTIuKbNJP3iclvP1iGHb+5+RY+KXay0iHC+QThwR+gMp+i6MyIcolBtYTxfsK5be0Ww6SlG7wKeYnvVkmRXyxu1tqnginKEPNpx75KSRxJez/nq6AxfPeflC9zr4X1PkWLfvP+I1miFLJ1Ek1yVqg7zcIBWp4d6xzW/N5pdFMoNdKlATaJtdgZw+kNUGx3T6PYQ5pnQykWhKxCteEzSLWRydA10Elk2efXkeKaIIjdN57y1IiVNd7PhtuulcPXuR+Mc0rQaNfJXJkdC1XQ6qPFeY1+pN4iw4pBbomNOBim6T3lsaeSec9Ducg6pYsMgK5F43VNEkSvI59QMihRzUesZruX47Fk4avrLydY5RAzRQri8/YB6b2KOWaq1kS/V2fk6RqVL5KhUb6PEo2a47rT7KFabVKYeAsGI2XSz4RphvT/lw+KuSIFo03EViapOa0J03KRQIVfkMkFlL1YafKljaDkNbJPbbKgyCjMw05u3qLCfyLoVGeFsocp7yyAUbzkGqsCNFaBmu4divcUED2w2u0+biHFY8izOaIk8W6d8YJ0B0IZCVRIaY5pclLlx1qTN0Bz5oJYNQpZWiK10dHmLEr2LjpwnGm2YKzV4LAdpHvPpkd9EU9dTJvMzX/Cw9PRDNSs/01/emA3lWJ22yygyx4hIyZxjtFXDKjN9Z11qjyK0qDRBllFneoEc6zhMg2k6IaOvaKeIVGglIr6dFHmsv9wjpDoT4fCC8s9cFCqJQ7mqKNKOqKWyxFRNqlsdebdp+R5uKBHVkVsMitJGn1V+yYxXZpl82SBWBRWYRhmi1TOPtdhN2si0z1++Q3MwZ506bAELk4sl5pk7psiOZ+gTdZdWr0cZUyas9fBgQxlIIazxYYmsEl3CKiW3jKCGjDwp574+9u676PaalIcwy8RO4PzN93DcheFwyCYlSaow/wIUgDVvR7qI7IjW7oDL/bEialJGhklypkApP8VVggYgTk61pualYSd+PwTJDBwgtA3CJC6//QHt8Tkj6zV6tVHJlsYLl7xJHJoUhf5wjuF0hf5kQSWq7nHpjRW2N1ZIYKMUULVKITMVZHvGfW2RxalReKUa1072PLa1Y9r5pVd/+6dpUtU6R7OFzBIlnzLvUnSns5lBPppMmZdXmNNM9TiiWZxhdgO0Z9olrjLtx/edTOZSlzGc90OPWuzzk7AJyNqS7EZ626SI8PUPRDi/ptIMsDy/4TAzpOUYk68FeryGHNcuWE0lCseze9P0iGnfNimTg1HPsHujhWftlI/iS7z+ZcOpNvrNx9+Nnas2erTE17RzHGF7I/K3NAbeJULTQ04/bYs3VkQIlVtr034WTnjDY9AbFM3QaPi0PmuPt1Yk6tk5WeJNlJmHDaKc0L4p77KFsqkQSf4n/eH+WFEmVymDRKjN0EN+9XvA8jLBi75txt2/gHDHtBOhoixlWXB8LRH1eH6OGXNwRX4n0znlrXCgOPumnb1E/w7wB2OmbjWKeSi3o5meDZBffyi657UfDD4FRDX4/PInxle3qDTajOo1xzFWxNUNc/IFotTMtd1YT6Sf55D5GLULOAsmzL8APM/H4dHyeDR++guT6BahkaYU/uX8B9/271BstTGhwgzJWbvnbhD9X4OPHszG68hl66YqYsYCFwyXX9pk9/ofOYR93DhZdS4AAAAASUVORK5CYII=&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;package&quot; title=&quot;package&quot; src=&quot;/static/2161b4e7c99ef600b95b2c20e47f9d08/68dea/package.png&quot; srcset=&quot;/static/2161b4e7c99ef600b95b2c20e47f9d08/0780f/package.png 198w,
/static/2161b4e7c99ef600b95b2c20e47f9d08/68dea/package.png 216w&quot; sizes=&quot;(max-width: 216px) 100vw, 216px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
  &lt;figcaption&gt;&amp;#xC2E4;&amp;#xC81C; &amp;#xB9AC;&amp;#xC561;&amp;#xD2B8; &amp;#xD328;&amp;#xD0A4;&amp;#xC9C0;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h1 id=&quot;3-용어-정리&quot;&gt;&lt;a href=&quot;#3-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;3 용어 정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 용어 정리&lt;/h1&gt;
&lt;h3 id=&quot;컴포넌트&quot;&gt;&lt;a href=&quot;#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8&quot; aria-label=&quot;컴포넌트 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;컴포넌트&lt;/h3&gt;
&lt;p&gt;리액트에서는 자체 제공하는 컴포넌트, 사용자 정의 컴포넌트, 플랫폼 컴포넌트 등 여러 종류의 컴포넌트가 있습니다.
플랫폼 컴포넌트는 Host Component 사용자 정의 컴포넌트는 Custom Component , VDOM의 최상단 노드는 Host Root라고 명칭 하겠습니다.&lt;br&gt;
본 시리즈에서는 이 이외에 컴포넌트는 다루지 않습니다(&lt;down&gt;Suspense, Memo, Context..&lt;/down&gt;)&lt;/p&gt;
&lt;h3 id=&quot;렌더링&quot;&gt;&lt;a href=&quot;#%EB%A0%8C%EB%8D%94%EB%A7%81&quot; aria-label=&quot;렌더링 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;렌더링&lt;/h3&gt;
&lt;p&gt;일반적으로 컴포넌트의 실행을 렌더링이라고 말합니다. 하지만 세부 구현 사항으로 내려가면 여러 단계가 더 존재하기 때문에 용어 혼동을 방지하기 위해 좀 더 세분화 하도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;컴포넌트 실행은 reconciler에서 합니다. 그 후 VDOM 재조정 작업이 들어가고 DOM에 마운트됩니다.&lt;br&gt;
컴포넌트 실행과 DOM에 삽입되는 것은 별개라는 뜻입니다. 그리고 마운트와 화면에 그려지는 것 또한 마찬가지로 별개입니다.&lt;/p&gt;
&lt;p&gt;앞으로 렌더링은 컴포넌트가 실행되어 자식을 반환하고 host component들을 VDOM에 마운트하는 일련의 과정을 일컫는다고 하겠습니다.&lt;br&gt;
컴포넌트 실행은 그저 함수 ‘호출’로만 생각하면 됩니다. &lt;strong&gt;&lt;em&gt;‘react element를 반환한다.’&lt;/em&gt;&lt;/strong&gt; 그 이상 그 이하도 아닙니다.&lt;br&gt;
VDOM을 DOM에 삽입하는 것을 마운트, 브라우저가 화면에 그리는 걸 페인트라 정의하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;virtual-dom&quot;&gt;&lt;a href=&quot;#virtual-dom&quot; aria-label=&quot;virtual dom permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Virtual DOM&lt;/h3&gt;
&lt;p&gt;이하 VDOM으로 명칭&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;reactElement , fiber&lt;br&gt;
reactElement는 컴포넌트의 겉 정보인 type, props만을 가진 객체입니다. 컴포넌트가 반환하는 자식이 react element입니다.&lt;br&gt;
VDOM의 노드는 fiber라고 불리는 객체입니다. 이 객체는 컴포넌트가 반환한 react element를 VDOM에 올리기 위해 확장시켜주는 객체입니다.&lt;br&gt;
이 fiber를 통해 컴포넌트의 state, hook, life cycle 등 대부분이 관리됩니다.&lt;/li&gt;
&lt;li&gt;current, workInProgress&lt;br&gt;
리액트는 더블 버퍼링 형태로 VDOM을 설계 했습니다.&lt;br&gt;
current는 마운트가 끝난 트리이며 workInProgress는 업데이트가 적용 중인 트리입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;더 많은 용어들이 있지만 크게 혼동되는 부분만 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;02&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;a href=&quot;/react/in-depth-react-intro/&quot;&gt;React 톺아보기- 02. Intro&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[Redux 톺아보기]]></title><description><![CDATA[혹시 궁금해봤니❓ Redux를 사용하면서 다음과 같은 물음을 가진 경험이 있습니까? 나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것
일까? redux…]]></description><link>https://github.com/goidle/redux/in-depth-redux/</link><guid isPermaLink="false">https://github.com/goidle/redux/in-depth-redux/</guid><pubDate>Wed, 25 Dec 2019 22:40:13 GMT</pubDate><content:encoded>&lt;img src=&quot;/5c7392a91f8cd5d997137f6b4a36870b/logo.svg&quot; height=&quot;350&quot; width=&quot;100%&quot;&gt;
&lt;h2 id=&quot;혹시-궁금해봤니&quot;&gt;&lt;a href=&quot;#%ED%98%B9%EC%8B%9C-%EA%B6%81%EA%B8%88%ED%95%B4%EB%B4%A4%EB%8B%88&quot; aria-label=&quot;혹시 궁금해봤니 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;혹시 궁금해봤니❓&lt;/h2&gt;
&lt;p&gt;Redux를 사용하면서 다음과 같은 물음을 가진 경험이 있습니까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것
일까?&lt;/li&gt;
&lt;li&gt;redux는 전달해준 액션을 어떻게 내가 원하는 reducer에 전달해주는 것일까?&lt;/li&gt;
&lt;li&gt;reducer에서 반환하는 값을 왜 항상 새로 만들어야 하는 것일까? 순수함수는 무엇인가?&lt;/li&gt;
&lt;li&gt;redux state가 변경되면 모든 컴포넌트가 re-render 되는가? 아니면 해당 변경된 데이터를 참조하고 있는 컴포넌트만 re-render 되는가? 후자라면 이 또한 어떻게 그 컴포넌트만을 찾아서 re-render 시키는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 물음을 한 적이 없다면 혹은 &lt;strong&gt;&lt;em&gt;“뭐 뒤에서 알아서 해주겠지 이건 매직 코드야”&lt;/em&gt;&lt;/strong&gt;라고 생각만 했다면 이참에 글쓴이와 함께 오픈소스를 분석하면서 이런 물음에 답을 찾음과 동시에 매직 코드에 대한 막연함, 두려움을 없애고 단순 라이브러리 개발자가 아닌 진짜 생각하는 개발자, 스스로 발전할 수 있는 개발자가 되기 위한 기초를 다질 수 있는 능력을 함께 길러갔으면 좋겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;해당 포스트에서 언급하는 코드들은 많은 부분이 생략된 코드 스니펫이므로 전체 코드는 &lt;a href=&quot;https://github.com/reduxjs/redux&quot;&gt;Redux Github&lt;/a&gt;에서 확인해 보실 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-나는-액션을-dispatch만-하였는데-redux는-어떻게-알고-뒤에서-middleware를-실행하는-것일까&quot;&gt;&lt;a href=&quot;#1-%EB%82%98%EB%8A%94-%EC%95%A1%EC%85%98%EC%9D%84-dispatch%EB%A7%8C-%ED%95%98%EC%98%80%EB%8A%94%EB%8D%B0-redux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%95%8C%EA%B3%A0-%EB%92%A4%EC%97%90%EC%84%9C-middleware%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C&quot; aria-label=&quot;1 나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것일까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것일까❓&lt;/h2&gt;
&lt;p&gt;들어가기에 앞서 하나 미리 짚어가야할 점은 middleware 형태는 다음과 같이 약속되어 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;middleware&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; getState &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* something.. */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해당 섹션의 최종 목적은 위 middleware의 인자들이 언제 소비되는지 알아보는 것입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위와 같은 형식을 &lt;strong&gt;Currying&lt;/strong&gt;이라 부릅니다.&lt;br&gt;
필요한 데이터를 클로저를 이용하여 각각의 의미가 있는 함수에 인자로 잡아두고 &lt;strong&gt;lazy execution&lt;/strong&gt;하는 방식으로 자세한 설명은 넘어가지만, 반드시 따로 찾아보시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;redux의 middleware는 어떻게 동작하는 것일까?&lt;br&gt;
이 물음의 해답을 찾아가기 위해서는 middleware를 맨 처음 사용하는 &lt;a href=&quot;https://github.com/reduxjs/redux/blob/master/src/applyMiddleware.ts&quot;&gt;applyMiddleware&lt;/a&gt; 함수를 먼저 볼 필요가 있습니다.
우리가 들여다봐야 할 코드는 다음 두 줄입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyMiddleware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;middlewares&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; middlewareAPI &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    getState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;getState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; chain &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; middlewares&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;middleware&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;middleware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;middlewareAPI&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;chain&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    dispatch
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫 시작은 &lt;code class=&quot;language-text&quot;&gt;middlewareAPI&lt;/code&gt;를 모든 middleware &lt;code class=&quot;language-text&quot;&gt;({ dispatch, getState }) =&amp;gt;&lt;/code&gt;에 넘겨주어 redux의 핵심 기능을 middleware에서 사용 할 수 있도록 해줍니다.&lt;br&gt;
&lt;a href=&quot;https://github.com/reduxjs/redux-thunk/blob/master/src/index.js#L4&quot;&gt;redux-thunk&lt;/a&gt;의 경우 넘겨준 위 &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;를 이용하여 비동기 처리를 합니다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;는 함수를 합성하는데 이는 javascript function이 first-class objects인 점을 활용한 방법으로 함수형에서 많이 사용합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;first-class&quot;&gt;&lt;a href=&quot;#first-class&quot; aria-label=&quot;first class permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;first-class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;변수에 할당할 수 있다.&lt;/li&gt;
&lt;li&gt;함수의 인자값으로 전달 할 수 있다.&lt;/li&gt;
&lt;li&gt;함수의 반환 값으로 반환할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;또한 decorator패턴 입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이 패턴은 변경에는 닫혀 있고 확장에는 열려 있는 원칙이 묻어 있는 패턴입니다.
기능 추가에 기존 코드 변경이 필요가 없으며 기능을 무한히 추가할 수 있습니다.
middleware를 추가함에 있어 redux 코드에 전혀 영향이 가지 않고 변경 또한 필요하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;넘겨준 middleware가 &lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;안에서 어떻게 합성되는지 알아보겠습니다. 이런 방식이 익숙지 않은 분들은
머리가 조금 아플수도 있습니다. 하지만 하나씩 찬찬히 뜯어볼 생각이므로 포기하지 마시길 바랍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;middlewares&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; middlewares&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;코드는 간단해 보입니다.&lt;br&gt;
여기서 middleware의 &lt;code class=&quot;language-text&quot;&gt;(next) =&amp;gt;&lt;/code&gt;가 소비됩니다. 예로 [a, b, c] middleware가 있다면 &lt;code class=&quot;language-text&quot;&gt;a(b(c()))&lt;/code&gt;의 형태로 만들어 주면서 next를 다음 middleware로 할당합니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;가 끝난 형태는 &lt;code class=&quot;language-text&quot;&gt;(...args) =&amp;gt; a(b(c(...args)))&lt;/code&gt;가 됩니다.
더 정확하게는 &lt;code class=&quot;language-text&quot;&gt;(...args) =&amp;gt; f&amp;#39;(c(...args))&lt;/code&gt;이며 f’는 &lt;code class=&quot;language-text&quot;&gt;(c반환 값) =&amp;gt; a(b(c반환 값))&lt;/code&gt;가 됩니다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;가 반환한 함수의 형태를 보면 실행하기 전까지 &lt;code class=&quot;language-text&quot;&gt;(next) =&amp;gt;&lt;/code&gt;가 소비되지 않는 형태입니다. &lt;code class=&quot;language-text&quot;&gt;compose(...chain)(store.dispatch)&lt;/code&gt;를 통해 store의 dispatch를 넘겨주는데 이때 맨 마지막 middleware의 next를 dispatch로 할당하면서 도화선처럼 나머지의 middleware &lt;code class=&quot;language-text&quot;&gt;(next) =&amp;gt;&lt;/code&gt;도 연달아 소비시킵니다.&lt;/p&gt;
&lt;p&gt;c middleware의 next는 store의 dispatch인 걸 주목합니다. 즉 &lt;u&gt;&lt;strong&gt;우리가 쓰는 dispatch는 middleware가 층층이 겹쳐져 있는 함수이지 redux의 dispatch가 아닙니다😲&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;그리고 우리가 dispatch를 이용하여 Action을 날릴 때 비로소 &lt;code class=&quot;language-text&quot;&gt;(action) =&amp;gt;&lt;/code&gt;가 소비 됩니다. 계속해서 next(action)를 전달하면 위에서 currying하여 잡아둔 다음 middleware의 &lt;code class=&quot;language-text&quot;&gt;(action) =&amp;gt;&lt;/code&gt;를 소비하게 되는 것이고 마지막 middleware의 next는 redux의 dispatch이기 때문에 최종적으로 redux에 action이 도달하게 됩니다.&lt;/p&gt;
&lt;p&gt;누군가가 나에게 다음과 같은 질문을 한다고 생각해 봅시다.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 건가요?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
네. 지금 보니 간단한 질문이네요&lt;/p&gt;
&lt;h2 id=&quot;2-redux는-전달해준-액션을-어떻게-내가-원하는-reducer에-전달해주는-것-일까&quot;&gt;&lt;a href=&quot;#2-redux%EB%8A%94-%EC%A0%84%EB%8B%AC%ED%95%B4%EC%A4%80-%EC%95%A1%EC%85%98%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%82%B4%EA%B0%80-%EC%9B%90%ED%95%98%EB%8A%94-reducer%EC%97%90-%EC%A0%84%EB%8B%AC%ED%95%B4%EC%A3%BC%EB%8A%94-%EA%B2%83-%EC%9D%BC%EA%B9%8C&quot; aria-label=&quot;2 redux는 전달해준 액션을 어떻게 내가 원하는 reducer에 전달해주는 것 일까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Redux는 전달해준 액션을 어떻게 내가 원하는 reducer에 전달해주는 것 일까❓&lt;/h2&gt;
&lt;p&gt;이번에도 역시 reducer가 가장 먼저 쓰이는 &lt;a href=&quot;https://github.com/reduxjs/redux/blob/master/src/combineReducers.ts#L139&quot;&gt;combineReducers&lt;/a&gt; 부터 들여다 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;combineReducers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;reducers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; finalReducers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; reducerKeys&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reducerKeys&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; reducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;function&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      finalReducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; finalReducerKeys &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;finalReducers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;combination&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* something.. */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reducer의 최소 조건인 function을 검증하면서 key를 잡고 있습니다. 이는 추후에 reducer의 이름, 다시 말해 redux의 state 객체의 각 property 이름이 바로 &lt;code class=&quot;language-text&quot;&gt;combineReducers&lt;/code&gt;에 넘겨주는 객체의 key에 의해 정해집니다.  &lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;combination&lt;/code&gt; 함수를 반환해 줍니다. &lt;code class=&quot;language-text&quot;&gt;combineReducers&lt;/code&gt; 코드는 환경설정이라 할 수 있고 실 기능은 &lt;code class=&quot;language-text&quot;&gt;combination&lt;/code&gt;이 담당하고 있으며 이는 redux내부에서 사용되어 집니다. 이렇게 코드가 나누어져 있는 이유는 무엇일까요?  &lt;/p&gt;
&lt;p&gt;코드의 성질과 역할이 달라서 격리했다고 생각합니다. 역할별로 나누어서 한번 정해지면 변경될 일이 없는 부분과 요구 사항에 따라 추가 변경이 일어날 확률이 높고 주입되는 상태가 언제든지 변경될 수 있으며 재사용이 높은 부분을 나누었다고 볼 수 있습니다. 분명 이렇게 나누지 않았다면 변경될 확률이 낮은 코드들이 자주 변경되는 코드와 혼재되어 변경에 영향을 받는 코드의 범위가 커지면서 버그, 테스트, 유지보수 등 여러 면에서 좋지 않습니다.
이런 역할, 변화에 따른 격리는 여러 오픈소스를 보면 자주 보이는 형식으로 역할 모델별로 나누는 연습을 많이 해야 합니다.&lt;/p&gt;
&lt;p&gt;그러면 이 함수가 사용되는 곳은 어디일까요?
redux의 dispatch에서 사용됩니다. action을 dispatch에 담아 보내면 &lt;u&gt;middleware -&gt; redux dispatch -&gt; reducer의 순서로 흐릅니다.&lt;/u&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;combination&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; nextState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; finalReducerKeys&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; finalReducerKeys&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; reducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; finalReducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; previousStateForKey &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; nextStateForKey &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;previousStateForKey&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;    nextState&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextStateForKey
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    hasChanged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; nextStateForKey &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; previousStateForKey &lt;span class=&quot;token comment&quot;&gt;// 3&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  hasChanged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; finalReducerKeys&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; nextState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; state
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;보이시나요? 모든 reducer를 돌면서 state와 action을 던져줍니다(1, 2). 그리고 변경이 적용되기 위해선 객체를 새로 만들어야 하는 이유도 보입니다(3).
자신이 처리하지 않는 action의 경우 그저 default(switch의 경우)의 반환 값이 반환될 것입니다. 그다음 변경 여부는 값이 아닌 reference 비교로 결정됩니다.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“reference로 변경 여부를 결정 하므로 항상 새로운 객체를 반환해야 해!”&lt;/em&gt;&lt;/strong&gt;라고 여기까지만 생각하고 개발하는 것은 2%가 부족합니다.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“왜?”&lt;/em&gt;&lt;/strong&gt;가 빠져있습니다. redux는 왜 직접 데이터를 변경하지 않고 새로운 객체를 만들까? 그게 더 비용이 들지는 않을까? 여기에 대한 대답은 &lt;strong&gt;순수함수&lt;/strong&gt;에서 스스로 찾아보세요!  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;순수함수를 쓰는 이유 중 하나는 객체의 투 포인터 참조에서 오는 데이터 공유 때문 입니다.
단순 변수만을 참조하는 원 포인터 참조는 기존 데이터 변경에 영향을 받지 않습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
bar &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; foo &lt;span class=&quot;token comment&quot;&gt;// false;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;하지만 투 포인터 참조를 할 경우 그렇지 않습니다.  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;f&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;o&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;o&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
bar&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;f&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;당연한 얘기 같습니다. 여기서 중요한 점은 foo를 여러 곳에서 물고 있으면 foo의 데이터 변경이 어느 곳에 여파를 미치는지 예측할 수 없습니다.
하지만 새로운 객체를 만들어 데이터 변경을 적용하게 되면 기존에 foo를 물고 있던 곳에 영향을 주지 않습니다. 더불어 그 변경의 여파는 새로운 데이터를 반환받아 적용한 곳부터 시작하기 때문에 추적 또한 용이합니다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;“redux는 전달해준 액션을 어떻게 해당 액션을 처리하는 reducer에 전달해주는 것일까?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
여기에 대한 대답은 &lt;u&gt;해당 action을 처리하는 reducer에게만 넘겨주는 게 아니라 모든 reducer에게 액션을 던진다입니다.&lt;/u&gt;&lt;br&gt;
또한 &lt;strong&gt;&lt;em&gt;“reducer에서 반환하는 값을 왜 항상 새로 만들어야 하는 것일까? 순수함수는 무엇인가?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
여기에 대한 대답도 할 수 있겠네요😀  &lt;/p&gt;
&lt;h2 id=&quot;3-redux-state가-변경되면-모든-컴포넌트들이-re-render되는가&quot;&gt;&lt;a href=&quot;#3-redux-state%EA%B0%80-%EB%B3%80%EA%B2%BD%EB%90%98%EB%A9%B4-%EB%AA%A8%EB%93%A0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%93%A4%EC%9D%B4-re-render%EB%90%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;3 redux state가 변경되면 모든 컴포넌트들이 re render되는가 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. redux state가 변경되면 모든 컴포넌트들이 re-render되는가❓&lt;/h2&gt;
&lt;p&gt;마지막 섹션입니다. 코드는 &lt;a href=&quot;https://github.com/reduxjs/react-redux/tree/master/src&quot;&gt;react-redux&lt;/a&gt;에서 확인해 보실 수 있습니다.
해당 부분은 class와 funcitonal component에 따라 봐야할 부분이 다르기 때문에 최근에 대두되는 hook을 기준으로 분석해 보겠습니다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;해당 섹션은 hook을 중심으로 이야기 합니다. hook을 모르신다면 먼저 &lt;a href=&quot;https://reactjs.org/docs/hooks-intro.html&quot;&gt;Hooks&lt;/a&gt;를 보고오시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어디서 부터 접근해야 할 까요? class의 경우 component와의 접점인 connect부터 접근했겠지만 hook은 그런 부분이 없습니다. 그렇다면 그나마 데이터에 접근하는 useSelector가 가장 유력해 보입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;selector&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; equalityFn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; refEquality&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; subscription&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; contextSub &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useReduxContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    selector&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    equalityFn&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    contextSub
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useSelector&lt;/code&gt;의 두 번째 인자로 비교 함수를 전달해줄 수 있습니다. 기본적으로 shallow compare이며 성능 최적화 등 특정 케이스에서 유용하게 사용될 수 있기 때문에 알아두면 좋습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;useReduxContext&lt;/code&gt;는 context API를 이용하여 redux의 store와 &lt;strong&gt;observer 패턴&lt;/strong&gt; 을 구현한 Subscription 객체를 전달받습니다. 요놈들의 데이터를 넣어주는 context는 어디에 있느냐? 바로 우리가 쓰는 &lt;code class=&quot;language-text&quot;&gt;Provider&lt;/code&gt; 컴포넌트에 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Provider&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; context&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; children &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subscription &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Context &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; context &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; ReactReduxContext
 &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Provider value&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; subscription&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;Context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Provider&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Context는 &lt;a href=&quot;https://ko.reactjs.org/docs/context.html&quot;&gt;링크&lt;/a&gt;를 통해 정확히 알고 가는 게 좋습니다. 활용도가 매우 다양하며 여러분들이 알게 모르게 라이브러리를 통해 이미 쓰고 있어서 분석에 많은 도움이 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;useSelector의 &lt;code class=&quot;language-text&quot;&gt;useSelectorWithStoreAndSubs&lt;/code&gt;를 살펴보기에 앞서 위에 언급한 Subscription을 먼저 봐야 합니다. redux store의 state가 변경되면 redux는 자신을 subscribe하고 있는 listener들을 전부 실행 시켜 줍니다. react-redux는 react와 redux를 연결하기 위해 observable, observer 두 가지 역할을 가진 Subscription을 구현하여 redux 상태 변경을 subscribe 함과 동시에 자신을 subscribe하고 있는 listener를 가지고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subscription&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;handleChangeWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onStateChange&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;onStateChange&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;trySubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;unsubscribe&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;unsubscribe &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handleChangeWrapper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// usage&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subscription &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onStateChange &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; checkForUpdates
subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;trySubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;trySubscribe&lt;/code&gt;를 통해 store를 subscribe하고 store의 state가 변경되면 &lt;code class=&quot;language-text&quot;&gt;onStateChange&lt;/code&gt;를 실행해 줍니다. 계층 구조 전파를 위한 코드들이 빠져 있는 스니펫이므로 궁금하시면 직접 확인해 보시기 바랍니다.&lt;br&gt;
드디어 핵심인 &lt;code class=&quot;language-text&quot;&gt;useSelectorWithStoreAndSubscription&lt;/code&gt;를 살펴보기 위한 준비과정이 끝났습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; forceRender&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; s &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; latestSelector &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; latestSelectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;forceRender&lt;/code&gt;는 component를 강제로 re-render시키기 위한 방법중 하나 입니다. useState를 사용할 수도 있습니다. 그리고 selector와 그 결괏값인 state를 memoizing 하기 위해 변수를 할당합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    selector &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; latestSelector&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;/span&gt;    latestSubscriptionCallbackError&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    selectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    selectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;useIsomorphicLayoutEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    latestSelector&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; selector
    latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; selectedState
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;강조된 부분을 봤을 때 어떤 생각이 드시나요?&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“잘못 사용하면 ref의 memoization 이점을 전혀 못 누리겠구나”&lt;/em&gt;&lt;/strong&gt; 라고 생각이 드시나요?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대부분 이렇게 사용하실 겁니다. foo를 select 하는 callback은 항상 새로 만들어지는 함수입니다.&lt;br&gt;
그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;selector !== latestSelector.current&lt;/code&gt;는 항상 true가 될 것이고 컴포넌트가 re-render 될 때마다 selector는 매번 실행될 겁니다. 간단한 selector의 경우별 차이가 없겠지만 복잡한 연산이 필요한 selector의 경우 불필요한 연산을 추가로 하게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;selectFoo&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;useSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;selectFoo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Component가 아무리 re-render 돼도 selectFoo는 항상 같기 때문에 이미 구해놓은 &lt;code class=&quot;language-text&quot;&gt;latestSelectedState.current&lt;/code&gt;를 사용할 수 있습니다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;selector가 항상 이렇게 간단하지만은 않죠? 외부 인자에 의존할 경우 다른 방법을 강구해야 합니다.
이와 관련하여 이미 아주 좋은 &lt;a href=&quot;https://github.com/reduxjs/reselect#readme&quot;&gt;라이브러리(reselect)&lt;/a&gt;가 있습니다.
이참에 reselect가 어떻게 결괏값을 memoize 하는지 알아보는 것부터 시작하는 것도 좋습니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkForUpdates&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newSelectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; latestSelector&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;equalityFn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newSelectedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newSelectedState
    &lt;span class=&quot;token function&quot;&gt;forceRender&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;checkForUpdates&lt;/code&gt;에서는 selector를 실행하고 값이 변경되었는지 확인 후 변경된 state를 memoizing 하고 &lt;code class=&quot;language-text&quot;&gt;forceRender&lt;/code&gt;를 통해 강제로 컴포넌트를 re-render 시킵니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkForUpdates&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* 생략.. */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onStateChange &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; checkForUpdates
  subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;trySubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;checkForUpdates&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; selectedState
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;trySubscribe&lt;/code&gt;를 통해 store의 state 변경을 감지하고 변경 될 경우 &lt;code class=&quot;language-text&quot;&gt;checkForUpdates&lt;/code&gt;를 실행하기 위해 &lt;code class=&quot;language-text&quot;&gt;onStateChange&lt;/code&gt;에 할당합니다.&lt;/p&gt;
&lt;p&gt;다시 정리하자면 redux는 store의 state가 변경되면 모든 subscriber를 실행합니다. 컴포넌트에서 useSelector를 실행하면 store를 subscribe하게 됩니다. useSelector를 통해 등록한 checkForUpdates에서 selector가 반환한 값과 memoized 된 값을 비교하여 변경된 경우 해당 컴포넌트를 re-render 시키고 그렇지 않을경우 re-render없이 checkForUpdates 함수만 실행되는 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;“redux state가 변경되면 모든 컴포넌트가 re-render 되는가?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;u&gt;그렇지않다. useSelector를 사용한 컴포넌트 중 selector에서 반환한 값이 변경된 component만 re-render된다&lt;/u&gt; 입니다.&lt;/p&gt;
&lt;p&gt;드디어 다 끝났습니다.&lt;br&gt;
글로 풀어 쓸려니 많아 보이고 복잡해 보이지만 코드만 보면 별거 없습니다.
여러분이 익숙지 않아서일 수도 있고 제가 글솜씨가 드럽게 없어서 그럴지도 모릅니다.
하지만 분명한 건 우리가 쓰는 모든 라이브러리는 모두가 다 아는 Javascript로 구현되어 있고 매직 코드란 없다는 겁니다.&lt;br&gt;
라이브러리를 개발하지는 못하더라도 적어도 우리가 쓰는 라이브러리가 대충 어떻게는 돌아가는지 알고 있어야 덜 기분 나쁘지 않겠습니까?&lt;br&gt;
이만~🖐🏻&lt;/p&gt;</content:encoded></item></channel></rss>