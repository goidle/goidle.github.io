{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react-hooks_1/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"39ab20a2-4d6c-55f4-bffa-0ed3e5ab7ed9","excerpt":"모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 글을 써내려가는 방식은 하나도 몰랐던 상태에서 리액트를 분석한 그 순서 그대로를 따라가면서 설명하도록 하겠습니다. 글의 흐름은 다음과 같습니다. 훅을 통해 컴포넌트 상태를 업데이트한다. VDOM 재조정을 해줄 Work를 scheduler에게 스케줄링 시키고 scheduler가 스케줄링된 Task를 꺼내 실행한다 Work을 통해 VDOM…","html":"<blockquote>\n<p>모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.</p>\n</blockquote>\n<p>글을 써내려가는 방식은 하나도 몰랐던 상태에서 리액트를 분석한 그 순서 그대로를 따라가면서 설명하도록 하겠습니다.<br>\n글의 흐름은 다음과 같습니다.</p>\n<ol>\n<li>훅을 통해 컴포넌트 상태를 업데이트한다.</li>\n<li>VDOM 재조정을 해줄 <em>Work</em>를 <em>scheduler</em>에게 스케줄링 시키고 <em>scheduler</em>가 스케줄링된 <em>Task</em>를 꺼내 실행한다</li>\n<li><em>Work</em>을 통해 VDOM 재조정 작업을 진행한다.</li>\n<li>완성된 VDOM을 <em>commit phase</em>에서 처리하여 DOM에 적용한다.</li>\n<li>사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.</li>\n</ol>\n<p>위 내용이 리액트에서 가장 일반적인 흐름일 것으로 생각됩니다. 위 내용만 제대로 이해하게 된다면 이 이외의 케이스들에 대해서 굳이 설명하지 않아도 혼자서 충분히 알아볼 수 있지 않을까 기대해봅니다.</p>\n<p>이번 포스트에서는 첫 번째인 훅을 통해 컴포넌트 상태를 어떻게 업데이트하는지 알아보도록 하겠습니다.</p>\n<h1 id=\"1-hook의-구현체는-어디에-있을까\"><a href=\"#1-hook%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"1 hook의 구현체는 어디에 있을까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Hook의 구현체는 어디에 있을까?</h1>\n<p>분석을 시작하기 가장 좋은 방법은 분석할 함수를 어디서 어떻게 가져오는지 먼저 확인하는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react > React.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useState<span class=\"token punctuation\">,</span> useEffect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./ReactHooks'</span>\n<span class=\"token keyword\">import</span> ReactSharedInternals <span class=\"token keyword\">from</span> <span class=\"token string\">'./ReactSharedInternals'</span>\n\n<span class=\"token keyword\">const</span> React <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  useState<span class=\"token punctuation\">,</span>\n  useEffect<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 생략..</span>\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED<span class=\"token punctuation\">:</span> ReactSharedInternals<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> React</code></pre></div>\n<p>개발자가 코어를 통해 가져오는 훅은 <em>ReactHooks</em> 모듈에서 가져오고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react > ReactHooks.js</span>\n<span class=\"token keyword\">import</span> ReactCurrentDispatcher <span class=\"token keyword\">from</span> <span class=\"token string\">'./ReactCurrentDispatcher'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dispatcher <span class=\"token operator\">=</span> <span class=\"token function\">resolveDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> dispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">create<span class=\"token punctuation\">,</span> inputs</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dispatcher <span class=\"token operator\">=</span> <span class=\"token function\">resolveDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> dispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>create<span class=\"token punctuation\">,</span> inputs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">resolveDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> dispatcher <span class=\"token operator\">=</span> ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current\n  <span class=\"token keyword\">return</span> dispatcher\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">ReactCurrentDispatcher</code>란 모듈에서 <code class=\"language-text\">dispatcher</code>를 가지고 오네요. 훅의 구현체는 <code class=\"language-text\">dispatcher</code>가 가지고 있나 봅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber 0\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// react > ReactCurrentDispatcher.js</span>\n<span class=\"token keyword\">const</span> ReactCurrentDispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  current<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> ReactCurrentDispatcher</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아무것도 없습니다.. 그냥 객체 하나가 끝입니다.</p>\n<p>preview에서 패키지를 설명할 때 코어는 <strong>“개발자에게 다른 패키지의 모듈을 제공할 수 있도록 중간 다리 역할을 하는 모듈들만 위치해 있습니다.”</strong> 라고 말했었습니다.</p>\n<p>훅에 대해서 좀만 더 생각해보자면 훅은 컴포넌트의 상태를 업데이트하는데 코어에서는 컴포넌트의 겉 정보인 <em>reactElement</em>만을 관리합니다.<br>\n그렇다는 이야기는 이 상태는 VDOM의 fiber에 저장된다는 것이고 이 fiber를 업데이트할 수 있는 역할은 fiber를 만들어내는 <em>reconciler</em>에게 있다는 말입니다. 그러므로 hook의 구현체 또한 <em>reconciler</em>에 위치해 있습니다.</p>\n<p>이렇게 보면 코어가 다른 패키지의 기능을 개발자에게 제공해 줄 때 의존성을 자기가 만들지 않고 외부에서 주입 받는다는 걸 알 수 있습니다. 스프링의 DI(Dependency Injection)와 같습니다.<br>\n리액트는 외부에서 의존성을 주입할 때 코어에 바로 주입하지 않습니다. 중간자를 하나 더 두게 되는데 그게 Shared라는 패키지입니다.<br>\n이 Shared는 모든 패키지들이 공유하는 정보들을 가지고 있습니다. intro에서 본 side effect tag들도 여기에 위치해 있습니다.</p>\n<p>Shared에서 코어에 의존성을 주입해주기 위해 react를 알고 있는 모듈은 ReactSharedInternal.js입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// shared > ReactSharedInternals.js</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n\n<span class=\"token keyword\">const</span> ReactSharedInternals <span class=\"token operator\">=</span>\n  React<span class=\"token punctuation\">.</span>__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ReactSharedInternals<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ReactCurrentDispatcher'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  ReactSharedInternals<span class=\"token punctuation\">.</span>ReactCurrentDispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    current<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 생략..</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> ReactSharedInternals</code></pre></div>\n<p>맨 처음 React 선언 코드에서 본 <code class=\"language-text\">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</code>를 여기에서 사용하고 있습니다. 여기에는 코어의 <em>ReactSharedInternals</em> 이 할당되어 있었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react > ReactSharedInternals.js</span>\n<span class=\"token keyword\">import</span> ReactCurrentDispatcher <span class=\"token keyword\">from</span> <span class=\"token string\">'./ReactCurrentDispatcher'</span>\n\n<span class=\"token keyword\">const</span> ReactSharedInternals <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  ReactCurrentDispatcher<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> ReactSharedInternals</code></pre></div>\n<p>훅이 개발자에게 도달되는 흐름은 다음과 같습니다.\nreconciler -> shared/ReactSharedInternal -> react/ReactSharedInternal -> react/ReactCurrentDispatcher -> react/ReactHooks -> react -> 개발자의 형태가 됩니다. 다시 코드를 한 번 쭉 훑어 보시면서 흐름을 느껴 보시길 바랍니다.</p>\n<p>이제 우리는 훅이 어디에 있는지 shared/ReactSharedInternal.js를 import하고 <code class=\"language-text\">ReactCurrentDispatcher</code>를 사용하고 있는 곳을 찾아가면 확인할 수 있을 것입니다.<br>\n훅은 reconciler/ReactFiberHooks.js에 위치해 있습니다.</p>\n<h1 id=\"2-hook은-내부에서-어떻게-사용되는가\"><a href=\"#2-hook%EC%9D%80-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EA%B0%80\" aria-label=\"2 hook은 내부에서 어떻게 사용되는가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Hook은 내부에서 어떻게 사용되는가?</h1>\n<blockquote>\n<p>본격적으로 들어가기에 실제 코드를 보면 __DEV__로 감싸진 코드들을 많이 보실 텐데 개발 모드에서만 사용됨을 뜻하기 때문에 산뜻하게 무시해주시면 됩니다.</p>\n</blockquote>\n<p>훅을 <code class=\"language-text\">ReactCurrentDispatcher.current</code>에 할당해주는 함수는 <code class=\"language-text\">renderWithHooks()</code>입니다. 함수 이름에서 느껴지시나요? 컴포넌트 실행을 여기서 합니다. 주목적은 훅 할당이 아니라 함수 실행이고 훅 할당은 부수적으로 따라오는 부분이 됩니다.<br>\n이 함수는 재조정 작업을 할 때 사용되는데 그때 가서 자세히 다루고 지금은 훅과 관련된 코드들만 뜯어와서 보도록 하겠습니다.<br>\n<strong>코드에서 제가 설명하지 않고 넘어가는 코드는 크게 신경 쓰지 않으셔도 됩니다. 복잡하니 그때는 생략되고 사용되는 뒷부분에서 다뤄진다고 생각하시면 됩니다.</strong></p>\n<blockquote>\n<p>분석하기에 type이 있으면 좋을 부분들은 type를 제거하지 않고 그대로 사용하도록 하겠습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber 0\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > renderWithHooks()</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">renderWithHooks</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">current<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  Component<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  refOrContext<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  nextRenderExpirationTime<span class=\"token punctuation\">:</span> ExpirationTime</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  currentlyRenderingFiber <span class=\"token operator\">=</span> workInProgress <span class=\"token comment\">// 현재 작업 중인 fiber를 전역으로 잡아둠</span>\n  nextCurrentHook <span class=\"token operator\">=</span> current <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> current<span class=\"token punctuation\">.</span>memoizedState <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n\n  ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span>\n    nextCurrentHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> HooksDispatcherOnMount <span class=\"token punctuation\">:</span> HooksDispatcherOnUpdate\n\n  <span class=\"token keyword\">let</span> children <span class=\"token operator\">=</span> <span class=\"token function\">Component</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> refOrContext<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> renderedWork <span class=\"token operator\">=</span> currentlyRenderingFiber\n  renderedWork<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> firstWorkInProgressHook\n\n  ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> ContextOnlyDispatcher\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>19</strong>, <strong>22</strong> 라인을 먼저 확인하겠습니다.<br>\n<code class=\"language-text\">Component</code>는 fiber의 type에서 꺼낸 온 것인데 여기에는 개발자가 작성한 컴포넌트 함수가 저장되어 있습니다.\n<strong>19</strong> 라인을 통해 훅을 사용하고 있는 컴포넌트를 실행하면 전역변수 <code class=\"language-text\">firstWorkInProgressHook</code>에 hook 객체가 저장됩니다.\n이 변수를 fiber의 <code class=\"language-text\">memoizedState</code>에 저장해 놓음으로서 훅을 컴포넌트와 매핑시켜 줍니다.</p>\n<p>이제 <strong>12</strong>번 라인을 이해할 수 있습니다. <code class=\"language-text\">memoizedState</code>가 null이 아니라면 이전 컴포넌트 렌더에서 훅이 사용되었다는 뜻이 됩니다.<br>\n그리고 <strong>15</strong> 라인에서 <code class=\"language-text\">nextCurrentHook</code>을 이용하여 훅이 mount인지 update인지 판단을 하게 됩니다. 그리고 거기에 맞게 훅 구현체를 다르게 사용합니다.<br>\n즉 컴포넌트가 mount 될 때 훅은 mount 용 구현체를 사용할 것이고 그 이후에는 컴포넌트가 unmount되지 않는 한 계속 update 용 구현체를 사용하게 됩니다.</p>\n<p>마지막으로 <strong>24</strong>번 라인에서 한 번 더 다른 훅 구현체 <code class=\"language-text\">ContextOnlyDispatcher</code>를 사용합니다. 이는 컴포넌트 실행이 모두 끝난 다음 혹시나 훅을 호출하는 상황이 발생할 때\n에러를 던져 개발자가 올바르게 훅을 사용할 수 있도록 해주는 장치입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js</span>\n\n<span class=\"token comment\">// mount</span>\n<span class=\"token keyword\">const</span> HooksDispatcherOnMount <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  useState<span class=\"token punctuation\">:</span> mountState<span class=\"token punctuation\">,</span>\n  useEffect<span class=\"token punctuation\">:</span> mountEffect<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// update</span>\n<span class=\"token keyword\">const</span> HooksDispatcherOnUpdate<span class=\"token punctuation\">:</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  useState<span class=\"token punctuation\">:</span> updateState<span class=\"token punctuation\">,</span>\n  useEffect<span class=\"token punctuation\">:</span> updateEffect<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// invalid hook call</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ContextOnlyDispatcher<span class=\"token punctuation\">:</span> Dispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  useState<span class=\"token punctuation\">:</span> throwInvalidHookError<span class=\"token punctuation\">,</span>\n  useEffect<span class=\"token punctuation\">:</span> throwInvalidHookError<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h1 id=\"3-hook은-어떻게-구현되어-있을까\"><a href=\"#3-hook%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"3 hook은 어떻게 구현되어 있을까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Hook은 어떻게 구현되어 있을까?</h1>\n<p>이번 포스트의 분석 대상인 훅은 <code class=\"language-text\">useState</code> 입니다.</p>\n<blockquote>\n<p>분석하실 때 함수 내부에서 선언된 지역변수인지 모듈 최상단에서 선언된 전역변수인지 잘 확인하시길 바랍니다.</p>\n</blockquote>\n<h2 id=\"mount-state\"><a href=\"#mount-state\" aria-label=\"mount state permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mount state</h2>\n<h3 id=\"1-훅-객체-만들기\"><a href=\"#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"1 훅 객체 만들기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 훅 객체 만들기</h3>\n<p>mount이기 때문에 먼저 훅 객체를 만들어 줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber 0\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > mountState()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 훅 객체를 생성한다.</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>ReactFiberHooks 모듈의 컨텍스트는 현재 작업 중인 컴포넌트 전용으로 사용됩니다. 이 말이 무슨 뜻이냐면 해당 모듈에서 선언되는\n모든 것들은 현재 컴포넌트에만 국한되는 상태값으로 관리된다는 뜻입니다. 컴포넌트의 작업이 끝나게 되면 모두 초기화시켜\n다음 컴포넌트에서 사용할 수 있도록 준비시켜 놓습니다.</p>\n<p><code class=\"language-text\">mountWorkInProgressHook</code>에서 <code class=\"language-text\">hook</code>객체를 만들고 컴포넌트에서 맨 처음으로 호출된 훅일 경우에\n전역 변수인 <code class=\"language-text\">firstWorkInProgressHook</code>와 <code class=\"language-text\">workInProgressHook</code>에 저장해 놓습니다.<br>\n이제 변수명에서 first만 보면 바로 연결 리스트로 생각 하셔도됩니다. 리액트는 많은 곳에서 built-in collection 대신 연결 리스트를 이용하여 구현했습니다.</p>\n<blockquote>\n<p>built-in collection이 아닌 연결리스트로 구현된 이유는 순회할 때 제어하기가 매우 쉽기 때문입니다.<br>\n순회 조건이나 중지, 노드의 삭제 등 제어가 간편합니다.<br>\n또 다른 이점 하나는 연결 리스트끼리 이어 붙이는데 많은 리소스가 들지 않는다는 겁니다. 단지 tail 포인터만 연결할 리스트의 head를 가리키기만 하면 됩니다.<br>\n더불어 리액트에서는 랜덤 엑세스가 필요한 부분이 없으므로 더욱이 연결리스트를 쓰지 않을 이유가 없어 많은 곳에서 사용되고 있습니다.</p>\n</blockquote>\n<p><code class=\"language-text\">firstWorkInProgressHook</code>은 <em>renderWithHooks()</em>에서 이미 봤듯이 컴포넌트 실행이 끝났을 때 <code class=\"language-text\">renderedWork.memoizedState = firstWorkInProgressHook;</code>으로 fiber에 저장하는데 사용되고\n<code class=\"language-text\">workInProgressHook</code>은 연결 리스트에서 현재 처리되고 있는 hook에 대한 포인터로 사용됩니다.<br>\n여러 블로그에서 훅 구현체를 설명할 때 index와 배열을 이용하여 설명하지만 우리는 이제 실제 코드를 통해 연결 리스트로 되어 있다는 걸 알 수 있습니다.\n그리고 왜 훅의 순서가 항상 같아야 하는지도 알 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber 0\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > mountWorkInProgressHook()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Hook <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// hook 객체에 대해서는 update에서 더욱 자세히 다루게 됩니다.</span>\n  <span class=\"token keyword\">const</span> hook<span class=\"token punctuation\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    memoizedState<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 마지막 상태값</span>\n    queue<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 훅이 여러 번 실행될 때 update들을 queue에 연결리스트로 저장한다.</span>\n    next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 다음 연결 리스트 노드 포인터</span>\n\n    <span class=\"token comment\">// 이하 update에서 설명</span>\n    baseState<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    baseUpdate<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 맨 처음 실행되는 훅인 경우 연결 리스트의 head로 잡아둠</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    firstWorkInProgressHook <span class=\"token operator\">=</span> workInProgressHook <span class=\"token operator\">=</span> hook\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 두번 째부터는 연결 리스트에 추가</span>\n    workInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> hook\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> workInProgressHook\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>혹시나 혼동될까 봐 한 번 더 설명하자면 하나의 컴포넌트에서 여러 훅이 실행될 때는 훅 자체의 next 속성으로 연결 리스트로 저장되고 그 중 하나의 훅이 여러 번\n호출될 때는 호출되는 훅 객체의 queue에 그 훅이 만들어놓는 <em>update</em> 정보들이 연결 리스트로 저장됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token constant\">FC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> setA<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// aHook</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">,</span> setB<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// bHook</span>\n  <span class=\"token function\">setA</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_a</span> <span class=\"token operator\">=></span> _a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setA</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_a</span> <span class=\"token operator\">=></span> _a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setA</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_a</span> <span class=\"token operator\">=></span> _a <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// hook linked list</span>\n  <span class=\"token comment\">// fiber.memoizedState => aHook.next => bHook.next => null</span>\n\n  <span class=\"token comment\">//  update in queue of aHook</span>\n  <span class=\"token comment\">// fiber.memoizedState => aHook.queue.last => firstUpdate.next</span>\n  <span class=\"token comment\">// => secondUpdate.next => thirdUpdate.next => firstUpdate</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>queue는 왜 <em>Circular Linked List</em>인지는 <code class=\"language-text\">update state에서</code> 설명합니다.</p>\n<p>계속해서 <em>mountState</em>로 다시 돌아와서 훅을 mount 할 때 넘겨받은 <em>initialState</em>가 함수이면 바로 실행해서 결괏값을 얻어옵니다. 이 이후 이 함수가 실행되는 일은 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > mountState()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const hook = mountWorkInProgressHook();</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> initialState <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 생성자 함수일 경우</span>\n    initialState <span class=\"token operator\">=</span> <span class=\"token function\">initialState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> initialState\n  <span class=\"token comment\">//생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"2-update를-담을-queue-생성\"><a href=\"#2-update%EB%A5%BC-%EB%8B%B4%EC%9D%84-queue-%EC%83%9D%EC%84%B1\" aria-label=\"2 update를 담을 queue 생성 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. update를 담을 queue 생성</h3>\n<p>이제 useState의 상태를 업데이트 하는 함수(<down>이하 <em>setState</em></down>)를 호출할 때 넘겨주는 인자(<down>이하 <em>Action</em></down>)를 저장해놓을 <code class=\"language-text\">queue</code>를 만듭니다.\n한 번의 컴포넌트 실행에서 여러 번의 <em>setState</em>가 호출되면 이 <code class=\"language-text\">queue</code>에 다가 쌓아 놓습니다.\n그리고 컴포넌트가 리-렌더링 될 때 queue에 저장되어 있던 <em>Action</em>들을 차례대로 꺼내서 실행해 맨 마지막 결괏값을 state로 반환해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > mountState()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// hook.memoizedState = hook.baseState = initialState;</span>\n\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">.</span>queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    last<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 마지막 update</span>\n    dispatch<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// queue에 push 해주는 함수</span>\n\n    lastRenderedReducer<span class=\"token punctuation\">:</span> basicStateReducer<span class=\"token punctuation\">,</span> <span class=\"token comment\">// return typeof action === 'function' ? action(state) : action;</span>\n    lastRenderedState<span class=\"token punctuation\">:</span> initialState<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>dispatch <span class=\"token operator\">=</span> <span class=\"token function\">dispatchAction</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    currentlyRenderingFiber<span class=\"token punctuation\">,</span>\n    queue\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>dispatch 함수 할당을 자세히 보면 bind를 통해서 인자를 잡아둔 상태로 외부에 노출시키고 있습니다.\n우리가 사용하고 있는 <code class=\"language-text\">const [a, setA] = useState(0);</code>가 바로 위 반환하는 배열입니다.</p>\n<p>마지막으로 <code class=\"language-text\">queue</code>에 push 해줄 <code class=\"language-text\">dispatchAction()</code>를 알아보겠습니다.</p>\n<h3 id=\"3-code-classlanguage-textdispatchactioncode\"><a href=\"#3-code-classlanguage-textdispatchactioncode\" aria-label=\"3 code classlanguage textdispatchactioncode permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. <code class=\"language-text\">dispatchAction</code></h3>\n<p>이 함수는 <code class=\"language-text\">queue</code>에 <em>update</em>를 push 함과 동시에 <em>scheduler</em>에게 <em>Work</em>를 스케줄링 시켜주는 함수입니다.<br>\n<code class=\"language-text\">const [a, setA] = useState(0);</code>에서 <code class=\"language-text\">setA</code>가 <code class=\"language-text\">dispatchAction()</code>입니다.</p>\n<p>reconciler 코드를 보면 항상 <em>render phase</em>가 진행 중일 때 발생한 것인지 아니면 idle 상태에서 발생한 것인지에 따라 로직이 나뉩니다.<br>\n두 케이스 모두 처리해야 할 방법이 다르고 최적화 방식도 조금씩 다르므로 기능이 궁금해서 함수를 까보면 이 이유 때문에 코드의 길이가 상당히 긴 경우가 많습니다.<br>\n그래서 현재 분석하고 있는 코드가 어떤 상황에서 사용되는지 확실히 알고 가야 이해하기가 편합니다.</p>\n<blockquote>\n<p>render phase update란?<br>\n컴포넌트가 렌더링 되고 있는 상황에서 추가적으로 업데이트가 발생할 경우를 말합니다.<br>\n다음 코드에서 버튼을 클릭했을 때 컴포넌트는 a가 1인 상태로 실행되는데 <code class=\"language-text\">setA(2)</code> 때문에 추가적인 업데이트가 발생한 경우입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token constant\">FC</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> setA<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token function\">setA</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setA</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber 0\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">dispatchAction</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">fiber<span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span>\n  queue<span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span>\n  action<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">const</span> alternate <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    fiber <span class=\"token operator\">===</span> currentlyRenderingFiber <span class=\"token operator\">||</span>\n    <span class=\"token punctuation\">(</span>alternate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> alternate <span class=\"token operator\">===</span> currentlyRenderingFiber<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// render phase update</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// update in idle</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><em>renderWithHooks()</em>를 통해 컴포넌트가 실행되는 상황은 VDOM 재조정 작업 중 일때 발생합니다. 이는 업데이트가 발생하면 진행되는 작업으로 <code class=\"language-text\">currentlyRenderingFiber</code>가\n비어있지 않다는 건 <em>renderWithHooks()</em>가 호출되었다는 뜻입니다. 즉 <em>render phase</em>가 진행 중인 상황입니다.</p>\n<p>이때 <em>10</em>번 라인 <code class=\"language-text\">dispatchAction()</code>이 bind로 잡아 두었던 fiber와 현재 작업 중인 <code class=\"language-text\">currentlyRenderingFiber</code> 가 같다는 건 현재 컴포넌트는 <em>render phase</em>에서 작업중인 컴포넌트이며 동시에\n업데이트가 발생한 상황임을 나타내는 조건입니다.</p>\n<p>한가지 더 <code class=\"language-text\">alternate</code>도 비교를 하는데(<em>11번 라인</em>) VDOM 트리는 두 개가 있습니다. <em>current</em>, <em>workInProgress</em>.<br>\n하지만 우리는 <u><em>훅이 mount 될 때 작업 중이었던 fiber</em></u>를 bind로 고정시켜 놨습니다.<br>\n거기에 <em>current</em>와 <em>workInProgress</em>는 고정이 아닌 <em>commit</em>이 되면 서로 교체가 되기 때문에 현재 작업 중인 <code class=\"language-text\">currentlyRenderingFiber</code>가 두 개의 트리 중 어느 트리인지 알 수가 없습니다.<br>\n그래서 <code class=\"language-text\">fiber</code>와 <code class=\"language-text\">alternate</code>를 모두 비교를 해야 현재 컴포넌트가 작업 중인지 확인할 수 있습니다.</p>\n<p><em>render phase update</em> 로직은 <em>idle update</em>를 먼저 보고 난 후에 확인해 보도록 하겠습니다.</p>\n<h3 id=\"4-code-classlanguage-textexpirationtimecode\"><a href=\"#4-code-classlanguage-textexpirationtimecode\" aria-label=\"4 code classlanguage textexpirationtimecode permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. <code class=\"language-text\">expirationTime</code></h3>\n<p><em>idle update</em>를 들어가기에 앞서 먼저 <code class=\"language-text\">expirationTime</code> 부터 알고 가야 합니다.<br>\n<code class=\"language-text\">expirationTime</code>에 대해서는 깊이 들어가지는 않지만 리액트 시스템에 전반적으로 사용되므로 아주 기본만 알고 넘어가겠습니다.\n가장 큰 <code class=\"language-text\">expirationTime</code>은 32-bit 시스템인 v8에서 가장 큰 정수인 부호 있는 31bit 값입니다. 이 값을 <code class=\"language-text\">Sync</code>로 다룹니다.\n그리고 <code class=\"language-text\">legacy mode</code>에서는 모든 게 <code class=\"language-text\">Sync</code>로 처리된다고 생각하시면 됩니다.<br>\n여기서 나오는 나머지 부분들은 <code class=\"language-text\">concurrent mode</code>에서 사용됩니다.<br>\n그리고 이름이 <code class=\"language-text\">expirationTime</code>이라서 그렇지 작업의 유효 시간을 나타내는 것으로 쓰이지는 않습니다..</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberExpirationTime.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> NoWork <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Never <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Idle <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Sync <span class=\"token operator\">=</span> <span class=\"token constant\">MAX_SIGNED_31_BIT_INT</span> <span class=\"token comment\">// 1073741823</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Batched <span class=\"token operator\">=</span> Sync <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">MAGIC_NUMBER_OFFSET</span> <span class=\"token operator\">=</span> Batched <span class=\"token operator\">-</span> <span class=\"token number\">1</span></code></pre></div>\n<p>현재 시간을 가지고 올 때 시간의 형식은 <code class=\"language-text\">Date.now()</code>가 아닌 <code class=\"language-text\">performance.now()</code> 입니다.<br>\n<code class=\"language-text\">expirationTime</code>을 구하는 계산식은 <code class=\"language-text\">MAX_SIGNED_31_BIT_INT - now()</code> 입니다.<br>\n<code class=\"language-text\">now</code>가 오른쪽 피 연산자에 있다는 건 나중에 발생한 작업일수록 더 작은 <code class=\"language-text\">expirationTime</code>을 가지게 된다는 뜻입니다.\n하지만 <code class=\"language-text\">performance.now()</code>로 현재 시간을 표현하기 때문에 그럴 일은 없겠지만 이론상으로는 발생 시간이 0이 나올 수도 있습니다.<br>\n그렇게 되면 <code class=\"language-text\">Sync</code>나 <code class=\"language-text\">Batched</code>와 시간이 겹칠 수 있어서 기존 상수들과 겹치지 않기 위해 offset 값이 필요한데 그게 바로 <code class=\"language-text\">MAGIC_NUMBER_OFFSET</code>입니다.\n위 이유 때문에 계산식을 다시 작성하자면 <code class=\"language-text\">MAGIC_NUMBER_OFFSET - now()</code>가 됩니다.<br>\n그리고 반대로 <code class=\"language-text\">expirationTime</code>에서 발생시간을 구하는 계산식은 <code class=\"language-text\">offset - expirationTime</code> <code class=\"language-text\">expirationTime</code> 입니다.<br>\n<code class=\"language-text\">expirationTime</code>와는 반대로 큰 숫자가 더 나중에 발생한 작업을 나타냅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberExpirationTime.js</span>\n<span class=\"token comment\">// 생략..</span>\n<span class=\"token comment\">///export const Batched = Sync - 1;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">UNIT_SIZE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n\n<span class=\"token comment\">// 1 unit of expiration time represents 10ms.</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">msToExpirationTime</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ms<span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> ExpirationTime <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token constant\">MAGIC_NUMBER_OFFSET</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ms <span class=\"token operator\">/</span> <span class=\"token constant\">UNIT_SIZE</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">expirationTimeToMs</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">expirationTime<span class=\"token punctuation\">:</span> ExpirationTime</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">MAGIC_NUMBER_OFFSET</span> <span class=\"token operator\">-</span> expirationTime<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token constant\">UNIT_SIZE</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다시 간략하게 정리하자면 fiber의 <code class=\"language-text\">expirationTime</code>이 <code class=\"language-text\">NoWork</code>이면 작업 중인게 없다는 뜻이고 <code class=\"language-text\">Sync</code>는 동기적으로 작업이 처리될 것이며 <code class=\"language-text\">expirationTime</code>을 대소로 비교하는 조건문이 있을 때는\n큰 숫자가 더 옛날에 먼저 발생한 작업이다. 라고만 생각하고 넘어가시면 분석할 때 큰 무리 없이 이해할 수 있을 것입니다.<br>\n시간과 관련된 부분은 <code class=\"language-text\">concurrent mode</code>가 일반적으로 사용이 되면 그때 깊이 있게 알아보도록 하겠습니다.</p>\n<p>다시 훅의 업데이트를 dispatch 해주는 <code class=\"language-text\">dispatchAction</code>로 돌아오겠습니다. <code class=\"language-text\">expirationTime</code>을 간략하게 알아보았기 때문에 현재 시간으로 fiber의 <code class=\"language-text\">expirationTime</code>을 구하는 부분은 생략하도록 하겠습니다.\n업데이트에 대한 시간을 구한 후 이제 해야할 일은 업데이트 정보를 담을 <em>update</em>객체를 만드는 것입니다.<br>\n그리고 이 <em>Update</em>를 <code class=\"language-text\">queue</code>에 push 해야 합니다.</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">dispatchAction</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">fiber<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  queue<span class=\"token punctuation\">:</span> updateQueue<span class=\"token punctuation\">,</span>\n  action<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// if (render phase update) {</span>\n    <span class=\"token comment\">// 생략..</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> expirationTime <span class=\"token operator\">=</span> <span class=\"token comment\">// 만료 시간을 구한다.</span>\n\n    <span class=\"token comment\">// update 생성</span>\n    <span class=\"token keyword\">const</span> update<span class=\"token punctuation\">:</span> Update <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      expirationTime<span class=\"token punctuation\">,</span>\n      action<span class=\"token punctuation\">,</span> <span class=\"token comment\">// setState의 인자값</span>\n      next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 연결 리스트</span>\n      <span class=\"token comment\">// 이하 바로 밑에서 추가적으로 다룰 것이기 때문에 생략</span>\n      eagerReducer<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      eagerState<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// update를 queue에 연결리스트로 추가</span>\n    <span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>last<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// This is the first update. Create a circular list.</span>\n<span class=\"gatsby-highlight-code-line\">      update<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> last<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token comment\">// Still circular.</span></span><span class=\"gatsby-highlight-code-line\">        update<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">}</span></span>      last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    queue<span class=\"token punctuation\">.</span>last <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 생략..</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>Update</em>를 큐에 추가할 때 연결 리스트로 추가합니다. 로직을 보면 <em>Circular Linked List</em>로 만들어 주는데<up>하이라이트 부분</up> <code class=\"language-text\">queue</code>를 생성할 때 말씀드린 것 처럼 <em>update state</em>의 로직을 봐야 이해할 수 있기 때문에 여기서는 생략합니다.<br>\n그리고 만들어진 <em>update</em>를 <code class=\"language-text\">queue</code>의 tail pointer(<code class=\"language-text\">last</code>)에 추가해줍니다.</p>\n<h3 id=\"5-불필요한-컴포넌트-리-렌더링-방지\"><a href=\"#5-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A6%AC-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%A7%80\" aria-label=\"5 불필요한 컴포넌트 리 렌더링 방지 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 불필요한 컴포넌트 리-렌더링 방지</h3>\n<p>리액트는 이 시점에(<down><em>idle</em> 상태에서 업데이트가 발생한 상태</down>) 성능 최적화를 위한 한가지 선택지가 있습니다.<br>\n이전 <code class=\"language-text\">dispatchAction()</code>를 통해 컴포넌트<up>fiber</up>에 대한 <em>Work</em>가 스케줄링 되어있지 않고 넘겨받은 <em>action</em>의 결괏값이 현재 state와 같다면? 이때는 state가 변경된게 없으므로 더 이상 진행하지 않고 <strong>bail out</strong>할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token comment\">// function dispatchAction(</span>\n<span class=\"token comment\">//   fiber:,</span>\n<span class=\"token comment\">//   queue:,</span>\n<span class=\"token comment\">//   action,</span>\n<span class=\"token comment\">// ) {</span>\n<span class=\"token comment\">// 생략..</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    fiber<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">===</span> NoWork <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token punctuation\">(</span>alternate <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> alternate<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">===</span> NoWork<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> lastRenderedReducer <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>lastRenderedReducer<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lastRenderedReducer <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 생략..</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>우리는 이제 if 문의 조건을 이해할 수 있습니다. 왜 fiber와 alternate 모두 비교를 하는지에 대한.</p>\n<blockquote>\n<p><em>fiber</em>에 대한 <em>Work</em>가 스케줄링이 되면 <em>fiber</em>에 <code class=\"language-text\">expirationTime</code>에 새겨집니다.\n그리고 <code class=\"language-text\">queue</code>를 만들 때 <code class=\"language-text\">lastRenderedReducer</code>에 <code class=\"language-text\">basicStateReducer</code>를 할당했었습니다.<br>\n<code class=\"language-text\">basicStateReducer</code>의 로직은 간단합니다. <code class=\"language-text\">return typeof action === &#39;function&#39; ? action(state) : action;</code><br>\n로직과 이름을 보고 다음과 같은 생각을 하신 분이 계실지는 모르겠지만, 이 <em>reducer</em>는 <code class=\"language-text\">useReduer</code>를 사용할 때 넘겨주는 <em>reducer</em> 함수가 할당되는 곳이며 <em>update state</em>에서 <code class=\"language-text\">useState</code>는 <code class=\"language-text\">useReducer</code>와 같은 구현체를 공유합니다. 그러므로 <code class=\"language-text\">useState</code> 하나를 분석하면 <code class=\"language-text\">useReducer</code>도 함께 알 수 있습니다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n  <span class=\"token comment\">// 생략..</span>\n  <span class=\"token comment\">// if (lastRenderedReducer !== null) {</span>\n      <span class=\"token keyword\">const</span> currentState <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>lastRenderedState<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> eagerState <span class=\"token operator\">=</span> <span class=\"token function\">lastRenderedReducer</span><span class=\"token punctuation\">(</span>currentState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      update<span class=\"token punctuation\">.</span>eagerReducer <span class=\"token operator\">=</span> lastRenderedReducer<span class=\"token punctuation\">;</span>\n      update<span class=\"token punctuation\">.</span>eagerState <span class=\"token operator\">=</span> eagerState<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">is</span><span class=\"token punctuation\">(</span>eagerState<span class=\"token punctuation\">,</span> currentState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">scheduleWork</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">,</span> expirationTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// }</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>현재 state와 같지 않다면 VDOM을 재조정해줄 <em>Work</em>를 스케줄링 합니다. 여러 번의 <em>setState</em> 가 있어도 한 번만 스케줄링 되기 때문에 걱정은 안 하셔도 됩니다. <code class=\"language-text\">scheduleWork()</code>와 <code class=\"language-text\">scheduler</code>에 대한 자세한 내용은 다음 포스트에서 다룹니다.</p>\n<p>이제 생략했던 <em>render phase update</em>를 확인하도록 하겠습니다.</p>\n<h3 id=\"6-컴포넌트-리-렌더링\"><a href=\"#6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A6%AC-%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"6 컴포넌트 리 렌더링 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 컴포넌트 리-렌더링</h3>\n<p><code class=\"language-text\">setState()</code><up><code class=\"language-text\">dispatchAction</code></up>의 주요 일 중 하나는 <code class=\"language-text\">scheduleWork()</code>를 통해 <em>render phase</em>에 진입해서 업데이트를 VDOM에 적용시키는 겁니다. 그리고 <em>render phase update</em>의 경우는 이미 VDOM 재조정 작업 중인 상황입니다. 그렇기 때문에 우리는 현재 오로지 업데이트를 적용한 자식 <em>reactElement</em>만 필요합니다. 다른 건 필요가 없습니다. 그래서 업데이트를 적용한 컴포넌트를 실행해서 자식을 받아오는데 이 과정에서 추가적인 <code class=\"language-text\">setState</code> 가 발생하면 이때 발생하는 <code class=\"language-text\">setState()</code>들을 몽땅 모았다가 바로 다시 컴포넌트를 실행해서 해당 업데이트들을 기반으로 자식 <em>reactElement</em>를 다시 반환받습니다. 이 과정을 업데이트가 발생하지 않을 때까지 반복합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token keyword\">function</span> dispatchAction<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n  fiber<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  queue<span class=\"token punctuation\">:</span> UpdateQueue<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  action<span class=\"token punctuation\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// if (</span>\n<span class=\"token comment\">//   fiber === currentlyRenderingFiber ||</span>\n<span class=\"token comment\">//   (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber)</span>\n<span class=\"token comment\">// ) {</span>\n  didScheduleRenderPhaseUpdate <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴포넌트를 실행하는 renderWithHooks에게 재실행을 알려줄 플래그</span>\n  <span class=\"token keyword\">const</span> update<span class=\"token punctuation\">:</span> Update<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    expirationTime<span class=\"token punctuation\">:</span> renderExpirationTime<span class=\"token punctuation\">,</span>\n    suspenseConfig<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    action<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 업데이트 결과를 담고 있는 action만 필요합니다.</span>\n    eagerReducer<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    eagerState<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>renderPhaseUpdates <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    renderPhaseUpdates <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 업데이트를 저장할 맵</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> firstRenderPhaseUpdate <span class=\"token operator\">=</span> renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstRenderPhaseUpdate <span class=\"token operator\">===</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Append the update to the end of the list.</span>\n    <span class=\"token keyword\">let</span> lastRenderPhaseUpdate <span class=\"token operator\">=</span> firstRenderPhaseUpdate<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>lastRenderPhaseUpdate<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      lastRenderPhaseUpdate <span class=\"token operator\">=</span> lastRenderPhaseUpdate<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    lastRenderPhaseUpdate<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// else {</span>\n<span class=\"token comment\">//   생략..</span>\n<span class=\"token comment\">//   scheduleWork(fiber, expirationTime);</span>\n<span class=\"token comment\">// }</span></code></pre></div>\n<p><code class=\"language-text\">renderWithHooks()</code>에서 <code class=\"language-text\">didScheduleRenderPhaseUpdate</code>를 사용하는 코드는 바로 밑에서 확인하도록 하겠습니다.\n훅 객체들은 고유의 <code class=\"language-text\">queue</code>를 가집니다. 그래서 <code class=\"language-text\">queue</code>를 키로 <em>render phase update</em>들을 연결리스트로 저장해 놓습니다. 그리고 이 리스트는 컴포넌트 재실행 때 <em>update state</em>에서 소비합니다.</p>\n<p>이제 <code class=\"language-text\">didScheduleRenderPhaseUpdate</code>를 사용하는 곳만 보고 <em>mount state</em>를 마무리하도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > renderWithHooks()</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">renderWithHooks</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">current<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  Component<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  refOrContext<span class=\"token punctuation\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  nextRenderExpirationTime<span class=\"token punctuation\">:</span> ExpirationTime</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  <span class=\"token comment\">// let children = Component(props, refOrContext)</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>didScheduleRenderPhaseUpdate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n      didScheduleRenderPhaseUpdate <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      numberOfReRenders <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n      <span class=\"token comment\">//이하 updateState에서 사용되는 변수</span>\n      nextCurrentHook <span class=\"token operator\">=</span> current <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> current<span class=\"token punctuation\">.</span>memoizedState <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n      nextWorkInProgressHook <span class=\"token operator\">=</span> firstWorkInProgressHook\n\n      <span class=\"token comment\">// 필요한 전역 변수 초기화</span>\n      currentHook <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n      workInProgressHook <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n\n      ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> HooksDispatcherOnUpdate <span class=\"token comment\">// update state 구현체를 사용</span>\n\n      children <span class=\"token operator\">=</span> <span class=\"token function\">Component</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> refOrContext<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>didScheduleRenderPhaseUpdate<span class=\"token punctuation\">)</span>\n\n    renderPhaseUpdates <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n    numberOfReRenders <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// const renderedWork = currentlyRenderingFiber</span>\n  <span class=\"token comment\">// ReactCurrentDispatcher.current = ContextOnlyDispatcher</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">didScheduleRenderPhaseUpdate</code>가 false 일 때까지 계속 컴포넌트를 재실행 합니다.<br>\n훅을 사용하면서 많이 보셨을 메시지인 <strong><em>“Too many re-renders. React limits the number of renders to prevent an infinite loop.”</em></strong>도 여기서 증가시킨 <code class=\"language-text\">numberOfReRenders</code>을 기준으로 <code class=\"language-text\">dispatchAction()</code>에서 에러를 출력해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token keyword\">function</span> dispatchAction<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n  fiber<span class=\"token punctuation\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  queue<span class=\"token punctuation\">:</span> UpdateQueue<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  action<span class=\"token punctuation\">:</span> <span class=\"token constant\">A</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">invariant</span><span class=\"token punctuation\">(</span>\n    numberOfReRenders <span class=\"token operator\">&lt;</span> <span class=\"token constant\">RE_RENDER_LIMIT</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'Too many re-renders. React limits the number of renders to prevent '</span> <span class=\"token operator\">+</span>\n      <span class=\"token string\">'an infinite loop.'</span>\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">invariant</code>는 첫 번째 인자가 false이면 두 번째 인자의 메세지로 에러를 뿜는 함수입니다.<br>\n여기까지가 <em>mount state</em> 입니다.</p>\n<h3 id=\"7-정리\"><a href=\"#7-%EC%A0%95%EB%A6%AC\" aria-label=\"7 정리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 정리</h3>\n<p>이제 여러분은 다음과 같은 질문에 대답할 수 있어야 합니다.</p>\n<ol>\n<li><code class=\"language-text\">setState</code>를 한번에 여러 번 실행하면 매 실행마다 렌더링 되나요?</li>\n<li>클릭을 통해 컴포넌트 상태를 업데이트시켰습니다. 그리고 변경된 상태를 기준으로 <code class=\"language-text\">setState</code>를 호출했어요. 그러면 클릭을 통한 상태 업데이트 때 한번, 추가적인 <code class=\"language-text\">setState</code> 때 또 한 번. 이렇게 매번 렌더링 되나요?</li>\n</ol>\n<p>이런 질문이 들어오면 일단 가장 먼저 질문자에게 해주어야 할 부분은 렌더링 단어의 의미를 명확하게 인식시키는 겁니다. 이 부분만 제대로 이해해도 개발자의 입장에서만 바라보던 것들을 리액트의 입장에서 바라볼 수 있도록 시야를 트여줍니다.</p>\n<p>이제 하나씩 답변을 해보겠습니다.</p>\n<ol>\n<li>복수개의 훅 실행이 현재 state와 같다면 아무 일도 일어나지 않는다. 그게 아니면 한데 묶어서 다음 프레임 때 한 번만 컴포넌트가 재실행된다. 화면에 그려지는 것 또한 한 번이다.(<down>스케줄링도 한번</down>)</li>\n<li>클릭을 통한 업데이트로 컴포넌트가 재실행 된다. 그리고 그 재실행에서 발생하는 추가적인 <code class=\"language-text\">setState</code>는 1번처럼 묶어서 한 번만 실행한다.<br>\n여기서 업데이트가 발생하지 않을 때까지 계속해서 함수를 재실행한다. 결국, 최소 2번 최대 25번(<down>RE<em>RENDER</em>LIMIT = 25</down>) 컴포넌트가 재 실행될 수 있다. 그리고 화면은 1번과 마찬가지로 한 번만 그려진다.<br>\n이 사이클은 <em>render phase</em>임을 유의해라. <em>commit phase</em>가 아니면 단지 in-memory 객체만 끄적인 것이지 아무 변화도 일어나지 않는다.</li>\n</ol>\n<p>여기까지 이해가 가시나요? 그러면 다행이지만 그렇지 않다면 가장 이해하기 쉬운 방법은 위 내용을 토대로 직접 코드를 작성해서 디버깅을 해보는 것입니다.</p>\n<p>다음은 <code class=\"language-text\">setState</code>를 통해 <code class=\"language-text\">queue</code>에 저장해두었던 <code class=\"language-text\">update</code>들을 훅이 어떻게 컴포넌트에 적용시켜 실행하는지 알아보도록 하겠습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">목록</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"https://goidle.github.io/react/in-depth-react-intro/\">React 톺아보기- 02. Intro</a></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"https://goidle.github.io/react/in-depth-react-hooks_2/\">React 톺아보기- 03. Hooks_2</a></td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"React 톺아보기- 03. Hooks_1","date":"2020-06-12","keywords":["리액트","react","fiber","hook","hooks","useState","useEffect","useLayoutEffect","useCallback"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react/in-depth-react-hooks_1/","previous":{"fields":{"slug":"/react/in-depth-react-intro/"},"frontmatter":{"title":"React 톺아보기- 02. Intro","category":"react"}},"next":{"fields":{"slug":"/react/in-depth-react-hooks_2/"},"frontmatter":{"title":"React 톺아보기- 03. Hooks_2","category":"react"}}}}}