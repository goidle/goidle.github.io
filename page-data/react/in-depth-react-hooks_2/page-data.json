{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react-hooks_2/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"f5d1eff1-d17a-5c1e-a9fb-8a160e1a9ae5","excerpt":"모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. Update state 1. 훅 객체 가지고 오기 훅의 구현체는 컴포넌트가 mount 된 이후에는 항상 update를 사용합니다. 구현체를 갈아 끼우는 를 다시 한 번 더 확인해보겠습니다. 는 그저 로 포워딩하는 함수입니다. 그리고 함수 이름에서 알 수 있듯이 의 update 구현체입니다. 는 그저 을 처리하는 reducer…","html":"<blockquote>\n<p>모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.</p>\n</blockquote>\n<h2 id=\"update-state\"><a href=\"#update-state\" aria-label=\"update state permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Update state</h2>\n<h3 id=\"1-훅-객체-가지고-오기\"><a href=\"#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%98%A4%EA%B8%B0\" aria-label=\"1 훅 객체 가지고 오기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 훅 객체 가지고 오기</h3>\n<p>훅의 구현체는 컴포넌트가 mount 된 이후에는 항상 update를 사용합니다. 구현체를 갈아 끼우는 <code class=\"language-text\">renderWithHooks()</code>를 다시 한 번 더 확인해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > renderWithHooks()</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">renderWithHooks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 훅이 사용되었다면 memoizedState에 훅 리스트가 존재</span>\n  nextCurrentHook <span class=\"token operator\">=</span> current <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> current<span class=\"token punctuation\">.</span>memoizedState <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// mount, update 여부에 따라 구현체 주입</span>\n  ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span>\n    nextCurrentHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> HooksDispatcherOnMount <span class=\"token punctuation\">:</span> HooksDispatcherOnUpdate\n\n  <span class=\"token comment\">// let children = Component(props, refOrContext)</span>\n\n  <span class=\"token comment\">// 컴포넌트 실행 후 처리된 훅 리스트를 저장</span>\n  renderedWork<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> firstWorkInProgressHook\n  <span class=\"token comment\">// 비동기로 훅을 사용할 경우를 대비한 error throw 구현체</span>\n  ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> ContextOnlyDispatcher\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateState()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateState</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">initialState<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span>basicStateReducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">updateState()</code>는 그저 <code class=\"language-text\">updateReducer()</code>로 포워딩하는 함수입니다. 그리고 함수 이름에서 알 수 있듯이 <code class=\"language-text\">useReducer()</code>의 update 구현체입니다. <code class=\"language-text\">useState()</code>는 그저 <code class=\"language-text\">action</code>을 처리하는 reducer가 <code class=\"language-text\">basicStateReducer</code>로 고정된 훅입니다. 두 개의 차이는 reducer를 사용자가 넘겨준 reducer를 사용하느냐 아니면 basic을 사용하느냐의 차이만 있을 뿐입니다.  </p>\n<p>mount 와 마찬가지로 먼저 훅을 가져와야 합니다. mount 때는 훅을 만들었고 update는 이전 훅 리스트의 head를 가지고 와야 합니다. 그리고 그 head는 <code class=\"language-text\">renderWithHooks()</code>에서 전역변수에 할당했던 <code class=\"language-text\">nextCurrentHook</code>를 사용합니다.<br>\n그리고 한 가지 더 알아가야 할 부분은 모든 훅은 이 타이밍에 이전 훅을 바로 사용하지 않고 훅 객체들을 항상 새로 만들어서 사용합니다.  </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span>\n  initialArg<span class=\"token punctuation\">,</span>\n  init<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer() > updateWorkInProgressHook()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Hook <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 훅 연결 리스트의 head</span>\n  currentHook <span class=\"token operator\">=</span> nextCurrentHook<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 훅 객체를 새로 만든다.</span>\n  <span class=\"token keyword\">const</span> newHook<span class=\"token punctuation\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    memoizedState<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span>\n\n    baseState<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>baseState<span class=\"token punctuation\">,</span>\n    queue<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">,</span>\n    baseUpdate<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>baseUpdate<span class=\"token punctuation\">,</span>\n\n    next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This is the first hook in the list.</span>\n    workInProgressHook <span class=\"token operator\">=</span> firstWorkInProgressHook <span class=\"token operator\">=</span> newHook<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Append to the end of the list.</span>\n    workInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newHook<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  nextCurrentHook <span class=\"token operator\">=</span> currentHook<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>근데 컴포넌트는 실행될 때마다 추가적인 업데이트가 발생할 수 있었습니다. 한번 렌더링할 때 훅은 한 번만 새로 만들면 됩니다. 그래서 <em>render phase update</em>로 인해 추가로 컴포넌트가 실행될 때는 이미 만들어놓은 훅 객체를 사용하게 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer() > updateWorkInProgressHook()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Hook <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// nextWorkInProgressHook를 통해 render phase update를 판단</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextWorkInProgressHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// There's already a work-in-progress. Reuse it.</span>\n    workInProgressHook <span class=\"token operator\">=</span> nextWorkInProgressHook<span class=\"token punctuation\">;</span>\n    nextWorkInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n\n    currentHook <span class=\"token operator\">=</span> nextCurrentHook<span class=\"token punctuation\">;</span>\n    nextCurrentHook <span class=\"token operator\">=</span> currentHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> currentHook<span class=\"token punctuation\">.</span>next <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">//  currentHook = nextCurrentHook;</span>\n<span class=\"token comment\">//  const newHook: Hook = { 생략.. }</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> workInProgressHook<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>컴포넌트를 재실행시켜주는 로직을 보면<up><code class=\"language-text\">renderWithHooks</code></up> 컴포넌트 실행 직전에 다음과 같이 전역변수를 셋팅었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > renderWithHooks()</span>\nnextCurrentHook <span class=\"token operator\">=</span> current <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> current<span class=\"token punctuation\">.</span>memoizedState <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nnextWorkInProgressHook <span class=\"token operator\">=</span> firstWorkInProgressHook<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">firstWorkInProgressHook</code>는 우리가 새롭게 만든 훅 리스트의 head입니다.</p>\n<h3 id=\"2-훅의-code-classlanguage-textbaseupdatecode-circular-linked-list\"><a href=\"#2-%ED%9B%85%EC%9D%98-code-classlanguage-textbaseupdatecode-circular-linked-list\" aria-label=\"2 훅의 code classlanguage textbaseupdatecode circular linked list permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 훅의 <code class=\"language-text\">baseUpdate</code>, <em>Circular Linked List</em></h3>\n<p>훅 객체를 만들 때 설명을 생략했던 <code class=\"language-text\">baseUpdate</code>와 <code class=\"language-text\">baseState</code>, 그리고 <em>update</em>가 왜 <em>Circular Linked List</em>인지 알아보고 가야 할 차례가 왔습니다. 훅과 <code class=\"language-text\">queue</code>에 대해서 한 번 더 개념을 잡고 가겠습니다.  </p>\n<p><code class=\"language-text\">queue</code>는 <em>update</em>를 담고 있습니다. 우리는 항상 <em>update</em>를 이 <code class=\"language-text\">queue</code>에 추가해줍니다. 그리고 <em>update state</em>일 때 <code class=\"language-text\">queue</code>에서 <em>update</em> 리스트를 꺼내와 적용시킵니다. 문제는 업데이트가 자주 발생할 경우 이 <code class=\"language-text\">queue</code>가 매우 길어지며 매번 처음부터 반복하게 될 수도 있습니다.  </p>\n<p>그래서 이 불필요한 반복을 줄이기 위해 적용된 부분과 아직 적용되지 않은 부분의 경계선을 정해줄 필요가 있습니다. 그래야 이 경계선을 기준으로 적용되지 않는 부분만 실행할 수 있으며 이미 적용된, 더는 사용하지 않을 <em>update</em> 객체를 gc를 위해 참조를 끊어줄 필요도 있습니다.  </p>\n<p>그럼 이 경계선에 대한 지식은 누가 알고 있어야 할까요? 리액트는 이 지식을 <code class=\"language-text\">queue</code>가 아닌 훅 객체가 알고 있어야 한다고 생각했습니다. 그리고 그 정보는 <code class=\"language-text\">baseUpdate</code>, <code class=\"language-text\">baseState</code>에 담기게 됩니다. <code class=\"language-text\">baseUpdate</code>는 적용된<em>update</em>의 tail 포인터이며 <code class=\"language-text\">baseState</code>는 tail <em>update</em>를 실행한 결괏값입니다.<br>\n이제 이 base를 기준으로 next는 모두 적용되지 않은 훅들의 리스트입니다.  </p>\n<p>근데 <code class=\"language-text\">queue</code>는 마지막 <em>update</em>만 <code class=\"language-text\">last</code>에 담고 있었습니다. 이러면 tail만 알 수 있지 head는 모릅니다. <code class=\"language-text\">baseUpdate</code>도 처음에는 적용된 <em>update</em>가 없으므로 null입니다.<br>\n이러한 케이스 때문에 <em>update state</em>를 실행하기 전까지는 head를 계속 물고 있기 위해 처음에는 <em>update</em>의 <code class=\"language-text\">last.next</code>가 head를 가리키기위해 <em>Circular Linked List</em>로 만들어 놓는 겁니다.  </p>\n<p><em>update state</em>를 한 번이라도 실행하면 이 <em>Circular Linked List</em>를 끊어주고 모든 <em>update</em>를 적용시킨 후 <code class=\"language-text\">baseUpdate</code>에 tail <em>update</em>를 할당해주게 됩니다.<br>\n이 이유 때문에 <code class=\"language-text\">dispatchAction()</code>에서 <em>update</em>를 연결 리스트로 추가할 때 <code class=\"language-text\">last</code>의 next가 있는지 확인하는 부분이 바로 head를 훅의 <code class=\"language-text\">baseUpdate</code>에서 물고 있는지 아니면 <code class=\"language-text\">queue</code>에서<em>Circular Linked List</em>를 통해 물고 있는지 확인하는 의미가 되겠습니다.  </p>\n<h3 id=\"3-update-적용-시키기\"><a href=\"#3-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0\" aria-label=\"3 update 적용 시키기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. update 적용 시키기</h3>\n<p><code class=\"language-text\">dispatchAction()</code>에서 <em>render phase update</em>를 나타내는 플래그를 설정함과 동시에 모든 <em>update</em>들을 <code class=\"language-text\">renderPhaseUpdates</code> 맵에 담아두었던 걸 기억하시나요? 이 맵을 다음번 컴포넌트 실행 때 꺼내어 적용하는데 이 부분이 다음 코드에서 <code class=\"language-text\">if (numberOfReRenders &gt; 0)</code>에 해당합니다.<br>\n해당 로직은 <em>updateState</em> 의 나머지 로직을 먼저 보고 난 후에 확인하도록 하겠습니다.</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span>\n  initialArg<span class=\"token punctuation\">,</span>\n  init<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const hook = updateWorkInProgressHook();</span>\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">;</span>\n  queue<span class=\"token punctuation\">.</span>lastRenderedReducer <span class=\"token operator\">=</span> reducer<span class=\"token punctuation\">;</span> <span class=\"token comment\">// updateState는 basicStateReducer</span>\n\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numberOfReRenders <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span>    <span class=\"token comment\">// 생략..</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 훅을 가지고 왔으니 <code class=\"language-text\">queue</code>에 있는 <em>update</em>를 적용시킬 차례입니다. 로직은 간단합니다.  </p>\n<ol>\n<li>적용시킬 <em>update</em>의 head를 가지고 온다. </li>\n<li><em>baseUpdate</em> 또는 <em>last.next</em></li>\n<li><em>Circular Linked List</em> 라면 last의 next에 null을 할당하여 연결을 끊어준다.</li>\n<li>head부터 시작하여 tail까지 순회하면서 <code class=\"language-text\">reducer</code>에 <code class=\"language-text\">action</code>을 던져 결괏값을 취한다.</li>\n<li><em>update</em>를 모두 실행했다면 결과를 저장한다. </li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token comment\">// 생략..</span>\n<span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>last<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> baseUpdate <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseUpdate<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 적용된 리스트의 tail update</span>\n<span class=\"token keyword\">const</span> baseState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseState<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 1. 적용시킬 *update*의 head를 가지고 온다. </span>\n  <span class=\"token keyword\">let</span> first<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>baseUpdate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 첫 업데이트가 커밋된 이후에는 baseUpdate가 존재하기 때문에 </span>\n      <span class=\"token comment\">// 더 이상 Circular Linked List는 필요가 없다. 다음 update state부터는 연결을 끊어준다.</span>\n    <span class=\"token punctuation\">}</span>\n    first <span class=\"token operator\">=</span> baseUpdate<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span> <span class=\"token comment\">// baseUpdate의 head 참조</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    first <span class=\"token operator\">=</span> last <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> last<span class=\"token punctuation\">.</span>next <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Circular Linked List의 head 참조</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 2. head부터 시작하여 tail까지 순회하면서 `reducer`에 `action`을 던져 결괏값을 취한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> baseState<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> prevUpdate <span class=\"token operator\">=</span> baseUpdate<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action<span class=\"token punctuation\">;</span>\n        newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      prevUpdate <span class=\"token operator\">=</span> update<span class=\"token punctuation\">;</span>\n      update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> update <span class=\"token operator\">!==</span> first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 3. *update*를 모두 실행했다면 결과를 저장한다. </span>\n    hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span>\n    hook<span class=\"token punctuation\">.</span>baseUpdate <span class=\"token operator\">=</span> prevUpdate<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 적용된 tail update</span>\n    hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>dispatch<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>다음은 <em>render phase update</em>를 담아두었던 <code class=\"language-text\">renderPhaseUpdates</code>을 사용하여 <em>update</em>를 적용시키는 방법을 알아보겠습니다.</p>\n<h3 id=\"4-render-phase-update-적용-시키기\"><a href=\"#4-render-phase-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0\" aria-label=\"4 render phase update 적용 시키기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. render phase update 적용 시키기</h3>\n<p><em>render phase update</em>을 <code class=\"language-text\">renderPhaseUpdates</code>에 담을 때 key를 <code class=\"language-text\">queue</code>로 사용했습니다.\n<code class=\"language-text\">queue</code>를 이용하여 <em>render phase update</em> 리스트를 꺼내 head - tail까지 순회하며 위에서 본 로직과 같이 결괏값을 취한 후 마무리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span>\n  initialArg<span class=\"token punctuation\">,</span>\n  init<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numberOfReRenders <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>dispatch<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>renderPhaseUpdates <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> firstRenderPhaseUpdate <span class=\"token operator\">=</span> renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstRenderPhaseUpdate <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> firstRenderPhaseUpdate<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action<span class=\"token punctuation\">;</span>\n          newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">.</span>baseUpdate <span class=\"token operator\">===</span> queue<span class=\"token punctuation\">.</span>last<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n          <span class=\"token comment\">// queue의 마지막이 이미 다 적용된 update라면(baseUpdate)</span>\n          <span class=\"token comment\">// 처리해야 할 update가 남아 있지 않은 것이기 때문에 여기서 처리된 state를 할당해도 된다.</span>\n          hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        queue<span class=\"token punctuation\">.</span>lastRenderedState <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>newState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기까지가 <em>useState</em> 훅의 전부입니다.<br>\n이전 Hooks_1에서 처음에 언급 드렸던 다음의 순서 중 1번과 3번의 일부분(<down>재조정 작업 중 컴포넌트 실행에서 <em>update</em>를 적용 시켜주는 부분</down>)을 보았습니다.</p>\n<ol>\n<li>훅을 통해 컴포넌트 상태를 업데이트한다.</li>\n<li>VDOM 재조정을 해줄 <em>Work</em>를 <em>scheduler</em>에게 스케줄링 시키고 <em>scheduler</em>가 스케줄링된<em>Task</em>를 꺼내 실행한다</li>\n<li><em>Work</em>을 통해 VDOM 재조정 작업을 진행한다.</li>\n<li>완성된 VDOM을 <em>commit phase</em>에서 처리하여 DOM에 적용시킨다.</li>\n<li>사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.</li>\n</ol>\n<p><em>useReducer</em>는 <em>useState</em>와 같은 구현체 쓰고 <em>useEffect</em>는 <em>commit phase</em> 때 추가 적으로 확인하게 될 것으로 이를 제외한 나머지 훅들도 궁금하신 분들은 직접 한번 분석해보시길 추천해 드립니다.  </p>\n<p>다음 포스트는 2번 <em>scheduler</em>를 분석합니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">목록</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"https://goidle.github.io/react/in-depth-react-hooks_1/\">React 톺아보기- 03. Hooks_1</a></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"https://goidle.github.io/react/in-depth-react-scheduler/\">React 톺아보기- 04. Scheduler</a></td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"React 톺아보기- 03. Hooks_2","date":"2020-06-15","keywords":["리액트","react","fiber","hook","hooks","useState","useEffect","useLayoutEffect","useCallback"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react/in-depth-react-hooks_2/","previous":{"fields":{"slug":"/react/in-depth-react-hooks_1/"},"frontmatter":{"title":"React 톺아보기- 03. Hooks_1","category":"react"}},"next":null}}}