<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Deep Dive Magic Code]]></title><description><![CDATA[오픈소스를 톺아보며 매직 코드라 생각했던 부분들의 동작 원리와 의미, 의도를 파악해보고 서로의 생각을 나누기 위한 블로그]]></description><link>https://github.com/goidle</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 23 Jun 2020 06:03:04 GMT</lastBuildDate><item><title><![CDATA[React 톺아보기- 03. Hooks_2]]></title><description><![CDATA[모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. Update state 1. 훅 객체 가지고 오기 훅의 구현체는 컴포넌트가 mount…]]></description><link>https://github.com/goidle/react/in-depth-react-hooks_2/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-hooks_2/</guid><pubDate>Mon, 15 Jun 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;update-state&quot;&gt;&lt;a href=&quot;#update-state&quot; aria-label=&quot;update state permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Update state&lt;/h2&gt;
&lt;h3 id=&quot;1-훅-객체-가지고-오기&quot;&gt;&lt;a href=&quot;#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%98%A4%EA%B8%B0&quot; aria-label=&quot;1 훅 객체 가지고 오기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 훅 객체 가지고 오기&lt;/h3&gt;
&lt;p&gt;훅의 구현체는 컴포넌트가 mount 된 이후에는 항상 update를 사용합니다. 구현체를 갈아 끼우는 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;를 다시 한 번 더 확인해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderWithHooks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 훅이 사용되었다면 memoizedState에 훅 리스트가 존재&lt;/span&gt;
  nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// mount, update 여부에 따라 구현체 주입&lt;/span&gt;
  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; HooksDispatcherOnMount &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HooksDispatcherOnUpdate

  &lt;span class=&quot;token comment&quot;&gt;// let children = Component(props, refOrContext)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트 실행 후 처리된 훅 리스트를 저장&lt;/span&gt;
  renderedWork&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook
  &lt;span class=&quot;token comment&quot;&gt;// 비동기로 훅을 사용할 경우를 대비한 error throw 구현체&lt;/span&gt;
  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ContextOnlyDispatcher
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;initialState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;basicStateReducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; initialState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;updateState()&lt;/code&gt;는 그저 &lt;code class=&quot;language-text&quot;&gt;updateReducer()&lt;/code&gt;로 포워딩하는 함수입니다. 그리고 함수 이름에서 알 수 있듯이 &lt;code class=&quot;language-text&quot;&gt;useReducer()&lt;/code&gt;의 update 구현체입니다. &lt;code class=&quot;language-text&quot;&gt;useState()&lt;/code&gt;는 그저 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt;을 처리하는 reducer가 &lt;code class=&quot;language-text&quot;&gt;basicStateReducer&lt;/code&gt;로 고정된 훅입니다. 두 개의 차이는 reducer를 사용자가 넘겨준 reducer를 사용하느냐 아니면 basic을 사용하느냐의 차이만 있을 뿐입니다.  &lt;/p&gt;
&lt;p&gt;mount 와 마찬가지로 먼저 훅을 가져와야 합니다. mount 때는 훅을 만들었고 update는 이전 훅 리스트의 head를 가지고 와야 합니다. 그리고 그 head는 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 전역변수에 할당했던 &lt;code class=&quot;language-text&quot;&gt;nextCurrentHook&lt;/code&gt;를 사용합니다.&lt;br&gt;
그리고 한 가지 더 알아가야 할 부분은 모든 훅은 이 타이밍에 이전 훅을 바로 사용하지 않고 훅 객체들을 항상 새로 만들어서 사용합니다.  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  init&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer() &gt; updateWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 훅 연결 리스트의 head&lt;/span&gt;
  currentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextCurrentHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 훅 객체를 새로 만든다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newHook&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    memoizedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

    baseState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgressHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// This is the first hook in the list.&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Append to the end of the list.&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;근데 컴포넌트는 실행될 때마다 추가적인 업데이트가 발생할 수 있었습니다. 한번 렌더링할 때 훅은 한 번만 새로 만들면 됩니다. 그래서 &lt;em&gt;render phase update&lt;/em&gt;로 인해 추가로 컴포넌트가 실행될 때는 이미 만들어놓은 훅 객체를 사용하게 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer() &gt; updateWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// nextWorkInProgressHook를 통해 render phase update를 판단&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// There&apos;s already a work-in-progress. Reuse it.&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextWorkInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    currentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextCurrentHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentHook &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; currentHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//  currentHook = nextCurrentHook;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//  const newHook: Hook = { 생략.. }&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;컴포넌트를 재실행시켜주는 로직을 보면&lt;up&gt;&lt;code class=&quot;language-text&quot;&gt;renderWithHooks&lt;/code&gt;&lt;/up&gt; 컴포넌트 실행 직전에 다음과 같이 전역변수를 셋팅었습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;는 우리가 새롭게 만든 훅 리스트의 head입니다.&lt;/p&gt;
&lt;h3 id=&quot;2-훅의-code-classlanguage-textbaseupdatecode-circular-linked-list&quot;&gt;&lt;a href=&quot;#2-%ED%9B%85%EC%9D%98-code-classlanguage-textbaseupdatecode-circular-linked-list&quot; aria-label=&quot;2 훅의 code classlanguage textbaseupdatecode circular linked list permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 훅의 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;, &lt;em&gt;Circular Linked List&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;훅 객체를 만들 때 설명을 생략했던 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;, 그리고 &lt;em&gt;update&lt;/em&gt;가 왜 &lt;em&gt;Circular Linked List&lt;/em&gt;인지 알아보고 가야 할 차례가 왔습니다. 훅과 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 대해서 한 번 더 개념을 잡고 가겠습니다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;는 &lt;em&gt;update&lt;/em&gt;를 담고 있습니다. 우리는 항상 &lt;em&gt;update&lt;/em&gt;를 이 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 추가해줍니다. 그리고 &lt;em&gt;update state&lt;/em&gt;일 때 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에서 &lt;em&gt;update&lt;/em&gt; 리스트를 꺼내와 적용시킵니다. 문제는 업데이트가 자주 발생할 경우 이 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;가 매우 길어지며 매번 처음부터 반복하게 될 수도 있습니다.  &lt;/p&gt;
&lt;p&gt;그래서 이 불필요한 반복을 줄이기 위해 적용된 부분과 아직 적용되지 않은 부분의 경계선을 정해줄 필요가 있습니다. 그래야 이 경계선을 기준으로 적용되지 않는 부분만 실행할 수 있으며 이미 적용된, 더는 사용하지 않을 &lt;em&gt;update&lt;/em&gt; 객체를 gc를 위해 참조를 끊어줄 필요도 있습니다.  &lt;/p&gt;
&lt;p&gt;그럼 이 경계선에 대한 지식은 누가 알고 있어야 할까요? 리액트는 이 지식을 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;가 아닌 훅 객체가 알고 있어야 한다고 생각했습니다. 그리고 그 정보는 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;에 담기게 됩니다. &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;는 적용된&lt;em&gt;update&lt;/em&gt;의 tail 포인터이며 &lt;code class=&quot;language-text&quot;&gt;baseState&lt;/code&gt;는 tail &lt;em&gt;update&lt;/em&gt;를 실행한 결괏값입니다.&lt;br&gt;
이제 이 base를 기준으로 next는 모두 적용되지 않은 훅들의 리스트입니다.  &lt;/p&gt;
&lt;p&gt;근데 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;는 마지막 &lt;em&gt;update&lt;/em&gt;만 &lt;code class=&quot;language-text&quot;&gt;last&lt;/code&gt;에 담고 있었습니다. 이러면 tail만 알 수 있지 head는 모릅니다. &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;도 처음에는 적용된 &lt;em&gt;update&lt;/em&gt;가 없으므로 null입니다.&lt;br&gt;
이러한 케이스 때문에 &lt;em&gt;update state&lt;/em&gt;를 실행하기 전까지는 head를 계속 물고 있기 위해 처음에는 &lt;em&gt;update&lt;/em&gt;의 &lt;code class=&quot;language-text&quot;&gt;last.next&lt;/code&gt;가 head를 가리키기위해 &lt;em&gt;Circular Linked List&lt;/em&gt;로 만들어 놓는 겁니다.  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;update state&lt;/em&gt;를 한 번이라도 실행하면 이 &lt;em&gt;Circular Linked List&lt;/em&gt;를 끊어주고 모든 &lt;em&gt;update&lt;/em&gt;를 적용시킨 후 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;에 tail &lt;em&gt;update&lt;/em&gt;를 할당해주게 됩니다.&lt;br&gt;
이 이유 때문에 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;에서 &lt;em&gt;update&lt;/em&gt;를 연결 리스트로 추가할 때 &lt;code class=&quot;language-text&quot;&gt;last&lt;/code&gt;의 next가 있는지 확인하는 부분이 바로 head를 훅의 &lt;code class=&quot;language-text&quot;&gt;baseUpdate&lt;/code&gt;에서 물고 있는지 아니면 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에서&lt;em&gt;Circular Linked List&lt;/em&gt;를 통해 물고 있는지 확인하는 의미가 되겠습니다.  &lt;/p&gt;
&lt;h3 id=&quot;3-update-적용-시키기&quot;&gt;&lt;a href=&quot;#3-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0&quot; aria-label=&quot;3 update 적용 시키기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. update 적용 시키기&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;에서 &lt;em&gt;render phase update&lt;/em&gt;를 나타내는 플래그를 설정함과 동시에 모든 &lt;em&gt;update&lt;/em&gt;들을 &lt;code class=&quot;language-text&quot;&gt;renderPhaseUpdates&lt;/code&gt; 맵에 담아두었던 걸 기억하시나요? 이 맵을 다음번 컴포넌트 실행 때 꺼내어 적용하는데 이 부분이 다음 코드에서 &lt;code class=&quot;language-text&quot;&gt;if (numberOfReRenders &amp;gt; 0)&lt;/code&gt;에 해당합니다.&lt;br&gt;
해당 로직은 &lt;em&gt;updateState&lt;/em&gt; 의 나머지 로직을 먼저 보고 난 후에 확인하도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  init&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const hook = updateWorkInProgressHook();&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedReducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reducer&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// updateState는 basicStateReducer&lt;/span&gt;

&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 훅을 가지고 왔으니 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 있는 &lt;em&gt;update&lt;/em&gt;를 적용시킬 차례입니다. 로직은 간단합니다.  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;적용시킬 &lt;em&gt;update&lt;/em&gt;의 head를 가지고 온다. &lt;/li&gt;
&lt;li&gt;&lt;em&gt;baseUpdate&lt;/em&gt; 또는 &lt;em&gt;last.next&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Circular Linked List&lt;/em&gt; 라면 last의 next에 null을 할당하여 연결을 끊어준다.&lt;/li&gt;
&lt;li&gt;head부터 시작하여 tail까지 순회하면서 &lt;code class=&quot;language-text&quot;&gt;reducer&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;action&lt;/code&gt;을 던져 결괏값을 취한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;update&lt;/em&gt;를 모두 실행했다면 결과를 저장한다. &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; baseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 적용된 리스트의 tail update&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 1. 적용시킬 *update*의 head를 가지고 온다. &lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; first&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;baseUpdate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 첫 업데이트가 커밋된 이후에는 baseUpdate가 존재하기 때문에 &lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 더 이상 Circular Linked List는 필요가 없다. 다음 update state부터는 연결을 끊어준다.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// baseUpdate의 head 참조&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Circular Linked List의 head 참조&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 2. head부터 시작하여 tail까지 순회하면서 `reducer`에 `action`을 던져 결괏값을 취한다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;first &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; baseState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; prevUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; first&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; action &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      prevUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;update &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; first&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// 3. *update*를 모두 실행했다면 결과를 저장한다. &lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; prevUpdate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 적용된 tail update&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다음은 &lt;em&gt;render phase update&lt;/em&gt;를 담아두었던 &lt;code class=&quot;language-text&quot;&gt;renderPhaseUpdates&lt;/code&gt;을 사용하여 &lt;em&gt;update&lt;/em&gt;를 적용시키는 방법을 알아보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;4-render-phase-update-적용-시키기&quot;&gt;&lt;a href=&quot;#4-render-phase-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0&quot; aria-label=&quot;4 render phase update 적용 시키기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. render phase update 적용 시키기&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;render phase update&lt;/em&gt;을 &lt;code class=&quot;language-text&quot;&gt;renderPhaseUpdates&lt;/code&gt;에 담을 때 key를 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;로 사용했습니다.
&lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 이용하여 &lt;em&gt;render phase update&lt;/em&gt; 리스트를 꺼내 head - tail까지 순회하며 위에서 본 로직과 같이 결괏값을 취한 후 마무리합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; updateReducer()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;reducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  initialArg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  init&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; action &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          newState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;update &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseUpdate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; 
          &lt;span class=&quot;token comment&quot;&gt;// queue의 마지막이 이미 다 적용된 update라면(baseUpdate)&lt;/span&gt;
          &lt;span class=&quot;token comment&quot;&gt;// 처리해야 할 update가 남아 있지 않은 것이기 때문에 여기서 처리된 state를 할당해도 된다.&lt;/span&gt;
          hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;newState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기까지가 &lt;em&gt;useState&lt;/em&gt; 훅의 전부입니다.&lt;br&gt;
이전 Hooks_1에서 처음에 언급 드렸던 다음의 순서 중 1번과 3번의 일부분(&lt;down&gt;재조정 작업 중 컴포넌트 실행에서 &lt;em&gt;update&lt;/em&gt;를 적용 시켜주는 부분&lt;/down&gt;)을 보았습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;훅을 통해 컴포넌트 상태를 업데이트한다.&lt;/li&gt;
&lt;li&gt;VDOM 재조정을 해줄 &lt;em&gt;Work&lt;/em&gt;를 &lt;em&gt;scheduler&lt;/em&gt;에게 스케줄링 시키고 &lt;em&gt;scheduler&lt;/em&gt;가 스케줄링된&lt;em&gt;Task&lt;/em&gt;를 꺼내 실행한다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Work&lt;/em&gt;을 통해 VDOM 재조정 작업을 진행한다.&lt;/li&gt;
&lt;li&gt;완성된 VDOM을 &lt;em&gt;commit phase&lt;/em&gt;에서 처리하여 DOM에 적용시킨다.&lt;/li&gt;
&lt;li&gt;사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;useReducer&lt;/em&gt;는 &lt;em&gt;useState&lt;/em&gt;와 같은 구현체 쓰고 &lt;em&gt;useEffect&lt;/em&gt;는 &lt;em&gt;commit phase&lt;/em&gt; 때 추가 적으로 확인하게 될 것으로 이를 제외한 나머지 훅들도 궁금하신 분들은 직접 한번 분석해보시길 추천해 드립니다.  &lt;/p&gt;
&lt;p&gt;다음 포스트는 2번 &lt;em&gt;scheduler&lt;/em&gt;를 분석합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-hooks_1/&quot;&gt;React 톺아보기- 03. Hooks_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-scheduler/&quot;&gt;React 톺아보기- 04. Scheduler&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 03. Hooks_1]]></title><description><![CDATA[모든 설명은 v16.12.…]]></description><link>https://github.com/goidle/react/in-depth-react-hooks_1/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-hooks_1/</guid><pubDate>Fri, 12 Jun 2020 10:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;글을 써내려가는 방식은 하나도 몰랐던 상태에서 리액트를 분석한 그 순서 그대로를 따라가면서 설명하도록 하겠습니다.&lt;br&gt;
글의 흐름은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;훅을 통해 컴포넌트 상태를 업데이트한다.&lt;/li&gt;
&lt;li&gt;VDOM 재조정을 해줄 &lt;em&gt;Work&lt;/em&gt;를 &lt;em&gt;scheduler&lt;/em&gt;에게 스케줄링 시키고 &lt;em&gt;scheduler&lt;/em&gt;가 스케줄링된 &lt;em&gt;Task&lt;/em&gt;를 꺼내 실행한다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Work&lt;/em&gt;을 통해 VDOM 재조정 작업을 진행한다.&lt;/li&gt;
&lt;li&gt;완성된 VDOM을 &lt;em&gt;commit phase&lt;/em&gt;에서 처리하여 DOM에 적용한다.&lt;/li&gt;
&lt;li&gt;사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 내용이 리액트에서 가장 일반적인 흐름일 것으로 생각됩니다. 위 내용만 제대로 이해하게 된다면 이 이외의 케이스들에 대해서 굳이 설명하지 않아도 혼자서 충분히 알아볼 수 있지 않을까 기대해봅니다.&lt;/p&gt;
&lt;p&gt;이번 포스트에서는 첫 번째인 훅을 통해 컴포넌트 상태를 어떻게 업데이트하는지 알아보도록 하겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;1-hook의-구현체는-어디에-있을까&quot;&gt;&lt;a href=&quot;#1-hook%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;1 hook의 구현체는 어디에 있을까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Hook의 구현체는 어디에 있을까?&lt;/h1&gt;
&lt;p&gt;분석을 시작하기 가장 좋은 방법은 분석할 함수를 어디서 어떻게 가져오는지 먼저 확인하는 것입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; React.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; useState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; useEffect &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactHooks&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactSharedInternals &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactSharedInternals&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; React &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ReactSharedInternals&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; React&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;개발자가 코어를 통해 가져오는 훅은 &lt;em&gt;ReactHooks&lt;/em&gt; 모듈에서 가져오고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactHooks.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactCurrentDispatcher &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactCurrentDispatcher&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolveDispatcher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initialState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;create&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; inputs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolveDispatcher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;create&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; inputs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resolveDispatcher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dispatcher
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher&lt;/code&gt;란 모듈에서 &lt;code class=&quot;language-text&quot;&gt;dispatcher&lt;/code&gt;를 가지고 오네요. 훅의 구현체는 &lt;code class=&quot;language-text&quot;&gt;dispatcher&lt;/code&gt;가 가지고 있나 봅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactCurrentDispatcher.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ReactCurrentDispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; ReactCurrentDispatcher&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아무것도 없습니다.. 그냥 객체 하나가 끝입니다.&lt;/p&gt;
&lt;p&gt;preview에서 패키지를 설명할 때 코어는 &lt;strong&gt;“개발자에게 다른 패키지의 모듈을 제공할 수 있도록 중간 다리 역할을 하는 모듈들만 위치해 있습니다.”&lt;/strong&gt; 라고 말했었습니다.&lt;/p&gt;
&lt;p&gt;훅에 대해서 좀만 더 생각해보자면 훅은 컴포넌트의 상태를 업데이트하는데 코어에서는 컴포넌트의 겉 정보인 &lt;em&gt;reactElement&lt;/em&gt;만을 관리합니다.&lt;br&gt;
그렇다는 이야기는 이 상태는 VDOM의 fiber에 저장된다는 것이고 이 fiber를 업데이트할 수 있는 역할은 fiber를 만들어내는 &lt;em&gt;reconciler&lt;/em&gt;에게 있다는 말입니다. 그러므로 hook의 구현체 또한 &lt;em&gt;reconciler&lt;/em&gt;에 위치해 있습니다.&lt;/p&gt;
&lt;p&gt;이렇게 보면 코어가 다른 패키지의 기능을 개발자에게 제공해 줄 때 의존성을 자기가 만들지 않고 외부에서 주입 받는다는 걸 알 수 있습니다. 스프링의 DI(Dependency Injection)와 같습니다.&lt;br&gt;
리액트는 외부에서 의존성을 주입할 때 코어에 바로 주입하지 않습니다. 중간자를 하나 더 두게 되는데 그게 Shared라는 패키지입니다.&lt;br&gt;
이 Shared는 모든 패키지들이 공유하는 정보들을 가지고 있습니다. intro에서 본 side effect tag들도 여기에 위치해 있습니다.&lt;/p&gt;
&lt;p&gt;Shared에서 코어에 의존성을 주입해주기 위해 react를 알고 있는 모듈은 ReactSharedInternal.js입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// shared &gt; ReactSharedInternals.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;react&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ReactSharedInternals &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
  React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;ReactSharedInternals&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasOwnProperty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;ReactCurrentDispatcher&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  ReactSharedInternals&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ReactCurrentDispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; ReactSharedInternals&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;맨 처음 React 선언 코드에서 본 &lt;code class=&quot;language-text&quot;&gt;__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED&lt;/code&gt;를 여기에서 사용하고 있습니다. 여기에는 코어의 &lt;em&gt;ReactSharedInternals&lt;/em&gt; 이 할당되어 있었습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactSharedInternals.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ReactCurrentDispatcher &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;./ReactCurrentDispatcher&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ReactSharedInternals &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; ReactSharedInternals&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;훅이 개발자에게 도달되는 흐름은 다음과 같습니다.
reconciler -&gt; shared/ReactSharedInternal -&gt; react/ReactSharedInternal -&gt; react/ReactCurrentDispatcher -&gt; react/ReactHooks -&gt; react -&gt; 개발자의 형태가 됩니다. 다시 코드를 한 번 쭉 훑어 보시면서 흐름을 느껴 보시길 바랍니다.&lt;/p&gt;
&lt;p&gt;이제 우리는 훅이 어디에 있는지 shared/ReactSharedInternal.js를 import하고 &lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher&lt;/code&gt;를 사용하고 있는 곳을 찾아가면 확인할 수 있을 것입니다.&lt;br&gt;
훅은 reconciler/ReactFiberHooks.js에 위치해 있습니다.&lt;/p&gt;
&lt;h1 id=&quot;2-hook은-내부에서-어떻게-사용되는가&quot;&gt;&lt;a href=&quot;#2-hook%EC%9D%80-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;2 hook은 내부에서 어떻게 사용되는가 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Hook은 내부에서 어떻게 사용되는가?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;본격적으로 들어가기에 실제 코드를 보면 __DEV__로 감싸진 코드들을 많이 보실 텐데 개발 모드에서만 사용됨을 뜻하기 때문에 산뜻하게 무시해주시면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;훅을 &lt;code class=&quot;language-text&quot;&gt;ReactCurrentDispatcher.current&lt;/code&gt;에 할당해주는 함수는 &lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;입니다. 함수 이름에서 느껴지시나요? 컴포넌트 실행을 여기서 합니다. 주목적은 훅 할당이 아니라 함수 실행이고 훅 할당은 부수적으로 따라오는 부분이 됩니다.&lt;br&gt;
이 함수는 재조정 작업을 할 때 사용되는데 그때 가서 자세히 다루고 지금은 훅과 관련된 코드들만 뜯어와서 보도록 하겠습니다.&lt;br&gt;
&lt;strong&gt;코드에서 제가 설명하지 않고 넘어가는 코드는 크게 신경 쓰지 않으셔도 됩니다. 복잡하니 그때는 생략되고 사용되는 뒷부분에서 다뤄진다고 생각하시면 됩니다.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;분석하기에 type이 있으면 좋을 부분들은 type를 제거하지 않고 그대로 사용하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderWithHooks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  workInProgress&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  Component&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  refOrContext&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  nextRenderExpirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  currentlyRenderingFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress &lt;span class=&quot;token comment&quot;&gt;// 현재 작업 중인 fiber를 전역으로 잡아둠&lt;/span&gt;
  nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;

  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; HooksDispatcherOnMount &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; HooksDispatcherOnUpdate

  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; refOrContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; renderedWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; currentlyRenderingFiber
  renderedWork&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook

  ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; ContextOnlyDispatcher
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;19&lt;/strong&gt;, &lt;strong&gt;22&lt;/strong&gt; 라인을 먼저 확인하겠습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Component&lt;/code&gt;는 fiber의 type에서 꺼낸 온 것인데 여기에는 개발자가 작성한 컴포넌트 함수가 저장되어 있습니다.
&lt;strong&gt;19&lt;/strong&gt; 라인을 통해 훅을 사용하고 있는 컴포넌트를 실행하면 전역변수 &lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;에 hook 객체가 저장됩니다.
이 변수를 fiber의 &lt;code class=&quot;language-text&quot;&gt;memoizedState&lt;/code&gt;에 저장해 놓음으로서 훅을 컴포넌트와 매핑시켜 줍니다.&lt;/p&gt;
&lt;p&gt;이제 &lt;strong&gt;12&lt;/strong&gt;번 라인을 이해할 수 있습니다. &lt;code class=&quot;language-text&quot;&gt;memoizedState&lt;/code&gt;가 null이 아니라면 이전 컴포넌트 렌더에서 훅이 사용되었다는 뜻이 됩니다.&lt;br&gt;
그리고 &lt;strong&gt;15&lt;/strong&gt; 라인에서 &lt;code class=&quot;language-text&quot;&gt;nextCurrentHook&lt;/code&gt;을 이용하여 훅이 mount인지 update인지 판단을 하게 됩니다. 그리고 거기에 맞게 훅 구현체를 다르게 사용합니다.&lt;br&gt;
즉 컴포넌트가 mount 될 때 훅은 mount 용 구현체를 사용할 것이고 그 이후에는 컴포넌트가 unmount되지 않는 한 계속 update 용 구현체를 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;strong&gt;24&lt;/strong&gt;번 라인에서 한 번 더 다른 훅 구현체 &lt;code class=&quot;language-text&quot;&gt;ContextOnlyDispatcher&lt;/code&gt;를 사용합니다. 이는 컴포넌트 실행이 모두 끝난 다음 혹시나 훅을 호출하는 상황이 발생할 때
에러를 던져 개발자가 올바르게 훅을 사용할 수 있도록 해주는 장치입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// mount&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; HooksDispatcherOnMount &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; mountState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; mountEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// update&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; HooksDispatcherOnUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; updateState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; updateEffect&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// invalid hook call&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ContextOnlyDispatcher&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Dispatcher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  useState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; throwInvalidHookError&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  useEffect&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; throwInvalidHookError&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-hook은-어떻게-구현되어-있을까&quot;&gt;&lt;a href=&quot;#3-hook%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;3 hook은 어떻게 구현되어 있을까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Hook은 어떻게 구현되어 있을까?&lt;/h1&gt;
&lt;p&gt;이번 포스트의 분석 대상인 훅은 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; 입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;분석하실 때 함수 내부에서 선언된 지역변수인지 모듈 최상단에서 선언된 전역변수인지 잘 확인하시길 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;mount-state&quot;&gt;&lt;a href=&quot;#mount-state&quot; aria-label=&quot;mount state permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Mount state&lt;/h2&gt;
&lt;h3 id=&quot;1-훅-객체-만들기&quot;&gt;&lt;a href=&quot;#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0&quot; aria-label=&quot;1 훅 객체 만들기 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 훅 객체 만들기&lt;/h3&gt;
&lt;p&gt;mount이기 때문에 먼저 훅 객체를 만들어 줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 훅 객체를 생성한다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ReactFiberHooks 모듈의 컨텍스트는 현재 작업 중인 컴포넌트 전용으로 사용됩니다. 이 말이 무슨 뜻이냐면 해당 모듈에서 선언되는
모든 것들은 현재 컴포넌트에만 국한되는 상태값으로 관리된다는 뜻입니다. 컴포넌트의 작업이 끝나게 되면 모두 초기화시켜
다음 컴포넌트에서 사용할 수 있도록 준비시켜 놓습니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;mountWorkInProgressHook&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;hook&lt;/code&gt;객체를 만들고 컴포넌트에서 맨 처음으로 호출된 훅일 경우에
전역 변수인 &lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;workInProgressHook&lt;/code&gt;에 저장해 놓습니다.&lt;br&gt;
이제 변수명에서 first만 보면 바로 연결 리스트로 생각 하셔도됩니다. 리액트는 많은 곳에서 built-in collection 대신 연결 리스트를 이용하여 구현했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;built-in collection이 아닌 연결리스트로 구현된 이유는 순회할 때 제어하기가 매우 쉽기 때문입니다.&lt;br&gt;
순회 조건이나 중지, 노드의 삭제 등 제어가 간편합니다.&lt;br&gt;
또 다른 이점 하나는 연결 리스트끼리 이어 붙이는데 많은 리소스가 들지 않는다는 겁니다. 단지 tail 포인터만 연결할 리스트의 head를 가리키기만 하면 됩니다.&lt;br&gt;
더불어 리액트에서는 랜덤 엑세스가 필요한 부분이 없으므로 더욱이 연결리스트를 쓰지 않을 이유가 없어 많은 곳에서 사용되고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;firstWorkInProgressHook&lt;/code&gt;은 &lt;em&gt;renderWithHooks()&lt;/em&gt;에서 이미 봤듯이 컴포넌트 실행이 끝났을 때 &lt;code class=&quot;language-text&quot;&gt;renderedWork.memoizedState = firstWorkInProgressHook;&lt;/code&gt;으로 fiber에 저장하는데 사용되고
&lt;code class=&quot;language-text&quot;&gt;workInProgressHook&lt;/code&gt;은 연결 리스트에서 현재 처리되고 있는 hook에 대한 포인터로 사용됩니다.&lt;br&gt;
여러 블로그에서 훅 구현체를 설명할 때 index와 배열을 이용하여 설명하지만 우리는 이제 실제 코드를 통해 연결 리스트로 되어 있다는 걸 알 수 있습니다.
그리고 왜 훅의 순서가 항상 같아야 하는지도 알 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountWorkInProgressHook()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountWorkInProgressHook&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// hook 객체에 대해서는 update에서 더욱 자세히 다루게 됩니다.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    memoizedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 마지막 상태값&lt;/span&gt;
    queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 훅이 여러 번 실행될 때 update들을 queue에 연결리스트로 저장한다.&lt;/span&gt;
    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 다음 연결 리스트 노드 포인터&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// 이하 update에서 설명&lt;/span&gt;
    baseState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    baseUpdate&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 맨 처음 실행되는 훅인 경우 연결 리스트의 head로 잡아둠&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgressHook &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    firstWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 두번 째부터는 연결 리스트에 추가&lt;/span&gt;
    workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgressHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; workInProgressHook
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;혹시나 혼동될까 봐 한 번 더 설명하자면 하나의 컴포넌트에서 여러 훅이 실행될 때는 훅 자체의 next 속성으로 연결 리스트로 저장되고 그 중 하나의 훅이 여러 번
호출될 때는 호출되는 훅 객체의 queue에 그 훅이 만들어놓는 &lt;em&gt;update&lt;/em&gt; 정보들이 연결 리스트로 저장됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;FC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setA&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// aHook&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setB&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// bHook&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;_a&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; _a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// hook linked list&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// fiber.memoizedState =&gt; aHook.next =&gt; bHook.next =&gt; null&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;//  update in queue of aHook&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// fiber.memoizedState =&gt; aHook.queue.last =&gt; firstUpdate.next&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// =&gt; secondUpdate.next =&gt; thirdUpdate.next =&gt; firstUpdate&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;queue는 왜 &lt;em&gt;Circular Linked List&lt;/em&gt;인지는 &lt;code class=&quot;language-text&quot;&gt;update state에서&lt;/code&gt; 설명합니다.&lt;/p&gt;
&lt;p&gt;계속해서 &lt;em&gt;mountState&lt;/em&gt;로 다시 돌아와서 훅을 mount 할 때 넘겨받은 &lt;em&gt;initialState&lt;/em&gt;가 함수이면 바로 실행해서 결괏값을 얻어옵니다. 이 이후 이 함수가 실행되는 일은 없습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// const hook = mountWorkInProgressHook();&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; initialState &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;function&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 생성자 함수일 경우&lt;/span&gt;
    initialState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;baseState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; initialState
  &lt;span class=&quot;token comment&quot;&gt;//생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-update를-담을-queue-생성&quot;&gt;&lt;a href=&quot;#2-update%EB%A5%BC-%EB%8B%B4%EC%9D%84-queue-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;2 update를 담을 queue 생성 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. update를 담을 queue 생성&lt;/h3&gt;
&lt;p&gt;이제 useState의 상태를 업데이트 하는 함수(&lt;down&gt;이하 &lt;em&gt;setState&lt;/em&gt;&lt;/down&gt;)를 호출할 때 넘겨주는 인자(&lt;down&gt;이하 &lt;em&gt;Action&lt;/em&gt;&lt;/down&gt;)를 저장해놓을 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 만듭니다.
한 번의 컴포넌트 실행에서 여러 번의 &lt;em&gt;setState&lt;/em&gt;가 호출되면 이 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 다가 쌓아 놓습니다.
그리고 컴포넌트가 리-렌더링 될 때 queue에 저장되어 있던 &lt;em&gt;Action&lt;/em&gt;들을 차례대로 꺼내서 실행해 맨 마지막 결괏값을 state로 반환해줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; mountState()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mountState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initialState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// hook.memoizedState = hook.baseState = initialState;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    last&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 마지막 update&lt;/span&gt;
    dispatch&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// queue에 push 해주는 함수&lt;/span&gt;

    lastRenderedReducer&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; basicStateReducer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// return typeof action === &apos;function&apos; ? action(state) : action;&lt;/span&gt;
    lastRenderedState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; initialState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    currentlyRenderingFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dispatch 함수 할당을 자세히 보면 bind를 통해서 인자를 잡아둔 상태로 외부에 노출시키고 있습니다.
우리가 사용하고 있는 &lt;code class=&quot;language-text&quot;&gt;const [a, setA] = useState(0);&lt;/code&gt;가 바로 위 반환하는 배열입니다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 push 해줄 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;를 알아보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;3-code-classlanguage-textdispatchactioncode&quot;&gt;&lt;a href=&quot;#3-code-classlanguage-textdispatchactioncode&quot; aria-label=&quot;3 code classlanguage textdispatchactioncode permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. &lt;code class=&quot;language-text&quot;&gt;dispatchAction&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;이 함수는 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 &lt;em&gt;update&lt;/em&gt;를 push 함과 동시에 &lt;em&gt;scheduler&lt;/em&gt;에게 &lt;em&gt;Work&lt;/em&gt;를 스케줄링 시켜주는 함수입니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;const [a, setA] = useState(0);&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;setA&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;reconciler 코드를 보면 항상 &lt;em&gt;render phase&lt;/em&gt;가 진행 중일 때 발생한 것인지 아니면 idle 상태에서 발생한 것인지에 따라 로직이 나뉩니다.&lt;br&gt;
두 케이스 모두 처리해야 할 방법이 다르고 최적화 방식도 조금씩 다르므로 기능이 궁금해서 함수를 까보면 이 이유 때문에 코드의 길이가 상당히 긴 경우가 많습니다.&lt;br&gt;
그래서 현재 분석하고 있는 코드가 어떤 상황에서 사용되는지 확실히 알고 가야 이해하기가 편합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;render phase update란?&lt;br&gt;
컴포넌트가 렌더링 되고 있는 상황에서 추가적으로 업데이트가 발생할 경우를 말합니다.&lt;br&gt;
다음 코드에서 버튼을 클릭했을 때 컴포넌트는 a가 1인 상태로 실행되는데 &lt;code class=&quot;language-text&quot;&gt;setA(2)&lt;/code&gt; 때문에 추가적인 업데이트가 발생한 경우입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;FC&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setA&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;button&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber 0&quot; class=&quot;language-ts line-numbers&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; alternate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    fiber &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; currentlyRenderingFiber &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; alternate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; currentlyRenderingFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// render phase update&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// update in idle&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;renderWithHooks()&lt;/em&gt;를 통해 컴포넌트가 실행되는 상황은 VDOM 재조정 작업 중 일때 발생합니다. 이는 업데이트가 발생하면 진행되는 작업으로 &lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt;가
비어있지 않다는 건 &lt;em&gt;renderWithHooks()&lt;/em&gt;가 호출되었다는 뜻입니다. 즉 &lt;em&gt;render phase&lt;/em&gt;가 진행 중인 상황입니다.&lt;/p&gt;
&lt;p&gt;이때 &lt;em&gt;10&lt;/em&gt;번 라인 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;이 bind로 잡아 두었던 fiber와 현재 작업 중인 &lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt; 가 같다는 건 현재 컴포넌트는 &lt;em&gt;render phase&lt;/em&gt;에서 작업중인 컴포넌트이며 동시에
업데이트가 발생한 상황임을 나타내는 조건입니다.&lt;/p&gt;
&lt;p&gt;한가지 더 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;도 비교를 하는데(&lt;em&gt;11번 라인&lt;/em&gt;) VDOM 트리는 두 개가 있습니다. &lt;em&gt;current&lt;/em&gt;, &lt;em&gt;workInProgress&lt;/em&gt;.&lt;br&gt;
하지만 우리는 &lt;u&gt;&lt;em&gt;훅이 mount 될 때 작업 중이었던 fiber&lt;/em&gt;&lt;/u&gt;를 bind로 고정시켜 놨습니다.&lt;br&gt;
거기에 &lt;em&gt;current&lt;/em&gt;와 &lt;em&gt;workInProgress&lt;/em&gt;는 고정이 아닌 &lt;em&gt;commit&lt;/em&gt;이 되면 서로 교체가 되기 때문에 현재 작업 중인 &lt;code class=&quot;language-text&quot;&gt;currentlyRenderingFiber&lt;/code&gt;가 두 개의 트리 중 어느 트리인지 알 수가 없습니다.&lt;br&gt;
그래서 &lt;code class=&quot;language-text&quot;&gt;fiber&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;를 모두 비교를 해야 현재 컴포넌트가 작업 중인지 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;render phase update&lt;/em&gt; 로직은 &lt;em&gt;idle update&lt;/em&gt;를 먼저 보고 난 후에 확인해 보도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;4-code-classlanguage-textexpirationtimecode&quot;&gt;&lt;a href=&quot;#4-code-classlanguage-textexpirationtimecode&quot; aria-label=&quot;4 code classlanguage textexpirationtimecode permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;idle update&lt;/em&gt;를 들어가기에 앞서 먼저 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt; 부터 알고 가야 합니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에 대해서는 깊이 들어가지는 않지만 리액트 시스템에 전반적으로 사용되므로 아주 기본만 알고 넘어가겠습니다.
가장 큰 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;은 32-bit 시스템인 v8에서 가장 큰 정수인 부호 있는 31bit 값입니다. 이 값을 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;로 다룹니다.
그리고 &lt;code class=&quot;language-text&quot;&gt;legacy mode&lt;/code&gt;에서는 모든 게 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;로 처리된다고 생각하시면 됩니다.&lt;br&gt;
여기서 나오는 나머지 부분들은 &lt;code class=&quot;language-text&quot;&gt;concurrent mode&lt;/code&gt;에서 사용됩니다.&lt;br&gt;
그리고 이름이 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;이라서 그렇지 작업의 유효 시간을 나타내는 것으로 쓰이지는 않습니다..&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberExpirationTime.js&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; NoWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Never &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Idle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Sync &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;MAX_SIGNED_31_BIT_INT&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1073741823&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Batched &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Sync &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Batched &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 시간을 가지고 올 때 시간의 형식은 &lt;code class=&quot;language-text&quot;&gt;Date.now()&lt;/code&gt;가 아닌 &lt;code class=&quot;language-text&quot;&gt;performance.now()&lt;/code&gt; 입니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 구하는 계산식은 &lt;code class=&quot;language-text&quot;&gt;MAX_SIGNED_31_BIT_INT - now()&lt;/code&gt; 입니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;now&lt;/code&gt;가 오른쪽 피 연산자에 있다는 건 나중에 발생한 작업일수록 더 작은 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 가지게 된다는 뜻입니다.
하지만 &lt;code class=&quot;language-text&quot;&gt;performance.now()&lt;/code&gt;로 현재 시간을 표현하기 때문에 그럴 일은 없겠지만 이론상으로는 발생 시간이 0이 나올 수도 있습니다.&lt;br&gt;
그렇게 되면 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Batched&lt;/code&gt;와 시간이 겹칠 수 있어서 기존 상수들과 겹치지 않기 위해 offset 값이 필요한데 그게 바로 &lt;code class=&quot;language-text&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/code&gt;입니다.
위 이유 때문에 계산식을 다시 작성하자면 &lt;code class=&quot;language-text&quot;&gt;MAGIC_NUMBER_OFFSET - now()&lt;/code&gt;가 됩니다.&lt;br&gt;
그리고 반대로 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에서 발생시간을 구하는 계산식은 &lt;code class=&quot;language-text&quot;&gt;offset - expirationTime&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt; 입니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;와는 반대로 큰 숫자가 더 나중에 발생한 작업을 나타냅니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberExpirationTime.js&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;///export const Batched = Sync - 1;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UNIT_SIZE&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 1 unit of expiration time represents 10ms.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;msToExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;ms&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ms &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UNIT_SIZE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;expirationTimeToMs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;expirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;MAGIC_NUMBER_OFFSET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UNIT_SIZE&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다시 간략하게 정리하자면 fiber의 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;NoWork&lt;/code&gt;이면 작업 중인게 없다는 뜻이고 &lt;code class=&quot;language-text&quot;&gt;Sync&lt;/code&gt;는 동기적으로 작업이 처리될 것이며 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 대소로 비교하는 조건문이 있을 때는
큰 숫자가 더 옛날에 먼저 발생한 작업이다. 라고만 생각하고 넘어가시면 분석할 때 큰 무리 없이 이해할 수 있을 것입니다.&lt;br&gt;
시간과 관련된 부분은 &lt;code class=&quot;language-text&quot;&gt;concurrent mode&lt;/code&gt;가 일반적으로 사용이 되면 그때 깊이 있게 알아보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;다시 훅의 업데이트를 dispatch 해주는 &lt;code class=&quot;language-text&quot;&gt;dispatchAction&lt;/code&gt;로 돌아오겠습니다. &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 간략하게 알아보았기 때문에 현재 시간으로 fiber의 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;을 구하는 부분은 생략하도록 하겠습니다.
업데이트에 대한 시간을 구한 후 이제 해야할 일은 업데이트 정보를 담을 &lt;em&gt;update&lt;/em&gt;객체를 만드는 것입니다.&lt;br&gt;
그리고 이 &lt;em&gt;Update&lt;/em&gt;를 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 push 해야 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatchAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; updateQueue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (render phase update) {&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 만료 시간을 구한다.&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// update 생성&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      expirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// setState의 인자값&lt;/span&gt;
      next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 연결 리스트&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 이하 바로 밑에서 추가적으로 다룰 것이기 때문에 생략&lt;/span&gt;
      eagerReducer&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      eagerState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// update를 queue에 연결리스트로 추가&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// This is the first update. Create a circular list.&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; first &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;first &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;        &lt;span class=&quot;token comment&quot;&gt;// Still circular.&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;        update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; first&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;      last&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;last &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;를 큐에 추가할 때 연결 리스트로 추가합니다. 로직을 보면 &lt;em&gt;Circular Linked List&lt;/em&gt;로 만들어 주는데&lt;up&gt;하이라이트 부분&lt;/up&gt; &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 생성할 때 말씀드린 것 처럼 &lt;em&gt;update state&lt;/em&gt;의 로직을 봐야 이해할 수 있기 때문에 여기서는 생략합니다.&lt;br&gt;
그리고 만들어진 &lt;em&gt;update&lt;/em&gt;를 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;의 tail pointer(&lt;code class=&quot;language-text&quot;&gt;last&lt;/code&gt;)에 추가해줍니다.&lt;/p&gt;
&lt;h3 id=&quot;5-불필요한-컴포넌트-리-렌더링-방지&quot;&gt;&lt;a href=&quot;#5-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A6%AC-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%A7%80&quot; aria-label=&quot;5 불필요한 컴포넌트 리 렌더링 방지 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 불필요한 컴포넌트 리-렌더링 방지&lt;/h3&gt;
&lt;p&gt;리액트는 이 시점에(&lt;down&gt;&lt;em&gt;idle&lt;/em&gt; 상태에서 업데이트가 발생한 상태&lt;/down&gt;) 성능 최적화를 위한 한가지 선택지가 있습니다.&lt;br&gt;
이전 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;를 통해 컴포넌트&lt;up&gt;fiber&lt;/up&gt;에 대한 &lt;em&gt;Work&lt;/em&gt;가 스케줄링 되어있지 않고 넘겨받은 &lt;em&gt;action&lt;/em&gt;의 결괏값이 현재 state와 같다면? 이때는 state가 변경된게 없으므로 더 이상 진행하지 않고 &lt;strong&gt;bail out&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// function dispatchAction(&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   fiber:,&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   queue:,&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   action,&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ) {&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; NoWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; NoWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; lastRenderedReducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedReducer&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lastRenderedReducer &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리는 이제 if 문의 조건을 이해할 수 있습니다. 왜 fiber와 alternate 모두 비교를 하는지에 대한.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;fiber&lt;/em&gt;에 대한 &lt;em&gt;Work&lt;/em&gt;가 스케줄링이 되면 &lt;em&gt;fiber&lt;/em&gt;에 &lt;code class=&quot;language-text&quot;&gt;expirationTime&lt;/code&gt;에 새겨집니다.
그리고 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 만들 때 &lt;code class=&quot;language-text&quot;&gt;lastRenderedReducer&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;basicStateReducer&lt;/code&gt;를 할당했었습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;basicStateReducer&lt;/code&gt;의 로직은 간단합니다. &lt;code class=&quot;language-text&quot;&gt;return typeof action === &amp;#39;function&amp;#39; ? action(state) : action;&lt;/code&gt;&lt;br&gt;
로직과 이름을 보고 다음과 같은 생각을 하신 분이 계실지는 모르겠지만, 이 &lt;em&gt;reducer&lt;/em&gt;는 &lt;code class=&quot;language-text&quot;&gt;useReduer&lt;/code&gt;를 사용할 때 넘겨주는 &lt;em&gt;reducer&lt;/em&gt; 함수가 할당되는 곳이며 &lt;em&gt;update state&lt;/em&gt;에서 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;useReducer&lt;/code&gt;와 같은 구현체를 공유합니다. 그러므로 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; 하나를 분석하면 &lt;code class=&quot;language-text&quot;&gt;useReducer&lt;/code&gt;도 함께 알 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// if (lastRenderedReducer !== null) {&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; currentState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastRenderedState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; eagerState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lastRenderedReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;currentState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;eagerReducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; lastRenderedReducer&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;eagerState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eagerState&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eagerState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; currentState&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;token function&quot;&gt;scheduleWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// }&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 state와 같지 않다면 VDOM을 재조정해줄 &lt;em&gt;Work&lt;/em&gt;를 스케줄링 합니다. 여러 번의 &lt;em&gt;setState&lt;/em&gt; 가 있어도 한 번만 스케줄링 되기 때문에 걱정은 안 하셔도 됩니다. &lt;code class=&quot;language-text&quot;&gt;scheduleWork()&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;scheduler&lt;/code&gt;에 대한 자세한 내용은 다음 포스트에서 다룹니다.&lt;/p&gt;
&lt;p&gt;이제 생략했던 &lt;em&gt;render phase update&lt;/em&gt;를 확인하도록 하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;6-컴포넌트-리-렌더링&quot;&gt;&lt;a href=&quot;#6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A6%AC-%EB%A0%8C%EB%8D%94%EB%A7%81&quot; aria-label=&quot;6 컴포넌트 리 렌더링 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 컴포넌트 리-렌더링&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;&lt;up&gt;&lt;code class=&quot;language-text&quot;&gt;dispatchAction&lt;/code&gt;&lt;/up&gt;의 주요 일 중 하나는 &lt;code class=&quot;language-text&quot;&gt;scheduleWork()&lt;/code&gt;를 통해 &lt;em&gt;render phase&lt;/em&gt;에 진입해서 업데이트를 VDOM에 적용시키는 겁니다. 그리고 &lt;em&gt;render phase update&lt;/em&gt;의 경우는 이미 VDOM 재조정 작업 중인 상황입니다. 그렇기 때문에 우리는 현재 오로지 업데이트를 적용한 자식 &lt;em&gt;reactElement&lt;/em&gt;만 필요합니다. 다른 건 필요가 없습니다. 그래서 업데이트를 적용한 컴포넌트를 실행해서 자식을 받아오는데 이 과정에서 추가적인 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 가 발생하면 이때 발생하는 &lt;code class=&quot;language-text&quot;&gt;setState()&lt;/code&gt;들을 몽땅 모았다가 바로 다시 컴포넌트를 실행해서 해당 업데이트들을 기반으로 자식 &lt;em&gt;reactElement&lt;/em&gt;를 다시 반환받습니다. 이 과정을 업데이트가 발생하지 않을 때까지 반복합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; dispatchAction&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  fiber&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; UpdateQueue&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  action&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// if (&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   fiber === currentlyRenderingFiber ||&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   (alternate !== null &amp;amp;&amp;amp; alternate === currentlyRenderingFiber)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ) {&lt;/span&gt;
  didScheduleRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 컴포넌트를 실행하는 renderWithHooks에게 재실행을 알려줄 플래그&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Update&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    expirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; renderExpirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    suspenseConfig&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 업데이트 결과를 담고 있는 action만 필요합니다.&lt;/span&gt;
    eagerReducer&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    eagerState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    next&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 업데이트를 저장할 맵&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; undefined&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    renderPhaseUpdates&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Append the update to the end of the list.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; lastRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lastRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      lastRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; lastRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    lastRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// else {&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   생략..&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//   scheduleWork(fiber, expirationTime);&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;renderWithHooks()&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;didScheduleRenderPhaseUpdate&lt;/code&gt;를 사용하는 코드는 바로 밑에서 확인하도록 하겠습니다.
훅 객체들은 고유의 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 가집니다. 그래서 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;를 키로 &lt;em&gt;render phase update&lt;/em&gt;들을 연결리스트로 저장해 놓습니다. 그리고 이 리스트는 컴포넌트 재실행 때 &lt;em&gt;update state&lt;/em&gt;에서 소비합니다.&lt;/p&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;didScheduleRenderPhaseUpdate&lt;/code&gt;를 사용하는 곳만 보고 &lt;em&gt;mount state&lt;/em&gt;를 마무리하도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; renderWithHooks()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;renderWithHooks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token parameter&quot;&gt;current&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  workInProgress&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  Component&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  refOrContext&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  nextRenderExpirationTime&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ExpirationTime&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// let children = Component(props, refOrContext)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;didScheduleRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      didScheduleRenderPhaseUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
      numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;

      &lt;span class=&quot;token comment&quot;&gt;//이하 updateState에서 사용되는 변수&lt;/span&gt;
      nextCurrentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
      nextWorkInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; firstWorkInProgressHook

      &lt;span class=&quot;token comment&quot;&gt;// 필요한 전역 변수 초기화&lt;/span&gt;
      currentHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
      workInProgressHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;

      ReactCurrentDispatcher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; HooksDispatcherOnUpdate &lt;span class=&quot;token comment&quot;&gt;// update state 구현체를 사용&lt;/span&gt;

      children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; refOrContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;didScheduleRenderPhaseUpdate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    renderPhaseUpdates &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
    numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// const renderedWork = currentlyRenderingFiber&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ReactCurrentDispatcher.current = ContextOnlyDispatcher&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;didScheduleRenderPhaseUpdate&lt;/code&gt;가 false 일 때까지 계속 컴포넌트를 재실행 합니다.&lt;br&gt;
훅을 사용하면서 많이 보셨을 메시지인 &lt;strong&gt;&lt;em&gt;“Too many re-renders. React limits the number of renders to prevent an infinite loop.”&lt;/em&gt;&lt;/strong&gt;도 여기서 증가시킨 &lt;code class=&quot;language-text&quot;&gt;numberOfReRenders&lt;/code&gt;을 기준으로 &lt;code class=&quot;language-text&quot;&gt;dispatchAction()&lt;/code&gt;에서 에러를 출력해줍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// reconciler &gt; ReactFiberHooks.js &gt; dispatchAction()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; dispatchAction&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  fiber&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  queue&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; UpdateQueue&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  action&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;invariant&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    numberOfReRenders &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;RE_RENDER_LIMIT&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Too many re-renders. React limits the number of renders to prevent &apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&apos;an infinite loop.&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;invariant&lt;/code&gt;는 첫 번째 인자가 false이면 두 번째 인자의 메세지로 에러를 뿜는 함수입니다.&lt;br&gt;
여기까지가 &lt;em&gt;mount state&lt;/em&gt; 입니다.&lt;/p&gt;
&lt;h3 id=&quot;7-정리&quot;&gt;&lt;a href=&quot;#7-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;7 정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 정리&lt;/h3&gt;
&lt;p&gt;이제 여러분은 다음과 같은 질문에 대답할 수 있어야 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;를 한번에 여러 번 실행하면 매 실행마다 렌더링 되나요?&lt;/li&gt;
&lt;li&gt;클릭을 통해 컴포넌트 상태를 업데이트시켰습니다. 그리고 변경된 상태를 기준으로 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;를 호출했어요. 그러면 클릭을 통한 상태 업데이트 때 한번, 추가적인 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 때 또 한 번. 이렇게 매번 렌더링 되나요?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이런 질문이 들어오면 일단 가장 먼저 질문자에게 해주어야 할 부분은 렌더링 단어의 의미를 명확하게 인식시키는 겁니다. 이 부분만 제대로 이해해도 개발자의 입장에서만 바라보던 것들을 리액트의 입장에서 바라볼 수 있도록 시야를 트여줍니다.&lt;/p&gt;
&lt;p&gt;이제 하나씩 답변을 해보겠습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;복수개의 훅 실행이 현재 state와 같다면 아무 일도 일어나지 않는다. 그게 아니면 한데 묶어서 다음 프레임 때 한 번만 컴포넌트가 재실행된다. 화면에 그려지는 것 또한 한 번이다.(&lt;down&gt;스케줄링도 한번&lt;/down&gt;)&lt;/li&gt;
&lt;li&gt;클릭을 통한 업데이트로 컴포넌트가 재실행 된다. 그리고 그 재실행에서 발생하는 추가적인 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;는 1번처럼 묶어서 한 번만 실행한다.&lt;br&gt;
여기서 업데이트가 발생하지 않을 때까지 계속해서 함수를 재실행한다. 결국, 최소 2번 최대 25번(&lt;down&gt;RE&lt;em&gt;RENDER&lt;/em&gt;LIMIT = 25&lt;/down&gt;) 컴포넌트가 재 실행될 수 있다. 그리고 화면은 1번과 마찬가지로 한 번만 그려진다.&lt;br&gt;
이 사이클은 &lt;em&gt;render phase&lt;/em&gt;임을 유의해라. &lt;em&gt;commit phase&lt;/em&gt;가 아니면 단지 in-memory 객체만 끄적인 것이지 아무 변화도 일어나지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기까지 이해가 가시나요? 그러면 다행이지만 그렇지 않다면 가장 이해하기 쉬운 방법은 위 내용을 토대로 직접 코드를 작성해서 디버깅을 해보는 것입니다.&lt;/p&gt;
&lt;p&gt;다음은 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;를 통해 &lt;code class=&quot;language-text&quot;&gt;queue&lt;/code&gt;에 저장해두었던 &lt;code class=&quot;language-text&quot;&gt;update&lt;/code&gt;들을 훅이 어떻게 컴포넌트에 적용시켜 실행하는지 알아보도록 하겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-intro/&quot;&gt;React 톺아보기- 02. Intro&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-hooks_2/&quot;&gt;React 톺아보기- 03. Hooks_2&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 02. Intro]]></title><description><![CDATA[모든 설명은 v16.12.…]]></description><link>https://github.com/goidle/react/in-depth-react-intro/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-intro/</guid><pubDate>Tue, 09 Jun 2020 09:20:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번 포스트에서는 사전지식을 좀 더 자세하게 다루도록 하겠습니다.&lt;/p&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 790px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 59.05017921146953%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACGUlEQVQoz2VTia6bMBDk/7+vlZp3hCPB3GDjEwKZjp0+6bW1ZK3XZmdnZ5cMXM/nMxrs+w69rpjnGUopOOfgvU9Wa41xHLHyPfpfb6tasSwLpJTpLotgX4AhBIItEKJB38dgDWMMLD9cGFDXAhOTRd8Ym5LE5EIIdF2PlX6Gb8u4gKLz+PHR4b0mI2kRnIaSC7wjwEoWRkMuE5nJVzJrk/XeJZud55moPx4PZg649Q7XWqLqLc8WZaNQiAX1YFC2CmJytBrNsMISIIJEecyfcxYzRMpRH+s8GgbE3c4eda/xeZ9xKUfkjcZVrKhHn0D7OTJ7SRJ1/WKaRWZRC+8DNfTYWKLTMpW6e2rEsq9C4b3s8UbgYTH8RpGdYpz5H/BfDcveI29tstUQzw6XSuKdu+wC7tOBvNvI1BFUp+b8BbhtW3Jiy419ldLPhkxsOg/s4jAI9GOLWtzQdjXladn1KVX2XcPoZxFoGEbMnKUIfjw2BG/x2AP2LeAMPeCuCPINevwJv1xw2g8cvoEPG/bHTvtqaozP4jCrNAIWx+45jCUBcmCrsKs32OkXwQigczwt3/Ya8BVO3+E4Tvy7UlOmaUo67GQnxgJ5fUHVfnBQOdx2RCcrjk2e7u/dZ/KVnWBZyX28oWgK3IYKs55ef0oq9Tiw7Ruq7oZcFOxsDqUVVna7lS3vq3RfcDdLA2kktNUEy3mXc3avGOSA30vklEj6RoQzAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;react lifescycle&quot; title=&quot;react lifescycle&quot; src=&quot;/static/83aa2072b273a11e7b733979b439d735/c94d1/react-lifescycle.png&quot; srcset=&quot;/static/83aa2072b273a11e7b733979b439d735/0780f/react-lifescycle.png 198w,
/static/83aa2072b273a11e7b733979b439d735/47b26/react-lifescycle.png 395w,
/static/83aa2072b273a11e7b733979b439d735/c94d1/react-lifescycle.png 790w,
/static/83aa2072b273a11e7b733979b439d735/32b35/react-lifescycle.png 1116w&quot; sizes=&quot;(max-width: 790px) 100vw, 790px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
&lt;p&gt;위 표는 클래스의 라이프 사이클을 나타내는 표이며 오다가다 많이 보셨을 겁니다.&lt;br&gt;
표 왼쪽을 보면 리액트를 개발하면서 접해보지 못한 단어들이 보입니다.&lt;br&gt;
&lt;em&gt;“Render phase”&lt;/em&gt;, &lt;em&gt;“Commit phase”&lt;/em&gt;&lt;br&gt;
표만봐서는 설명에서 언급되는 &lt;em&gt;side effect&lt;/em&gt;가 무엇을 뜻하는 것이고 또 무엇이 중지되고 다시 시작될 수 있는지 이해하기가 어렵습니다.&lt;/p&gt;
&lt;h2 id=&quot;render-phase&quot;&gt;&lt;a href=&quot;#render-phase&quot; aria-label=&quot;render phase permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Render phase&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Render phase&lt;/em&gt;는 쉽게 말해 VDOM 조작 단계라고 생각하시면 됩니다.&lt;br&gt;
리액트는 변경점이 생겼을 때 다르게 말하면 react element가 추가, 수정, 삭제 등이 발생했을 때 이를 VDOM에 반영하기 위해 &lt;u&gt;&lt;strong&gt;&lt;em&gt;VDOM 재조정 작업(이하 Work)&lt;/em&gt;&lt;/strong&gt;&lt;/u&gt;을 &lt;em&gt;scheduler&lt;/em&gt;을 통해 실행시킵니다.&lt;/p&gt;
&lt;p&gt;이 VDOM을 재조정하는 일련의 과정을 &lt;em&gt;Render phase&lt;/em&gt;라고 부릅니다. 재조정을 담당하는 &lt;em&gt;reconciler&lt;/em&gt;의 시스템이 stack 기반에서 fiber architecture로 넘어가면서 이 과정을 abort, stop, restart 할 수 있게 되었습니다.&lt;br&gt;
이 기능은
&lt;a href=&quot;https://reactjs.org/docs/concurrent-mode-adoption.html#migration-step-blocking-mode&quot; target=&quot;_blank&quot;&gt;concurrent mode&lt;/a&gt;
에서만 비동기로 함께 이루어지며 legacy mode(현재 우리가 일반적으로 사용하는 ReactDOM.render)에서는 위 기능 없이 동기적으로 &lt;em&gt;Render phase&lt;/em&gt;가 동작하게 됩니다.&lt;/p&gt;
&lt;p&gt;컴포넌트 실행은 &lt;em&gt;Render phase&lt;/em&gt;에서 실행되며 위 내용으로 짐작할 수 있듯이 컴포넌트 실행이 곧 화면에 페인트 된다는 뜻은 아닙니다.
이전 포스트에서 언급한 용어인 렌더링에 빗대어 보자면 컴포넌트가 리-렌더링 된다는 말은 컴포넌트가 실행되고 그 결과가 VDOM에 반영된다는 거지 DOM에 마운트되어 페인트 된다는 뜻이 아니라는 겁니다.&lt;/p&gt;
&lt;h2 id=&quot;commit-phase&quot;&gt;&lt;a href=&quot;#commit-phase&quot; aria-label=&quot;commit phase permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Commit phase&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Commit phase&lt;/em&gt;는 &lt;em&gt;Render phase&lt;/em&gt;에서 재조정된 VDOM을 DOM에 마운트시키고 라이프 사이클을 실행하는 단계입니다.
여기서도 마찬가지로 DOM에 마운트된다는 것이지 페인트 된다는 건 아닙니다.&lt;/p&gt;
&lt;p&gt;이 단계는 모드와는 상관없이 항상 일관적인 화면 업데이트를 위해 동기적으로 실행 됩니다. 동기적으로 실행된다는 건 DOM 조작을 Call stack을 한 번도 비우지 않고 일괄처리한다는 뜻입니다. 그러므로 &lt;em&gt;Commit phase&lt;/em&gt; 중간에 페인트 되지 않습니다. 이 단계가 끝나고 리액트에서 Call stack을 비워줘야지만 브라우저에서 화면을 페인트 할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;그 다음은 자주 언급되는 VDOM을 알아보겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;vdom&quot;&gt;&lt;a href=&quot;#vdom&quot; aria-label=&quot;vdom permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;VDOM&lt;/h2&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 634px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 143.69085173501577%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAEOElEQVRIx31VaVMbRxDl/1cZCXOksKGAKrv4EmOBDSGxY9kcTkglgSRCEgh0sTr2vne150vPiBUSEnRV1+xcb1/PdL+Zw5ilacpbx3VhOw58f4AoipAkCR8zTQuO40LTDXi+P9qT7WM2Nw6W3E9UqjUcfiriy9cTHBx+xq/FY/zx5zl2Cvu8/2b7R5Qr13wt+9k46NwshsyCIOTs/MGAswvDiPdD8iiOZ+6ZYsjMNE1IkgRRFKEoCndd16Gqw9axbSg0L/V6MKj/OOwpQJ/OxjAM2LSRuWVZvC8IAmzPg0NgSqkEg1qPmM8EzDqP6Y+bS2DMom4XqarOCPkR4HN+cnyMt9vbEGo1pLKMmN082Fx2IckDw6dYZePs3FZXVzE/P4+fDw/xnLE9nKETWhA9AYrfR5zGCOOQPCAWCfpSH4XdAlZfraJyVeEb7cBAz2lDsBvou3foum1Ygf4Qco8GWnaNT+oDGU5igpIF10IVl80SZK+LlnYDLZSh+QrUQIQa99H37yA4DbTtW94mRIYDGoE6Qb3VbOGqegWZUmc4T4wINDPHclD65xK+OxiN2aGBIB4MAfWBwjvMms0mFhYWsJCbx28XJVzrKb7U+9i/buGi5+LvjoN3799jZXkJu3u77GqQkQqT4AGQnRmzer2OxcUl/LCyjOO//kONAE/bIj7V2yhLPm4UD+92drC0soJCoTBiaATaJGCUhKPJi/Nz/Ht6OuprvoaO02GVy/syVc/Rx4+wKOGzFDQfA8Yp5VacQFE1nipUf4hM2hClMEMdktfh4bmuB5nWuO02HaaD+L5azGmGEc+jMAx5/ULTkFICM1IWAcp+lycwUxeLlWSrNVQbtmY24DDkmJTkw4c9HOztkeIML6prK3SWdyOVKVcqeLOxgUaj8XTI2aWUy2Xk8nl+y/vffsdZN8HB9R12SCNPWg6+3hhY39hELpfD1tbWqKKMacAhw77Yx8bmJjbW11BrCdDpPyWqlrNuE307gBumKBaLWHz5EkdHR7MZalQdCWKIsgJR6MAlqXLu1SU7H9F7uGX2BFQq1YlimAJkv5EUFQ4pCqns1GKJKiXhqgIMSMU1ujSm4FliTwDasY6+LKJE+RcrD2UoSiKajRa/5QyQGcuEIAi4z2R4pzTwev0V8vkFfP9+DHhU+MItXq+tIT+fx7ezIsxE4RnwlMxNANZ7NSwuL5Lm5fD5F9K8xELr9hJLy8vIvcjhpyJVRaoSYIRZgjwjZAPlapnf2ngY1WqV1PoUqitRYvdGIY8/GTMBzVDDIPThe/79WxuP3gjXduHEJkS3MwH4mOFEHmq+TC+cRZs9KqVkxNCjuvVsnxjKkPzus/JvkmKPAFVf4sltByaXdyekltyibzbG5lnITObZc2Hfz2fO1qu+iJj0gAOyOnYjG17kcGff7tg3+zNbnI2Pe7YmE+j/AYmfmLxmz5QpAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;vDOM&quot; title=&quot;vDOM&quot; src=&quot;/static/258b43ce623e7b6340fc6aed969199ed/153fa/vDOM.png&quot; srcset=&quot;/static/258b43ce623e7b6340fc6aed969199ed/0780f/vDOM.png 198w,
/static/258b43ce623e7b6340fc6aed969199ed/47b26/vDOM.png 395w,
/static/258b43ce623e7b6340fc6aed969199ed/153fa/vDOM.png 634w&quot; sizes=&quot;(max-width: 634px) 100vw, 634px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
&lt;p&gt;리액트는 VDOM을 더블 버퍼링 형태로 관리합니다. DOM에 마운트된 &lt;em&gt;current&lt;/em&gt;와 &lt;em&gt;Render phase&lt;/em&gt;에서 작업 중인 &lt;em&gt;workInProgress&lt;/em&gt;로 나뉘어 있습니다. 이 &lt;em&gt;workInProgress&lt;/em&gt;는 &lt;em&gt;Commit phase&lt;/em&gt;를 지나면 &lt;em&gt;current&lt;/em&gt;로 관리됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiberWorkLoop.js &gt; commitRootImpl()&lt;/span&gt;
root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; finishedWork&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이렇듯 더블 버퍼링 형태이기 때문에 리액트는 &lt;em&gt;workInProgress&lt;/em&gt;에 작업을 하다가도 언제든지 버리고 처음부터 다시 작업하던지 아니면 중지시켰다가 다시 시작하는 등 작업 우선순위에 맞게 유연하게 대처할 수 있기에 사용자 경험을 최우선적으로 고려할 수 있습니다.&lt;/p&gt;
&lt;p&gt;위 이미지에서 화살표는 생략된 게 없습니다. 자세히 보면 &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt;는 &lt;em&gt;current&lt;/em&gt;만 참조하고 있습니다. &lt;em&gt;workInProgress&lt;/em&gt;가 만들어지는 방식은 &lt;em&gt;current&lt;/em&gt;에서 자기 복제하여 서로 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;로 참조하는 방식입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiberWorkLoop.js &gt; prepareFreshStack()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; workInProgress &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createWorkInProgress&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; expirationTime&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
workInProgress &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token comment&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;VDOM node(이하 &lt;em&gt;fiber&lt;/em&gt;)는 자식을 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt;로 참조하는데 first child만 참조합니다. 나머지 자식들은 이전 형제가 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt;으로 참조하고 있습니다. 그리고 모든 자식은 부모를 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;으로 참조합니다.&lt;/p&gt;
&lt;h2 id=&quot;reactelement&quot;&gt;&lt;a href=&quot;#reactelement&quot; aria-label=&quot;reactelement permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;reactElement&lt;/h2&gt;
&lt;p&gt;일반적으로 개발자 대부분은 react 코어 패키지에 있는 모듈들만 사용하게 됩니다. 그리고 작업 결과물은 &lt;em&gt;reactElement&lt;/em&gt;로 만들어집니다. &lt;em&gt;reactElement&lt;/em&gt;는 컴포넌트 정보만을 담고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react &gt; ReactElement.js &gt; createElement()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// This tag allows us to uniquely identify this as a React Element&lt;/span&gt;
  $$&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;REACT_ELEMENT_TYPE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Built-in properties that belong on the element&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  key&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  ref&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; ref&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Record the component responsible for creating this element.&lt;/span&gt;
  _owner&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; owner&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리가 작성하는 JSX는 babel을 통해 react.createElement로 변환됩니다.&lt;br&gt;
type에 함수형 컴포넌트는 그 함수 자체가 &lt;em&gt;Host Component&lt;/em&gt;는 tag 이름이 들어갑니다.&lt;br&gt;
나머지는 child 포함 죄다 props로 들어갑니다.
리액트 코어는 이게 끝입니다.&lt;/p&gt;
&lt;h2 id=&quot;fiber&quot;&gt;&lt;a href=&quot;#fiber&quot; aria-label=&quot;fiber permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;fiber&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;reactElement&lt;/em&gt;를 VDOM에 올려놓아야 합니다. 그 확장을 fiber가 해줍니다.&lt;br&gt;
fiber는 VDOM node이며 모든 정보를 담고 있다고 생각하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiber.js &gt; createFiberFromElement()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// element === reactElement&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; pendingProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createFiberFromTypeAndProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  pendingProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  owner&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  mode&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  expirationTime&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiber.js &gt; createFiberFromTypeAndProps()&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;createFiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiberTag&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pendingProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiber.js &gt; createFiber()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FiberNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;tag&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pendingProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// react-reconciler &gt; ReactFiber.js &gt; FiberNode()&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;FiberNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Instance&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tag&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;elementType &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 추후에 reactElement의 type을 할당&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 추후에 reactElement의 type을 할당&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stateNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// DOM에 마운트될 html element&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 부모 fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자식 fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 형제 fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자식들 중 자신의 위치&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pendingProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pendingProps&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// workInProgress는 아직 작업이 끝난 상태가 아니므로 props를 pending으로 관리&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// render phase가 끝나면 pendingProps는 memoizedProps로 관리&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;updateQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 라이프사이클과 관련된 queue&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;memoizedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// hook 객체 리스트&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Effects&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoEffect&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// fiber가 가지고 있는 side effect 종류를 기록&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 이하 side effect list 관련&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nextEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;expirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoWork&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Work의 우선순위와 개별 Work를 나타내는 척도&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;childExpirationTime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoWork&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 자식으로부터 Work가 만들어질 경우 사용됨&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 반대편 fiber를 참조&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reactElement가 개발자가 작성한 컴포넌트 겉 정보를 담고 있다면 fiber는 컴포넌트 내부에서 사용된 훅, 라이프 사이클 등 실질적으로 컴포넌트를 실행한 후에 발생하는 모든 정보를 담고 있습니다. Work와 관련된 정보도 모두 포함되기 때문에 fiber 자체를 실제 코드에서는 Work라고 표현되기도 합니다.&lt;br&gt;
너무 많은 정보가 있기 때문에 이런 게 있구나 하고 훑어만 보시면 됩니다. 추후에 하나도 빠짐없이 다루게 될 것입니다.&lt;/p&gt;
&lt;h2 id=&quot;side-effect&quot;&gt;&lt;a href=&quot;#side-effect&quot; aria-label=&quot;side effect permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;side effect&lt;/h2&gt;
&lt;p&gt;쉽게 생각해서 DOM에 변경점을 만들거나 혹은 변경점을 만들어낼 수도 있는 작업을 side effect라고 생각하면 됩니다(또는 effect).
아래는 리액트에서 사용되는 side effect tag입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Don&apos;t change these two values. They&apos;re used by React Dev Tools.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; NoEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*              */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; PerformedWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*         */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000001&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// You can change the rest (and add more).&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Placement &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*             */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000010&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Update &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*                */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; PlacementAndUpdate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*    */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000000110&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Deletion &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*              */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000001000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; ContentReset &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*          */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0000000010000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Passive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/*               */&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b0001000000000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; 생략&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 tag는 fiber의 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt;에 저장되며 side effect를 가지고 있는 fiber는 side effect list로 관리됩니다.
좀 더 자세히 설명하자면 side effect는 여러 종류가 있기 때문에 그 모든 걸 담고 있는 fiber 그 자체를 effect로 관리 합니다.&lt;/p&gt;
&lt;p&gt;그리고 이 effect들은 연결리스트로 구성됩니다. 위 fiber 객체의 &lt;code class=&quot;language-text&quot;&gt;nextEffect&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;firstEffect&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;lastEffect&lt;/code&gt;가 이를 위한 속성들입니다. 이 속성들만 봐도 알 수 있듯이 연결 리스트 노드는 fiber 그 자체임을 알 수 있습니다. 그리고 이 정보는 부모로 전달되며 부모는 모든 자식의 effect를 list로 가지고 있게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 자식의 side effect를 부모로 올린다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nextEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 자신에게도 side effect가 있다면 자기 자신도 effect list에 추가해준다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; PerformedWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nextEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firstEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  returnFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lastEffect &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; workInProgress
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;최종적으로 root가 모든 effect를 들고 있게 됩니다.&lt;br&gt;
root의 effect 연결 리스트는 &lt;em&gt;Commit phase&lt;/em&gt;에서 소비되면서 effect 종류에 맞는 시점에 특정 로직을 통해 처리됩니다.&lt;br&gt;
로직 순서를 보면 부모로 리스트를 올릴 때 자식을 먼저 연결하고 자신은 맨 마지막에 추가됩니다.&lt;br&gt;
중요한 부분은 아니지만 &lt;em&gt;Coomit phase&lt;/em&gt;에서는 리스트 순서대로 처리되기 때문에 dfs(깊이 우선 탐색)의 순서대로 effect가 적용됨을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;tag는 Bit Masking으로 관리됩니다. 모르시는 분들을 위해 잠깐만 다루고 가겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;bit-masking&quot;&gt;&lt;a href=&quot;#bit-masking&quot; aria-label=&quot;bit masking permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Bit Masking&lt;/h2&gt;
&lt;p&gt;비트 연산을 통해서 상태를 관리한다고 보시면 됩니다.&lt;br&gt;
리액트에서는 현재 실행되고 있는 환경을 context로 관리합니다. 이 context를 통해 Bit Masking을 알아보겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;비트 연산자에 대한 설명은 생략하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정의된 context를 보면 render context는 16, commit context는 32로 정의되어 있습니다.&lt;br&gt;
이를 2진수로 변환하면 각각 10000, 100000 입니다.&lt;br&gt;
즉 2진수로 5번째 자리가 1이면 &lt;em&gt;Render phase&lt;/em&gt;란 뜻입니다.&lt;br&gt;
이제 이 2진수를 통해서 어떻게 상태를 확인하고 추가하는지 알아보겠습니다.&lt;/p&gt;
&lt;p&gt;확인은 and(&amp;#x26;)연산, 추가는 or(|)연산, 삭제는 xor(~)연산을 이용합니다.&lt;/p&gt;
&lt;p&gt;다음과 같이 정의되어 있다고 가정합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; NoContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b00&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; RenderContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b01&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; CommitContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0b10&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; executionContext &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; NoContext &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Render phase&lt;/em&gt;에 접어들어 현재 context에 render context를 추가한다면 다음과 같습니다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;|=&lt;/span&gt; RenderContext &lt;span class=&quot;token comment&quot;&gt;// 00 | 01 =&gt; 01&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 context에 따라서 분기 처리를 해야 한다면 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; RenderContext &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; NoContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 01 &amp;amp; 01 !== 00&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Render phase&lt;/em&gt;가 끝나고 &lt;em&gt;Commit phase&lt;/em&gt;에 접어들 때는 이전 context를 지우고 다음 context를 추가해야 합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;~&lt;/span&gt;RenderContext &lt;span class=&quot;token comment&quot;&gt;// 01 &amp;amp;  10 =&gt; 00&lt;/span&gt;
executionContext &lt;span class=&quot;token operator&quot;&gt;|=&lt;/span&gt; CommitContext &lt;span class=&quot;token comment&quot;&gt;// 00 | 10 =&gt; 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런식으로 연산은 비트 연산으로 저장은 십진수로 상태 값을 쉽게 관리할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&quot;리액트-실제-사용-사례&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80&quot; aria-label=&quot;리액트 실제 사용 사례 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리액트 실제 사용 사례&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;executionContext &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;RenderContext &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; CommitContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; NoContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//현재 context가 Render phase이거나 Commit phase이면&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;msToExpirationTime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;사전 지식은 이 정도면 충분합니다.&lt;br&gt;
이해되지 않는다고 좌절할 필요는 없습니다. 그냥 이런 게 있구나 하고 기억만 해두시면 됩니다. 우리는 개발자이니 백번 말로 설명하는 것보단 한 번 코드로 보는 게 더 이해하기 쉬울 거라 생각합니다.&lt;/p&gt;
&lt;span class=&quot;gatsby-resp-image-wrapper&quot; style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 568px;&quot;&gt;
      &lt;span class=&quot;gatsby-resp-image-background-image&quot; style=&quot;padding-bottom: 21.12676056338028%; position: relative; bottom: 0; left: 0; background-image: url(&amp;apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAAlklEQVQY001Pyw6EIAz0pDwl3MFIRAkJB/7/57qZburuYTJ9TKft4pwjrTWVUmjOSSkljp/noeu6GL13rt33zXlrjXVg1I0xBJ9932kRw5wzjTFYeBwHD8MIdcTneTLQgyl0WIqatfZnKIlSitZ1ZRZgMyAaALn0t21jlt73QuveAe/9yyEEqrXyS2C8h4tijK9O8H/hB7liY9htm+ykAAAAAElFTkSuQmCC&amp;apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&quot;gatsby-resp-image-image&quot; alt=&quot;showMeTheCode&quot; title=&quot;showMeTheCode&quot; src=&quot;/static/e6117eec2a6fedd9a10a636574357cc2/870c3/showMeTheCode.png&quot; srcset=&quot;/static/e6117eec2a6fedd9a10a636574357cc2/0780f/showMeTheCode.png 198w,
/static/e6117eec2a6fedd9a10a636574357cc2/47b26/showMeTheCode.png 395w,
/static/e6117eec2a6fedd9a10a636574357cc2/870c3/showMeTheCode.png 568w&quot; sizes=&quot;(max-width: 568px) 100vw, 568px&quot; loading=&quot;lazy&quot;&gt;
    &lt;/span&gt;
&lt;p&gt;다음 포스트에서 코드와 함께 본격적으로 리액트를 분석해보도록 하겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-preview/&quot;&gt;React 톺아보기- 01. Preview&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-hooks_1/&quot;&gt;React 톺아보기- 03. Hooks_1&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[React 톺아보기- 01. Preview]]></title><description><![CDATA[모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.…]]></description><link>https://github.com/goidle/react/in-depth-react-preview/</link><guid isPermaLink="false">https://github.com/goidle/react/in-depth-react-preview/</guid><pubDate>Tue, 09 Jun 2020 09:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-들어가기에-앞서&quot;&gt;&lt;a href=&quot;#1-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C&quot; aria-label=&quot;1 들어가기에 앞서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 들어가기에 앞서&lt;/h1&gt;
&lt;p&gt;먼저 이 시리즈는 리액트 사용법에 대한 글이 아닙니다.&lt;br&gt;
리액트를 통해 프로젝트를 진행한 경험이 있고 동작 방식을 어렴풋이 이해하기는 하지만 여전히 리액트가 마법처럼 느껴지고 응용, 에러 디버깅 등에 어려움을 겪는 사람들을 위해 작성하였습니다.&lt;/p&gt;
&lt;p&gt;시리즈의 내용은 사용자의 상호작용으로부터 훅을 통해 컴포넌트가 업데이트되고 DOM에 마운트되기 까지의 일련의 과정을 실제 코드를 통해 분석해 나가게 될 것입니다.&lt;/p&gt;
&lt;p&gt;시리즈를 끝내고 나면 Virtual DOM이 무엇인지, 컴포넌트 상태가 바뀌었을 때 리액트는 어떻게 해당 컴포넌트를 리-렌더링시키는지, 어떻게 변경된 부분만 DOM에 마운트 되는지, hook은 컴포넌트와 어떤 방식으로 매핑되어 사용되는지, 이벤트 구현은 어떻게 되어 있는지 등 리액트의 전반적인 큰 줄기의 흐름을 알게 될 것입니다.&lt;/p&gt;
&lt;p&gt;들어가기에 앞서 당부 드리고 싶은 말씀은 코드를 분석할 때 필히 분석 대상이 어떤 패키지 밑에 있는 것이고 모듈과 함수 이름은 무엇인지 먼저 보고 머리에 담아둔 상태로 코드를 보시기 바랍니다.
리액트는 역할별로 많은 모듈과 동작에 맞는 함수들을 만들어 놓았습니다. 코드만 보고 넘어가게 된다면 리액트의 구조로 코드를 바라보기가 어려우며 이는 추후에 지금 내가 어디를 보고 있으며 어떠한 흐름으로 여기까지 왔는지 이해하기가 힘듭니다. 이해도 제대로 못 한 상태로 시간은 시간대로 날리고 가장 큰 걱정은 혼자 궁금한 부분을 분석하고 싶을 때 많은 어려움을 겪게 될 것입니다.&lt;/p&gt;
&lt;p&gt;여기서 언급되는 내용을 몰라도 리액트 프로젝트를 진행하는데 아무런 영향이 없지만, 이 시리즈를 통해 리액트에 대한 막연한 인식의 허들을 낮추고 궁금증을 가지고 있는 부분을 거기서 멈추지 않고 혼자 코드를 보면서 분석해보려는 의지를 심어 드리기 위하여 이 글을 작성해 봅니다.&lt;/p&gt;
&lt;h1 id=&quot;2-패키지-구조&quot;&gt;&lt;a href=&quot;#2-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;2 패키지 구조 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 패키지 구조&lt;/h1&gt;
&lt;p&gt;리액트는 react 코어, 플랫폼과 관련된 renderer, VDOM과 관련된 reconciler, 작업 실행기인 scheduler 그리고 event로 나눌 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;react&quot;&gt;&lt;a href=&quot;#react&quot; aria-label=&quot;react permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;react&lt;/h3&gt;
&lt;p&gt;컴포넌트 정의와 관련된 API가 있는 패키지입니다.&lt;br&gt;
대표적으로 &lt;em&gt;reactElement&lt;/em&gt;를 만드는 &lt;code class=&quot;language-text&quot;&gt;React.createElement&lt;/code&gt;가 있으며 개발자에게 다른 패키지의 모듈을 제공할 수 있도록 중간 다리 역할을 하는 모듈들만 위치해 있습니다.&lt;br&gt;
이 코어는 다른 패키지에 의존성을 가지고 있지 않기 때문에 여러 플랫폼에 올려서 사용할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;renderer&quot;&gt;&lt;a href=&quot;#renderer&quot; aria-label=&quot;renderer permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;renderer&lt;/h3&gt;
&lt;p&gt;플랫폼과 관련된 네이티브 로직이 위치해 있습니다. react-dom, react-native-renderer가 여기에 해당합니다.&lt;br&gt;
플랫폼과 react를 연결하며 실제적으로 플랫폼에 컴포넌트를 mount합니다. reconciler와 lagacy-event 패키지에 의존성을 가지고 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;eventlegacy-events&quot;&gt;&lt;a href=&quot;#eventlegacy-events&quot; aria-label=&quot;eventlegacy events permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;event(legacy-events)&lt;/h3&gt;
&lt;p&gt;SyntheticEvent라는 이름으로 구현되어 있습니다. native event를 wrapping하며 개발자가 native event를 사용하기 전 리액트에서 추가적인 제어를 하기 위해 따로 개발된 이벤트입니다.&lt;br&gt;
현재 리액트에서 제일 바꾸고 싶어 하는 영역으로 보이며 다른 시스템으로 변경하다 중단된 걸 보아하니 쉽지 않아 보입니다.&lt;/p&gt;
&lt;h3 id=&quot;scheduler&quot;&gt;&lt;a href=&quot;#scheduler&quot; aria-label=&quot;scheduler permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;scheduler&lt;/h3&gt;
&lt;p&gt;리액트는 여러가지 이유로 작업을 비동기로 실행시켜야 합니다. 이 작업은 Task란 이름으로 우선순위에 따라 스케쥴링 됩니다.&lt;br&gt;
scheduler는 자신에게 할당된 시간 내에 Task를 동기적으로 최소 힙 자료구조에서 꺼내 실행합니다.&lt;br&gt;
이 패키지는 호스트 비동기 API에 의존적입니다.&lt;/p&gt;
&lt;h3 id=&quot;reconciler&quot;&gt;&lt;a href=&quot;#reconciler&quot; aria-label=&quot;reconciler permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;reconciler&lt;/h3&gt;
&lt;p&gt;리액트의 핵심 패키지입니다.&lt;br&gt;
그만큼 여러 고민과 노력이 들어가 있고 이 시리즈에서 가장 많은 시간을 보내게 될 패키지입니다.&lt;br&gt;
v15 이전에는 stack기반 구현이었다면 v16부터는 몇 년간의 연구 끝에 fiber architecture를 도입했습니다.&lt;br&gt;
VDOM node에 해당하는 fiber, VDOM 생성과 순회, diff 알고리즘 등 중요한 기능들이 위치해 있습니다.&lt;/p&gt;
&lt;h1 id=&quot;3-용어-정리&quot;&gt;&lt;a href=&quot;#3-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;3 용어 정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 용어 정리&lt;/h1&gt;
&lt;h3 id=&quot;컴포넌트&quot;&gt;&lt;a href=&quot;#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8&quot; aria-label=&quot;컴포넌트 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;컴포넌트&lt;/h3&gt;
&lt;p&gt;리액트에서는 여러 종류의 컴포넌트가 있습니다. 자체 제공하는 컴포넌트, 사용자 정의 컴포넌트, 플랫폼 컴포넌트 등
플랫폼 컴포넌트는 &lt;em&gt;Host Component&lt;/em&gt;, 사용자 정의 컴포넌트는 &lt;em&gt;Custom Component&lt;/em&gt; , VDOM의 최상단 노드는 &lt;em&gt;Host Root&lt;/em&gt;라고 명칭 하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;렌더링&quot;&gt;&lt;a href=&quot;#%EB%A0%8C%EB%8D%94%EB%A7%81&quot; aria-label=&quot;렌더링 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;렌더링&lt;/h3&gt;
&lt;p&gt;일반적으로 컴포넌트의 실행을 렌더링이라고 말합니다. 하지만 세부 구현 사항으로 내려가면 여러 단계가 더 존재하기 때문에 용어 혼동을 방지하기 위해 재정의하고 가겠습니다.&lt;/p&gt;
&lt;p&gt;컴포넌트 실행은 reconciler에서 합니다. 그 후 VDOM 작업이 들어가고 DOM에 삽입시킵니다.&lt;br&gt;
다시 말해서 컴포넌트 실행과 DOM 삽입은 별개라는 뜻입니다.&lt;br&gt;
그리고 DOM에 삽입하는 것과 화면에 그려지는 것 또한 마찬가지로 별개입니다.&lt;/p&gt;
&lt;p&gt;앞으로 렌더링은 컴포넌트가 실행되어 &lt;em&gt;reactElement&lt;/em&gt;를 반환하고 VDOM에 적용되는 일련의 과정을 일컫는다고 하겠습니다.&lt;br&gt;
컴포넌트 실행은 그저 함수 ‘호출’로만 생각하면 됩니다. &lt;strong&gt;&lt;em&gt;reactElement를 반환한다.&lt;/em&gt;&lt;/strong&gt; 그 이상 그 이하도 아닙니다.&lt;br&gt;
VDOM을 DOM에 삽입하는 것을 마운트 브라우저가 화면에 그리는 걸 페인트라 정의하겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;virtual-dom&quot;&gt;&lt;a href=&quot;#virtual-dom&quot; aria-label=&quot;virtual dom permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Virtual DOM&lt;/h3&gt;
&lt;p&gt;이하 VDOM으로 명칭&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;reactElement&lt;/em&gt; , &lt;em&gt;fiber&lt;/em&gt;&lt;br&gt;
&lt;em&gt;reactElement&lt;/em&gt;는 컴포넌트의 type, props만을 가진 객체입니다. 컴포넌트가 반환하는 자식이 &lt;em&gt;reactElement&lt;/em&gt;입니다.&lt;br&gt;
VDOM의 node는 &lt;em&gt;fiber&lt;/em&gt;라고 불리는 객체입니다. 이 객체는 컴포넌트가 반환한 &lt;em&gt;reactElement&lt;/em&gt;를 VDOM에 올리기 위해 확장시켜주는 객체입니다.&lt;br&gt;
이 &lt;em&gt;fiber&lt;/em&gt;를 통해 컴포넌트의 state, hook, life cycle 등 대부분이 관리됩니다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;current&lt;/em&gt;, &lt;em&gt;workInProgress&lt;/em&gt;&lt;br&gt;
리액트는 더블 버퍼링 형태로 VDOM을 두개 가지고 있습니다.&lt;br&gt;
&lt;em&gt;current&lt;/em&gt;는 마운트가 끝난 트리이며 &lt;em&gt;workInProgress&lt;/em&gt;는 업데이트가 적용 중인 트리입니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;더 많은 용어들이 있지만 크게 혼동되는 부분만 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;목록&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;02&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-intro/&quot;&gt;React 톺아보기- 02. Intro&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[Redux 톺아보기]]></title><description><![CDATA[혹시 궁금해봤니❓ Redux를 사용하면서 다음과 같은 물음을 가진 경험이 있습니까? 나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것
일까? redux…]]></description><link>https://github.com/goidle/redux/in-depth-redux/</link><guid isPermaLink="false">https://github.com/goidle/redux/in-depth-redux/</guid><pubDate>Wed, 25 Dec 2019 22:40:13 GMT</pubDate><content:encoded>&lt;img src=&quot;/5c7392a91f8cd5d997137f6b4a36870b/logo.svg&quot; height=&quot;350&quot; width=&quot;100%&quot;&gt;
&lt;h2 id=&quot;혹시-궁금해봤니&quot;&gt;&lt;a href=&quot;#%ED%98%B9%EC%8B%9C-%EA%B6%81%EA%B8%88%ED%95%B4%EB%B4%A4%EB%8B%88&quot; aria-label=&quot;혹시 궁금해봤니 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;혹시 궁금해봤니❓&lt;/h2&gt;
&lt;p&gt;Redux를 사용하면서 다음과 같은 물음을 가진 경험이 있습니까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것
일까?&lt;/li&gt;
&lt;li&gt;redux는 전달해준 액션을 어떻게 내가 원하는 reducer에 전달해주는 것일까?&lt;/li&gt;
&lt;li&gt;reducer에서 반환하는 값을 왜 항상 새로 만들어야 하는 것일까? 순수함수는 무엇인가?&lt;/li&gt;
&lt;li&gt;redux state가 변경되면 모든 컴포넌트가 re-render 되는가? 아니면 해당 변경된 데이터를 참조하고 있는 컴포넌트만 re-render 되는가? 후자라면 이 또한 어떻게 그 컴포넌트만을 찾아서 re-render 시키는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 물음을 한 적이 없다면 혹은 &lt;strong&gt;&lt;em&gt;“뭐 뒤에서 알아서 해주겠지 이건 매직 코드야”&lt;/em&gt;&lt;/strong&gt;라고 생각만 했다면 이참에 글쓴이와 함께 오픈소스를 분석하면서 이런 물음에 답을 찾음과 동시에 매직 코드에 대한 막연함, 두려움을 없애고 단순 라이브러리 개발자가 아닌 진짜 생각하는 개발자, 스스로 발전할 수 있는 개발자가 되기 위한 기초를 다질 수 있는 능력을 함께 길러갔으면 좋겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;해당 포스트에서 언급하는 코드들은 많은 부분이 생략된 코드 스니펫이므로 전체 코드는 &lt;a href=&quot;https://github.com/reduxjs/redux&quot;&gt;Redux Github&lt;/a&gt;에서 확인해 보실 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-나는-액션을-dispatch만-하였는데-redux는-어떻게-알고-뒤에서-middleware를-실행하는-것일까&quot;&gt;&lt;a href=&quot;#1-%EB%82%98%EB%8A%94-%EC%95%A1%EC%85%98%EC%9D%84-dispatch%EB%A7%8C-%ED%95%98%EC%98%80%EB%8A%94%EB%8D%B0-redux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%95%8C%EA%B3%A0-%EB%92%A4%EC%97%90%EC%84%9C-middleware%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C&quot; aria-label=&quot;1 나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것일까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 나는 액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 것일까❓&lt;/h2&gt;
&lt;p&gt;들어가기에 앞서 하나 미리 짚어가야할 점은 middleware 형태는 다음과 같이 약속되어 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;middleware&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; dispatch&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; getState &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* something.. */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해당 섹션의 최종 목적은 위 middleware의 인자들이 언제 소비되는지 알아보는 것입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위와 같은 형식을 &lt;strong&gt;Currying&lt;/strong&gt;이라 부릅니다.&lt;br&gt;
필요한 데이터를 클로저를 이용하여 각각의 의미가 있는 함수에 인자로 잡아두고 &lt;strong&gt;lazy execution&lt;/strong&gt;하는 방식으로 자세한 설명은 넘어가지만, 반드시 따로 찾아보시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;redux의 middleware는 어떻게 동작하는 것일까?&lt;br&gt;
이 물음의 해답을 찾아가기 위해서는 middleware를 맨 처음 사용하는 &lt;a href=&quot;https://github.com/reduxjs/redux/blob/master/src/applyMiddleware.ts&quot;&gt;applyMiddleware&lt;/a&gt; 함수를 먼저 볼 필요가 있습니다.
우리가 들여다봐야 할 코드는 다음 두 줄입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyMiddleware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;middlewares&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; middlewareAPI &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    getState&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;getState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; chain &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; middlewares&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;middleware&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;middleware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;middlewareAPI&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  dispatch &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;chain&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    dispatch
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫 시작은 &lt;code class=&quot;language-text&quot;&gt;middlewareAPI&lt;/code&gt;를 모든 middleware &lt;code class=&quot;language-text&quot;&gt;({ dispatch, getState }) =&amp;gt;&lt;/code&gt;에 넘겨주어 redux의 핵심 기능을 middleware에서 사용 할 수 있도록 해줍니다.&lt;br&gt;
&lt;a href=&quot;https://github.com/reduxjs/redux-thunk/blob/master/src/index.js#L4&quot;&gt;redux-thunk&lt;/a&gt;의 경우 넘겨준 위 &lt;code class=&quot;language-text&quot;&gt;dispatch&lt;/code&gt;를 이용하여 비동기 처리를 합니다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;는 함수를 합성하는데 이는 javascript function이 first-class objects인 점을 활용한 방법으로 함수형에서 많이 사용합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;first-class&quot;&gt;&lt;a href=&quot;#first-class&quot; aria-label=&quot;first class permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;first-class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;변수에 할당할 수 있다.&lt;/li&gt;
&lt;li&gt;함수의 인자값으로 전달 할 수 있다.&lt;/li&gt;
&lt;li&gt;함수의 반환 값으로 반환할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;또한 decorator패턴 입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이 패턴은 변경에는 닫혀 있고 확장에는 열려 있는 원칙이 묻어 있는 패턴입니다.
기능 추가에 기존 코드 변경이 필요가 없으며 기능을 무한히 추가할 수 있습니다.
middleware를 추가함에 있어 redux 코드에 전혀 영향이 가지 않고 변경 또한 필요하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;넘겨준 middleware가 &lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;안에서 어떻게 합성되는지 알아보겠습니다. 이런 방식이 익숙지 않은 분들은
머리가 조금 아플수도 있습니다. 하지만 하나씩 찬찬히 뜯어볼 생각이므로 포기하지 마시길 바랍니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compose&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;middlewares&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; middlewares&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;코드는 간단해 보입니다.&lt;br&gt;
여기서 middleware의 &lt;code class=&quot;language-text&quot;&gt;(next) =&amp;gt;&lt;/code&gt;가 소비됩니다. 예로 [a, b, c] middleware가 있다면 &lt;code class=&quot;language-text&quot;&gt;a(b(c()))&lt;/code&gt;의 형태로 만들어 주면서 next를 다음 middleware로 할당합니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;가 끝난 형태는 &lt;code class=&quot;language-text&quot;&gt;(...args) =&amp;gt; a(b(c(...args)))&lt;/code&gt;가 됩니다.
더 정확하게는 &lt;code class=&quot;language-text&quot;&gt;(...args) =&amp;gt; f&amp;#39;(c(...args))&lt;/code&gt;이며 f’는 &lt;code class=&quot;language-text&quot;&gt;(c반환 값) =&amp;gt; a(b(c반환 값))&lt;/code&gt;가 됩니다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;compose&lt;/code&gt;가 반환한 함수의 형태를 보면 실행하기 전까지 &lt;code class=&quot;language-text&quot;&gt;(next) =&amp;gt;&lt;/code&gt;가 소비되지 않는 형태입니다. &lt;code class=&quot;language-text&quot;&gt;compose(...chain)(store.dispatch)&lt;/code&gt;를 통해 store의 dispatch를 넘겨주는데 이때 맨 마지막 middleware의 next를 dispatch로 할당하면서 도화선처럼 나머지의 middleware &lt;code class=&quot;language-text&quot;&gt;(next) =&amp;gt;&lt;/code&gt;도 연달아 소비시킵니다.&lt;/p&gt;
&lt;p&gt;c middleware의 next는 store의 dispatch인 걸 주목합니다. 즉 &lt;u&gt;&lt;strong&gt;우리가 쓰는 dispatch는 middleware가 층층이 겹쳐져 있는 함수이지 redux의 dispatch가 아닙니다😲&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;그리고 우리가 dispatch를 이용하여 Action을 날릴 때 비로소 &lt;code class=&quot;language-text&quot;&gt;(action) =&amp;gt;&lt;/code&gt;가 소비 됩니다. 계속해서 next(action)를 전달하면 위에서 currying하여 잡아둔 다음 middleware의 &lt;code class=&quot;language-text&quot;&gt;(action) =&amp;gt;&lt;/code&gt;를 소비하게 되는 것이고 마지막 middleware의 next는 redux의 dispatch이기 때문에 최종적으로 redux에 action이 도달하게 됩니다.&lt;/p&gt;
&lt;p&gt;누군가가 나에게 다음과 같은 질문을 한다고 생각해 봅시다.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“액션을 dispatch만 하였는데 redux는 어떻게 알고 뒤에서 middleware를 실행하는 건가요?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
네. 지금 보니 간단한 질문이네요&lt;/p&gt;
&lt;h2 id=&quot;2-redux는-전달해준-액션을-어떻게-내가-원하는-reducer에-전달해주는-것-일까&quot;&gt;&lt;a href=&quot;#2-redux%EB%8A%94-%EC%A0%84%EB%8B%AC%ED%95%B4%EC%A4%80-%EC%95%A1%EC%85%98%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%82%B4%EA%B0%80-%EC%9B%90%ED%95%98%EB%8A%94-reducer%EC%97%90-%EC%A0%84%EB%8B%AC%ED%95%B4%EC%A3%BC%EB%8A%94-%EA%B2%83-%EC%9D%BC%EA%B9%8C&quot; aria-label=&quot;2 redux는 전달해준 액션을 어떻게 내가 원하는 reducer에 전달해주는 것 일까 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Redux는 전달해준 액션을 어떻게 내가 원하는 reducer에 전달해주는 것 일까❓&lt;/h2&gt;
&lt;p&gt;이번에도 역시 reducer가 가장 먼저 쓰이는 &lt;a href=&quot;https://github.com/reduxjs/redux/blob/master/src/combineReducers.ts#L139&quot;&gt;combineReducers&lt;/a&gt; 부터 들여다 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;combineReducers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;reducers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; finalReducers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; reducerKeys&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reducerKeys&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; reducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;function&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      finalReducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; finalReducerKeys &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;finalReducers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;combination&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* something.. */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reducer의 최소 조건인 function을 검증하면서 key를 잡고 있습니다. 이는 추후에 reducer의 이름, 다시 말해 redux의 state 객체의 각 property 이름이 바로 &lt;code class=&quot;language-text&quot;&gt;combineReducers&lt;/code&gt;에 넘겨주는 객체의 key에 의해 정해집니다.  &lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;combination&lt;/code&gt; 함수를 반환해 줍니다. &lt;code class=&quot;language-text&quot;&gt;combineReducers&lt;/code&gt; 코드는 환경설정이라 할 수 있고 실 기능은 &lt;code class=&quot;language-text&quot;&gt;combination&lt;/code&gt;이 담당하고 있으며 이는 redux내부에서 사용되어 집니다. 이렇게 코드가 나누어져 있는 이유는 무엇일까요?  &lt;/p&gt;
&lt;p&gt;코드의 성질과 역할이 달라서 격리했다고 생각합니다. 역할별로 나누어서 한번 정해지면 변경될 일이 없는 부분과 요구 사항에 따라 추가 변경이 일어날 확률이 높고 주입되는 상태가 언제든지 변경될 수 있으며 재사용이 높은 부분을 나누었다고 볼 수 있습니다. 분명 이렇게 나누지 않았다면 변경될 확률이 낮은 코드들이 자주 변경되는 코드와 혼재되어 변경에 영향을 받는 코드의 범위가 커지면서 버그, 테스트, 유지보수 등 여러 면에서 좋지 않습니다.
이런 역할, 변화에 따른 격리는 여러 오픈소스를 보면 자주 보이는 형식으로 역할 모델별로 나누는 연습을 많이 해야 합니다.&lt;/p&gt;
&lt;p&gt;그러면 이 함수가 사용되는 곳은 어디일까요?
redux의 dispatch에서 사용됩니다. action을 dispatch에 담아 보내면 &lt;u&gt;middleware -&gt; redux dispatch -&gt; reducer의 순서로 흐릅니다.&lt;/u&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;combination&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; nextState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; finalReducerKeys&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; finalReducerKeys&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; reducer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; finalReducers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; previousStateForKey &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; nextStateForKey &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;previousStateForKey&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;    nextState&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextStateForKey
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    hasChanged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; nextStateForKey &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; previousStateForKey &lt;span class=&quot;token comment&quot;&gt;// 3&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  hasChanged &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; finalReducerKeys&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; hasChanged &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; nextState &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; state
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;보이시나요? 모든 reducer를 돌면서 state와 action을 던져줍니다(1, 2). 그리고 변경이 적용되기 위해선 객체를 새로 만들어야 하는 이유도 보입니다(3).
자신이 처리하지 않는 action의 경우 그저 default(switch의 경우)의 반환 값이 반환될 것입니다. 그다음 변경 여부는 값이 아닌 reference 비교로 결정됩니다.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“reference로 변경 여부를 결정 하므로 항상 새로운 객체를 반환해야 해!”&lt;/em&gt;&lt;/strong&gt;라고 여기까지만 생각하고 개발하는 것은 2%가 부족합니다.&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“왜?”&lt;/em&gt;&lt;/strong&gt;가 빠져있습니다. redux는 왜 직접 데이터를 변경하지 않고 새로운 객체를 만들까? 그게 더 비용이 들지는 않을까? 여기에 대한 대답은 &lt;strong&gt;순수함수&lt;/strong&gt;에서 스스로 찾아보세요!  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;순수함수를 쓰는 이유 중 하나는 객체의 투 포인터 참조에서 오는 데이터 공유 때문 입니다.
단순 변수만을 참조하는 원 포인터 참조는 기존 데이터 변경에 영향을 받지 않습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
bar &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; foo &lt;span class=&quot;token comment&quot;&gt;// false;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;하지만 투 포인터 참조를 할 경우 그렇지 않습니다.  &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;f&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;o&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;o&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
bar&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;f&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;당연한 얘기 같습니다. 여기서 중요한 점은 foo를 여러 곳에서 물고 있으면 foo의 데이터 변경이 어느 곳에 여파를 미치는지 예측할 수 없습니다.
하지만 새로운 객체를 만들어 데이터 변경을 적용하게 되면 기존에 foo를 물고 있던 곳에 영향을 주지 않습니다. 더불어 그 변경의 여파는 새로운 데이터를 반환받아 적용한 곳부터 시작하기 때문에 추적 또한 용이합니다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;“redux는 전달해준 액션을 어떻게 해당 액션을 처리하는 reducer에 전달해주는 것일까?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
여기에 대한 대답은 &lt;u&gt;해당 action을 처리하는 reducer에게만 넘겨주는 게 아니라 모든 reducer에게 액션을 던진다입니다.&lt;/u&gt;&lt;br&gt;
또한 &lt;strong&gt;&lt;em&gt;“reducer에서 반환하는 값을 왜 항상 새로 만들어야 하는 것일까? 순수함수는 무엇인가?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
여기에 대한 대답도 할 수 있겠네요😀  &lt;/p&gt;
&lt;h2 id=&quot;3-redux-state가-변경되면-모든-컴포넌트들이-re-render되는가&quot;&gt;&lt;a href=&quot;#3-redux-state%EA%B0%80-%EB%B3%80%EA%B2%BD%EB%90%98%EB%A9%B4-%EB%AA%A8%EB%93%A0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%93%A4%EC%9D%B4-re-render%EB%90%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;3 redux state가 변경되면 모든 컴포넌트들이 re render되는가 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. redux state가 변경되면 모든 컴포넌트들이 re-render되는가❓&lt;/h2&gt;
&lt;p&gt;마지막 섹션입니다. 코드는 &lt;a href=&quot;https://github.com/reduxjs/react-redux/tree/master/src&quot;&gt;react-redux&lt;/a&gt;에서 확인해 보실 수 있습니다.
해당 부분은 class와 funcitonal component에 따라 봐야할 부분이 다르기 때문에 최근에 대두되는 hook을 기준으로 분석해 보겠습니다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;해당 섹션은 hook을 중심으로 이야기 합니다. hook을 모르신다면 먼저 &lt;a href=&quot;https://reactjs.org/docs/hooks-intro.html&quot;&gt;Hooks&lt;/a&gt;를 보고오시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어디서 부터 접근해야 할 까요? class의 경우 component와의 접점인 connect부터 접근했겠지만 hook은 그런 부분이 없습니다. 그렇다면 그나마 데이터에 접근하는 useSelector가 가장 유력해 보입니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;selector&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; equalityFn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; refEquality&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; subscription&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; contextSub &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useReduxContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    selector&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    equalityFn&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    contextSub
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useSelector&lt;/code&gt;의 두 번째 인자로 비교 함수를 전달해줄 수 있습니다. 기본적으로 shallow compare이며 성능 최적화 등 특정 케이스에서 유용하게 사용될 수 있기 때문에 알아두면 좋습니다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;useReduxContext&lt;/code&gt;는 context API를 이용하여 redux의 store와 &lt;strong&gt;observer 패턴&lt;/strong&gt; 을 구현한 Subscription 객체를 전달받습니다. 요놈들의 데이터를 넣어주는 context는 어디에 있느냐? 바로 우리가 쓰는 &lt;code class=&quot;language-text&quot;&gt;Provider&lt;/code&gt; 컴포넌트에 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Provider&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; context&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; children &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subscription &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Context &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; context &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; ReactReduxContext
 &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Provider value&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; subscription&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;Context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Provider&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Context는 &lt;a href=&quot;https://ko.reactjs.org/docs/context.html&quot;&gt;링크&lt;/a&gt;를 통해 정확히 알고 가는 게 좋습니다. 활용도가 매우 다양하며 여러분들이 알게 모르게 라이브러리를 통해 이미 쓰고 있어서 분석에 많은 도움이 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;useSelector의 &lt;code class=&quot;language-text&quot;&gt;useSelectorWithStoreAndSubs&lt;/code&gt;를 살펴보기에 앞서 위에 언급한 Subscription을 먼저 봐야 합니다. redux store의 state가 변경되면 redux는 자신을 subscribe하고 있는 listener들을 전부 실행 시켜 줍니다. react-redux는 react와 redux를 연결하기 위해 observable, observer 두 가지 역할을 가진 Subscription을 구현하여 redux 상태 변경을 subscribe 함과 동시에 자신을 subscribe하고 있는 listener를 가지고 있습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subscription&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;handleChangeWrapper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onStateChange&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;onStateChange&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;trySubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;unsubscribe&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;unsubscribe &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;handleChangeWrapper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// usage&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subscription &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onStateChange &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; checkForUpdates
subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;trySubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;trySubscribe&lt;/code&gt;를 통해 store를 subscribe하고 store의 state가 변경되면 &lt;code class=&quot;language-text&quot;&gt;onStateChange&lt;/code&gt;를 실행해 줍니다. 계층 구조 전파를 위한 코드들이 빠져 있는 스니펫이므로 궁금하시면 직접 확인해 보시기 바랍니다.&lt;br&gt;
드디어 핵심인 &lt;code class=&quot;language-text&quot;&gt;useSelectorWithStoreAndSubscription&lt;/code&gt;를 살펴보기 위한 준비과정이 끝났습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; forceRender&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useReducer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; s &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; latestSelector &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; latestSelectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useRef&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;forceRender&lt;/code&gt;는 component를 강제로 re-render시키기 위한 방법중 하나 입니다. useState를 사용할 수도 있습니다. 그리고 selector와 그 결괏값인 state를 memoizing 하기 위해 변수를 할당합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight has-highlighted-lines&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;gatsby-highlight-code-line&quot;&gt;    selector &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; latestSelector&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;&lt;/span&gt;    latestSubscriptionCallbackError&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    selectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    selectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;useIsomorphicLayoutEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    latestSelector&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; selector
    latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; selectedState
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;강조된 부분을 봤을 때 어떤 생각이 드시나요?&lt;br&gt;
&lt;strong&gt;&lt;em&gt;“잘못 사용하면 ref의 memoization 이점을 전혀 못 누리겠구나”&lt;/em&gt;&lt;/strong&gt; 라고 생각이 드시나요?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대부분 이렇게 사용하실 겁니다. foo를 select 하는 callback은 항상 새로 만들어지는 함수입니다.&lt;br&gt;
그렇기 때문에 &lt;code class=&quot;language-text&quot;&gt;selector !== latestSelector.current&lt;/code&gt;는 항상 true가 될 것이고 컴포넌트가 re-render 될 때마다 selector는 매번 실행될 겁니다. 간단한 selector의 경우별 차이가 없겠지만 복잡한 연산이 필요한 selector의 경우 불필요한 연산을 추가로 하게 됩니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;selectFoo&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;useSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;selectFoo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Component가 아무리 re-render 돼도 selectFoo는 항상 같기 때문에 이미 구해놓은 &lt;code class=&quot;language-text&quot;&gt;latestSelectedState.current&lt;/code&gt;를 사용할 수 있습니다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;selector가 항상 이렇게 간단하지만은 않죠? 외부 인자에 의존할 경우 다른 방법을 강구해야 합니다.
이와 관련하여 이미 아주 좋은 &lt;a href=&quot;https://github.com/reduxjs/reselect#readme&quot;&gt;라이브러리(reselect)&lt;/a&gt;가 있습니다.
이참에 reselect가 어떻게 결괏값을 memoize 하는지 알아보는 것부터 시작하는 것도 좋습니다!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkForUpdates&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; newSelectedState &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; latestSelector&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;store&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;equalityFn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newSelectedState&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    latestSelectedState&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newSelectedState
    &lt;span class=&quot;token function&quot;&gt;forceRender&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;checkForUpdates&lt;/code&gt;에서는 selector를 실행하고 값이 변경되었는지 확인 후 변경된 state를 memoizing 하고 &lt;code class=&quot;language-text&quot;&gt;forceRender&lt;/code&gt;를 통해 강제로 컴포넌트를 re-render 시킵니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useSelectorWithStoreAndSubscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 생략..&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkForUpdates&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;/* 생략.. */&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;onStateChange &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; checkForUpdates
  subscription&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;trySubscribe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;checkForUpdates&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; selectedState
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;trySubscribe&lt;/code&gt;를 통해 store의 state 변경을 감지하고 변경 될 경우 &lt;code class=&quot;language-text&quot;&gt;checkForUpdates&lt;/code&gt;를 실행하기 위해 &lt;code class=&quot;language-text&quot;&gt;onStateChange&lt;/code&gt;에 할당합니다.&lt;/p&gt;
&lt;p&gt;다시 정리하자면 redux는 store의 state가 변경되면 모든 subscriber를 실행합니다. 컴포넌트에서 useSelector를 실행하면 store를 subscribe하게 됩니다. useSelector를 통해 등록한 checkForUpdates에서 selector가 반환한 값과 memoized 된 값을 비교하여 변경된 경우 해당 컴포넌트를 re-render 시키고 그렇지 않을경우 re-render없이 checkForUpdates 함수만 실행되는 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;“redux state가 변경되면 모든 컴포넌트가 re-render 되는가?”&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;u&gt;그렇지않다. useSelector를 사용한 컴포넌트 중 selector에서 반환한 값이 변경된 component만 re-render된다&lt;/u&gt; 입니다.&lt;/p&gt;
&lt;p&gt;드디어 다 끝났습니다.&lt;br&gt;
글로 풀어 쓸려니 많아 보이고 복잡해 보이지만 코드만 보면 별거 없습니다.
여러분이 익숙지 않아서일 수도 있고 제가 글솜씨가 드럽게 없어서 그럴지도 모릅니다.
하지만 분명한 건 우리가 쓰는 모든 라이브러리는 모두가 다 아는 Javascript로 구현되어 있고 매직 코드란 없다는 겁니다.&lt;br&gt;
라이브러리를 개발하지는 못하더라도 적어도 우리가 쓰는 라이브러리가 대충 어떻게는 돌아가는지 알고 있어야 덜 기분 나쁘지 않겠습니까?&lt;br&gt;
이만~🖐🏻&lt;/p&gt;</content:encoded></item></channel></rss>