<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, minimum-scale=1, maximum-scale=2"/><link rel="shortcut icon" href="/icons/icon-48x48.png"/><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:100%/1.625 -apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:normal;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}h1{margin-left:0;margin-right:0;margin-top:2.4375rem;padding-bottom:calc(0.40625rem - 1px);padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.21875rem;color:inherit;font-family:Catamaran;font-weight:800;text-rendering:optimizeLegibility;font-size:2rem;line-height:1.2;border-bottom:1px solid hsla(0,0%,0%,0.07);}h2{margin-left:0;margin-right:0;margin-top:56px;padding-bottom:calc(0.40625rem - 1px);padding-left:0;padding-right:0;padding-top:0;margin-bottom:20px;color:inherit;font-family:Catamaran;font-weight:700;text-rendering:optimizeLegibility;font-size:1.51572rem;line-height:1.2;border-bottom:1px solid hsla(0,0%,0%,0.07);}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:1.31951rem;line-height:1.1;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.1;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:0.87055rem;line-height:1.1;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;color:hsla(0,0%,0%,0.53);font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Helvetica','Arial',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';font-weight:600;text-rendering:optimizeLegibility;font-size:0.81225rem;line-height:1.1;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}ul{margin-left:1.625rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:6px;list-style-position:outside;list-style-image:none;}ol{margin-left:1.625rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;font-size:0.85rem;line-height:1.625rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;font-size:1rem;line-height:1.625rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}blockquote{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:calc(0.8125rem - 1px);padding-right:0;padding-top:0;margin-bottom:0.8125rem;border-left:4px solid hsla(0,0%,0%,0.13);color:hsla(0,0%,0%,0.53);}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(0.8125rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:0.8125rem;}b{font-weight:600;}strong{font-weight:600;}dt{font-weight:600;}th{font-weight:600;}li{margin-bottom:2px;}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.625rem;margin-bottom:calc(0.8125rem / 2);margin-top:calc(0.8125rem / 2);}li > ul{margin-left:1.625rem;margin-bottom:calc(0.8125rem / 2);margin-top:calc(0.8125rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(0.8125rem / 2);}code{font-size:0.85rem;line-height:1.625rem;}kbd{font-size:0.85rem;line-height:1.625rem;}samp{font-size:0.85rem;line-height:1.625rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:1.08333rem;padding-right:1.08333rem;padding-top:0.8125rem;padding-bottom:calc(0.8125rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}h3,h4,h5,h6{margin-bottom:0.8125rem;margin-top:1.625rem;}ol,ul{margin-left:2.03125rem;}li>ol,li>ul{margin-left:2.03125rem;}a{color:#0687f0;text-decoration:none;box-shadow:none;}a:hover,a:active{text-decoration:underline;}a.gatsby-resp-image-link{box-shadow:none;text-decoration:none;}a:hover{text-decoration:none;}</style><style data-href="/styles.5ef2db19258f1289f869.css" id="gatsby-global-css">@import url(https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css);@font-face{font-family:Noto Sans KR;font-style:normal;font-display:swap;font-weight:100;src:local("Noto Sans KR Thin "),local("Noto Sans KR-Thin"),url(/static/noto-sans-kr-latin-100-2de137ca3e12ea146ee47485a97f1e78.woff2) format("woff2"),url(/static/noto-sans-kr-latin-100-b965647685dd9fc531d1f8a1cc25e024.woff) format("woff")}@font-face{font-family:Noto Sans KR;font-style:normal;font-display:swap;font-weight:300;src:local("Noto Sans KR Light "),local("Noto Sans KR-Light"),url(/static/noto-sans-kr-latin-300-4f773a0fce88aa857d70b56c5b0a1d26.woff2) format("woff2"),url(/static/noto-sans-kr-latin-300-ee87751dac814562bac316d848e35748.woff) format("woff")}@font-face{font-family:Noto Sans KR;font-style:normal;font-display:swap;font-weight:400;src:local("Noto Sans KR Regular "),local("Noto Sans KR-Regular"),url(/static/noto-sans-kr-latin-400-be09f2ced7ff9fa6eda5f0416e2fc840.woff2) format("woff2"),url(/static/noto-sans-kr-latin-400-4c50be0fe5b21a153b8e40a392c2d3fe.woff) format("woff")}@font-face{font-family:Noto Sans KR;font-style:normal;font-display:swap;font-weight:500;src:local("Noto Sans KR Medium "),local("Noto Sans KR-Medium"),url(/static/noto-sans-kr-latin-500-416698c2fc4b3951f8d63d3d2ae23900.woff2) format("woff2"),url(/static/noto-sans-kr-latin-500-28601458e118110e494903a1fcd6dcf5.woff) format("woff")}@font-face{font-family:Noto Sans KR;font-style:normal;font-display:swap;font-weight:700;src:local("Noto Sans KR Bold "),local("Noto Sans KR-Bold"),url(/static/noto-sans-kr-latin-700-04e782e08729f3725ae5a9c95da0c8ba.woff2) format("woff2"),url(/static/noto-sans-kr-latin-700-b9e989a96027f839a9569d2d011e0b71.woff) format("woff")}@font-face{font-family:Noto Sans KR;font-style:normal;font-display:swap;font-weight:900;src:local("Noto Sans KR Black "),local("Noto Sans KR-Black"),url(/static/noto-sans-kr-latin-900-c41f1395489a117ca36d550142a1695f.woff2) format("woff2"),url(/static/noto-sans-kr-latin-900-589f5fbf84d9dc9984a969bae969fd60.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:100;src:local("Catamaran Thin "),local("Catamaran-Thin"),url(/static/catamaran-latin-100-3570195a7b5f619dd9b2419d8fa3f089.woff2) format("woff2"),url(/static/catamaran-latin-100-e82908f57f6d2f23eb9876b2d6868195.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:200;src:local("Catamaran Extra Light "),local("Catamaran-Extra Light"),url(/static/catamaran-latin-200-987ea210308405ac77ba2f36430a70c9.woff2) format("woff2"),url(/static/catamaran-latin-200-bb5993d2f001b739bb9ab7c3ed9725c3.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:300;src:local("Catamaran Light "),local("Catamaran-Light"),url(/static/catamaran-latin-300-2b8a4bd13e9d5ba755f010f8732b0bb6.woff2) format("woff2"),url(/static/catamaran-latin-300-c2696c65c33dcf37871b72bad51ee1ce.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:400;src:local("Catamaran Regular "),local("Catamaran-Regular"),url(/static/catamaran-latin-400-640947b787a38ec35d097129637d9130.woff2) format("woff2"),url(/static/catamaran-latin-400-97e5bc807a3e915e3fbf40ce5fcb1128.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:500;src:local("Catamaran Medium "),local("Catamaran-Medium"),url(/static/catamaran-latin-500-884483dd213f37ae3b5c98f73dd190a5.woff2) format("woff2"),url(/static/catamaran-latin-500-412cf386e31213e3601cb2132b9c4c2d.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:600;src:local("Catamaran SemiBold "),local("Catamaran-SemiBold"),url(/static/catamaran-latin-600-eb6ebda25331e50d3f42c45a41f613bb.woff2) format("woff2"),url(/static/catamaran-latin-600-215c58c6114e0556cb1c332c0fda463a.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:700;src:local("Catamaran Bold "),local("Catamaran-Bold"),url(/static/catamaran-latin-700-3196f49881b324fa5a5f937875cc380f.woff2) format("woff2"),url(/static/catamaran-latin-700-05f6e51c518dd3b521b258e5c05d0e72.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:800;src:local("Catamaran ExtraBold "),local("Catamaran-ExtraBold"),url(/static/catamaran-latin-800-601b1d0f1b78fd65c3205b2c004bbe60.woff2) format("woff2"),url(/static/catamaran-latin-800-3b1675e4ede7e86ec79fa84c1203908e.woff) format("woff")}@font-face{font-family:Catamaran;font-style:normal;font-display:swap;font-weight:900;src:local("Catamaran Black "),local("Catamaran-Black"),url(/static/catamaran-latin-900-6bb5f96614acb7754020b922e1a63d24.woff2) format("woff2"),url(/static/catamaran-latin-900-79292dba48851cc3a212863c860d8f09.woff) format("woff")}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;hyphens:none}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background-color:#fdf6e3}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83;background:#eee8d5}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.custom-hr{margin:64px 0;background:linear-gradient(72deg,#291e95,#cc007a);border:none;height:2px}.home-header{margin-top:0;border-bottom:none;font-weight:900;font-size:48px;letter-spacing:-2px}.link{box-shadow:none;text-decoration:none;color:inherit}.switch-container{text-align:right}.switch-container .icon{text-align:center;color:#222;font-size:14px;font-weight:900}.footer{padding-top:52px;text-align:center;font-size:12px}.footer a{text-decoration:none!important}.home{position:absolute;margin-top:-1.5px}body.light{background-color:#fff;color:#615f5f}body.light .home-header{color:#5a5a5a}body.light .bio .author-name-content{background-color:#ecf0f2}body.light .bio .author-introduction{color:#7d7d7d}body.light .bio a{color:navy}body.light .bio .bio_fontaswesome{fill:navy;vertical-align:-.125em}body.light .category-container{border-color:#ecf0f2;border-style:solid;border-width:1px 6px;background-color:#f4f7f8}body.light .category-container .item{border:1px solid #ecf0f2;background-color:#fff;box-shadow:0 1px 1px rgba(0,0,0,.1)}body.light .category-container .item a{color:#666}body.light .category-container .item[aria-selected=true]{border:2px solid #909da1;font-weight:bolder}body.light .category-container .item[aria-selected=true] a{color:#636c6e}body.light .category-container .item .badge{background-color:#f5222d;color:#fff}body.light .thumbnail{background-color:#fff;box-shadow:0 0 12px rgba(122,124,136,.212)}body.light .thumbnail h3{color:#5173b3}body.light .thumbnail p{color:#7d7d7d}body.light .thumbnail:hover{text-shadow:.1px .1px .1px rgba(68,67,67,.925);box-shadow:1px 3px 15px rgba(122,124,136,.432)}body.light .footer,body.light .thumbnail .thumbnail-subinfo{color:#615f5f}body.light .footer a{color:#5a5a5a}body.light .navigator a{background-color:#fceff7;color:#cc007a}body.light :not(pre)>code[class*=language-]{color:#fff;border:1.2px solid hsla(0,0%,100%,.6392156862745098);background:#7d7d7d}body.dark{background-color:#282c35;color:#dbd8d8}body.dark .home-header{color:#eee}body.dark .bio .author-name-content{background-color:#383636}body.dark .bio .author-introduction{color:#dbd8d8}body.dark .bio a{color:#bb72ec}body.dark .bio .bio_fontaswesome{fill:#bb72ec;vertical-align:-.125em}body.dark .category-container{border-color:#383636;border-style:solid;border-width:1px 6px;background-color:#24272c}body.dark .category-container .item{border:1px solid #383636;background-color:#282c35;box-shadow:0 1px 1px hsla(0,0%,100%,.1)}body.dark .category-container .item a{color:#d8d7d7}body.dark .category-container .item[aria-selected=true]{border:2px solid #666;font-weight:bolder}body.dark .category-container .item[aria-selected=true] a{color:#fff}body.dark .category-container .item .badge{background-color:#d695ab;color:#eee}body.dark .thumbnail{background-color:#282c35;box-shadow:0 0 12px rgba(197,166,201,.2)}body.dark .thumbnail h3{color:#d695ab}body.dark .thumbnail p{color:#dbd8d8}body.dark .thumbnail:hover{box-shadow:1px 1px 13px rgba(195,153,201,.26);text-shadow:.1px .1px .1px #fff}body.dark .footer,body.dark .thumbnail .thumbnail-subinfo{color:#dbd8d8}body.dark .footer a{color:#fff}body.dark blockquote{border-left:4px solid hsla(0,0%,100%,.822)}body.dark h1,body.dark h2{border-bottom-color:hsla(0,0%,100%,.3)}body.dark .navigator a{background-color:#fceff7;color:#cc007a}body.dark td,body.dark th{border-bottom:1px solid hsla(0,0%,100%,.15)}body.dark :not(pre)>code[class*=language-]{color:#c85656;border:1.2px solid rgba(0,0,0,.6392156862745098);background:#e1e1e1}body.dark hr{background:hsla(0,0%,100%,.3)}body{font-family:Noto Sans KR,sans-serif;background-color:#fff;-webkit-text-size-adjust:antialiased;-moz-osx-font-smoothing:grayscale;transition:background-color .3s,color .3s}h1{margin-top:2em;font-size:2.15em}h1,h2{letter-spacing:-1px;border-bottom:transparent!important}h2{margin-top:1.5em;margin-bottom:0;font-size:1.5em}h3{font-weight:700;margin-bottom:.1rem;margin-top:0;letter-spacing:-1px}@media (max-width:500px){.home-header{font-size:40px}}.post-date{text-align:right;font-size:12px;font-style:italic}.bio{margin-bottom:15px}.bio .author-description{display:flex}.bio .author-image{margin-top:0;margin-right:12px;margin-bottom:0;min-width:95px}.bio .author-name{display:flex;flex-direction:column;justify-content:center}.bio .author-name-prefix{font-size:90%;margin-right:4px}.bio .author-name-content{display:inline-block;font-size:95%;padding:2px 6px;font-weight:bolder;border-radius:8px;transform-origin:center;cursor:default}.bio .author-introduction{margin-top:4px;font-size:80%;line-height:1.4}.bio .author-socials{margin-top:4px}.bio a{margin-right:8px;font-size:80%;cursor:pointer}.bio a.visited{text-decoration:none}@keyframes flutter{0%{transform:rotate(0deg)}35%{transform:rotate(0deg)}40%{transform:rotate(-5deg)}60%{transform:rotate(5deg)}65%{transform:rotate(0deg)}to{transform:rotate(0deg)}}.item{position:relative}.item .badge{display:inline-block;position:absolute;top:1px;right:3px;transform:translate(50%,-50%);border-radius:10px;box-shadow:0 0 0 1px;padding:8px 7px;z-index:999;font-weight:700}.category-container{position:sticky;position:-webkit-sticky;top:0;line-height:0;white-space:nowrap;overflow-x:scroll;-ms-overflow-style:none;overflow:-moz-scrollbars-none;z-index:1;padding:6px 20px;margin:0 -5px!important}.category-container .item{display:inline-block;margin:.25rem 7px .25rem 0;border-radius:15px;white-space:normal;box-sizing:border-box;cursor:pointer}.category-container .item div{display:block;padding:14px 16px 16px;font-size:13px;box-sizing:border-box}.category-container .item:last-child{margin-right:0}.category-container::-webkit-scrollbar{display:none}.thumbnail-container{min-height:calc(100vh - 3.5rem)}.thumbnail{display:block;margin-top:12px;padding:15px 15px 12px;transition:box-shadow .3s,text-shadow .3s,opacity .4s;opacity:0;border-radius:10px}.thumbnail p{font-size:90%;line-height:1.4}.thumbnail .thumbnail-subinfo{font-size:.75rem;margin-bottom:.6rem;padding-bottom:.6rem;border-bottom:1px solid #e8e8e8}.thumbnail.visible{opacity:1}.navigator{margin:40px 0;list-style:none;padding:0;overflow:hidden}.navigator li{margin-bottom:12px}.navigator a{padding:7px 16px 8px;border-radius:6px;font-size:12px;opacity:.8}ul.navigator li.right_navi{float:right}ul.navigator li.left_navi{float:left}.post h1{font-size:2.5rem;line-height:1.1}.post h2{margin-top:3.5rem;font-size:1.73286rem}.post h2,.post p{margin-bottom:1.75rem}.post li{margin-bottom:.875rem}.post .gatsby-highlight-code-line{background-color:#022a4b;display:block;margin-right:-1.2em;margin-left:-1.2em;padding-right:1em;padding-left:.75em;border-left:.35em solid #0687f0}.post blockquote{color:#999}.post code[class*=language-],.post pre[class*=language-]{color:#e0e0e0;background:none;font-family:Fira Code,Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.6;font-size:13px;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;hyphens:none;-ms-overflow-style:none;overflow:-moz-scrollbars-none}.post pre[class*=language-]::-webkit-scrollbar{display:none}.post pre[class*=language-]{padding:1.2em;margin:1.5em 0;overflow:auto;border-radius:.6em}.post :not(pre)>code[class*=language-],.post pre[class*=language-]{background:#212121}.post :not(pre)>code[class*=language-]{padding:.1em .3em;border-radius:.5em;white-space:normal;color:#d66587;margin:0 .1em}.post .token.block-comment,.post .token.cdata,.post .token.comment,.post .token.doctype,.post .token.prolog{color:#616161}.post .token.punctuation{color:#e0e0e0}.post .token.attr-name,.post .token.deleted,.post .token.namespace,.post .token.tag{color:#e2777a}.post .token.function-name{color:#6196cc}.post .token.boolean,.post .token.function,.post .token.number{color:#ff9100}.post .token.class-name,.post .token.constant,.post .token.property,.post .token.symbol{color:#ff0}.post .token.atrule,.post .token.builtin,.post .token.important,.post .token.keyword,.post .token.selector{color:#b388ff}.post .token.attr-value,.post .token.char,.post .token.regex,.post .token.string,.post .token.variable{color:#00e676}.post .token.entity,.post .token.operator,.post .token.url{color:#67cdcc}.post .token.bold,.post .token.important{font-weight:700}.post .token.italic{font-style:italic}.post .token.entity{cursor:help}.post .token.inserted{color:green}.dark .anchor{fill:#dbd8d8}.light .anchor{fill:#615f5f}td[align=center]:first-child,th[align=center]:first-child{text-align:center!important;font-weight:bolder!important}table{margin-top:100px}pre[class*=language-].line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}pre[class*=language-].line-numbers>code{position:relative;white-space:inherit}.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:0;font-size:100%;left:-3.8em;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;user-select:none;margin:1.2em}.line-numbers-rows>span{display:block;counter-increment:linenumber}.line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.tldr{padding-left:1em;margin-top:-26px}h3{margin-bottom:.5em}h3 code.language-text{font-size:16px!important}up{top:-.5em;font-size:75%}down,up{position:relative;line-height:0;vertical-align:baseline;font-weight:500}down{font-size:85%}figcaption{padding:3px;text-align:center}center,figcaption{font:italic smaller sans-serif;font-weight:700;font-size:14px}center{top:-.7em;position:relative}ol li,ol li p{margin-bottom:.3rem!important}.gatsby-resp-image-wrapper{margin-bottom:20px}p{position:relative}a.code_link{position:absolute;font-size:small;bottom:-2rem;left:1rem}a.code_link_2{bottom:-2rem}a.code_link_2,a.code_link_3{position:absolute;font-size:small;left:3.1rem;z-index:999}a.code_link_3{bottom:-2.5rem}a.code_link_4{position:absolute;font-size:small;bottom:-3rem;left:1rem}h4{font-weight:700}a.code_link_5{position:absolute;font-size:small;bottom:-3rem;left:3.1rem;z-index:999}strong{font-weight:700}a.code_link_6{position:absolute;font-size:small;bottom:-2.5rem;z-index:999;left:1rem}summary{display:list-item}a.code_link_7{position:absolute;font-size:small;bottom:-3.5rem;left:1rem}</style><meta name="generator" content="Gatsby 2.32.13"/><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="icon" href="/favicon-32x32.png?v=f24356c48475809626ea0c2ac67855c6" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><meta name="theme-color" content="#ffffff"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=f24356c48475809626ea0c2ac67855c6"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><title data-react-helmet="true">React 18 톺아보기 - 04. Concurrent Render | Deep Dive Magic Code</title><meta data-react-helmet="true" name="description" content="리액트의 동시성을 다음과 같이 설명했습니다.  “대규모 화면 전환에서도 높은 응답성을 유지할 수 있다.” “화면 전환”은 Transition Lane에서 알아보았고 이번에는 “높은 응답성을 유지할 수 있다.”을 알아볼 차례입니다. 이를 이해하기 위해서는 리액트의 환경을 생각해보아야 합니다. 리액트는 Javascript…"/><meta data-react-helmet="true" property="og:title" content="React 18 톺아보기 - 04. Concurrent Render | Deep Dive Magic Code"/><meta data-react-helmet="true" property="og:description" content="리액트의 동시성을 다음과 같이 설명했습니다.  “대규모 화면 전환에서도 높은 응답성을 유지할 수 있다.” “화면 전환”은 Transition Lane에서 알아보았고 이번에는 “높은 응답성을 유지할 수 있다.”을 알아볼 차례입니다. 이를 이해하기 위해서는 리액트의 환경을 생각해보아야 합니다. 리액트는 Javascript…"/><meta data-react-helmet="true" property="og:image" content="/static/felog-f24356c48475809626ea0c2ac67855c6.png"/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="google-site-verification" content="o402P1kCwteUVT_5s9zR21dD9lTF4ALZNLms22CIMx4"/><meta data-react-helmet="true" name="keywords" content="react, redux, javascript, web, development, frontend, 리액트, 리덕스, 리액트18, 리액트 18, react 18, react18, transition lane, concurrent render, 리액트, react, react 18, concurrent render, lane, lane model, transition, transition lane, concurrent render, sync render, fiber, fiber architecture, scheduler"/><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link as="script" rel="preload" href="/webpack-runtime-1fa11aca75e3a2c54418.js"/><link as="script" rel="preload" href="/framework-8de36d3fd07627b19105.js"/><link as="script" rel="preload" href="/app-fe38415449496a7ca990.js"/><link as="script" rel="preload" href="/styles-0ec71dd62c66cb95665c.js"/><link as="script" rel="preload" href="/d5d7a013bc6c1e2b6d7db819052c16d7efea5559-707e424af4a0a27cbbeb.js"/><link as="script" rel="preload" href="/cd7d5f864fc9e15ed8adef086269b0aeff617554-6020d22b933a677a17bf.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-26aea61718c6277f711a.js"/><link as="fetch" rel="preload" href="/page-data/react/in-depth-react18-concurrent_render/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2277278352.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/536400264.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div style="margin-left:auto;margin-right:auto;max-width:52rem;padding:2.4375rem 1.21875rem" class="post"><a class="link" href="/"><svg class="home" width="1.125em" font-size="2em" overflow="visible" viewBox="0 0 576 512"><path fill="currentColor" d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path></svg></a><div class="switch-container"><label for="normal-switch"><div style="position:relative;display:inline-block;text-align:left;opacity:1;direction:ltr;border-radius:12px;-webkit-transition:opacity 0.25s;-moz-transition:opacity 0.25s;transition:opacity 0.25s;touch-action:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none"><div class="react-switch-bg" style="height:24px;width:48px;margin:0;position:relative;background:#d9dfe2;border-radius:12px;cursor:pointer;-webkit-transition:background 0.25s;-moz-transition:background 0.25s;transition:background 0.25s"><div style="height:24px;width:26px;position:relative;opacity:0;pointer-events:none;-webkit-transition:opacity 0.25s;-moz-transition:opacity 0.25s;transition:opacity 0.25s"><div class="icon checkedIcon">D</div></div><div style="height:24px;width:26px;position:absolute;opacity:1;right:0;top:0;pointer-events:none;-webkit-transition:opacity 0.25s;-moz-transition:opacity 0.25s;transition:opacity 0.25s"><div class="icon uncheckedIcon">L</div></div></div><div class="react-switch-handle" style="height:22px;width:22px;background:#ffffff;display:inline-block;cursor:pointer;border-radius:50%;position:absolute;transform:translateX(1px);top:1px;outline:0;border:0;-webkit-transition:background-color 0.25s, transform 0.25s, box-shadow 0.15s;-moz-transition:background-color 0.25s, transform 0.25s, box-shadow 0.15s;transition:background-color 0.25s, transform 0.25s, box-shadow 0.15s"></div><input type="checkbox" role="switch" style="border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px" id="normal-switch"/></div></label></div><h1>React 18 톺아보기 - 04. Concurrent Render</h1><p class="post-date">5 months ago</p><div><p>리액트의 동시성을 다음과 같이 설명했습니다.<br>
<em>“대규모 화면 전환에서도 높은 응답성을 유지할 수 있다.”</em><br>
<em>“화면 전환”</em>은 Transition Lane에서 알아보았고 이번에는 <em>“높은 응답성을 유지할 수 있다.”</em>을 알아볼 차례입니다.</p>
<p>이를 이해하기 위해서는 리액트의 환경을 생각해보아야 합니다. 리액트는 Javascript로 구현되었고 대게 브라우저 위에서 동작하게 됩니다. 이 둘은 하나의 콜 스택을 공유하고 있기 때문에 리액트가 콜 스택을 오래 점유할수록 브라우저는 다른 일을 못하게 됩니다. 높은 응답성을 위해서는 렌더링을 진행함과 동시에 브라우저가 사용자의 인풋을 처리할 수 있어야 합니다. 여기에 더불어 사용자 액션에 대한 즉각적인 반응을 해주어야 합니다. Concurrent Render는 이를 위한 구현 사항이며, 아이디어는 다음과 같습니다.</p>
<p>리액트는 렌더링을 진행할 때 메인 스레드를 주기적으로 비워줍니다. 브라우저는 이때 사용자 인풋을 처리하거나 렌더링 작업을 진행할 수 있습니다. 필요에 의해서는 진행 중이던 렌더링을 중단하고 신규로 생성된 업데이트를 먼저 처리합니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 22.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAABGElEQVQY0y2MzUoCYRiFvbHuIq0gYgQRC+dHc3REG8fvmz8NLCNyBK3MLKhd7YIKLIIWLrqC2ruqG3j6oBYHnnPe95yUN3pGXi4QVx8ERzecZjWma+t0i5aSySyTIdGyhFaF41yeWTrNQWGbjmHS1Q16FZvDmkPfqdO1SqR6d59cvy05e/lmf/ZEEJURQYWa2KQuNMU2LWlSFRs0ZB4ZVGl4Oo22RdMz1K1MW/274s+nevdfnM+XjOc/avARIXZUycKLsrSjHL5iGRh48ZYq5olimzA0iWWBwC8Sxrt0OiqLSkhfDbrDB8TkHW+6IO5fkDQLDFoGiWsqGYp1Bq7+73VOPIvpnsars8JtfZUkqDEKbcaxw9C3+QWE+szkbOvjrQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="concurrent" title="concurrent" src="/static/4d707db27b8df0d974a1348e47a10f28/2e237/concurrent.png" srcset="/static/4d707db27b8df0d974a1348e47a10f28/18f77/concurrent.png 198w,
/static/4d707db27b8df0d974a1348e47a10f28/2cb6c/concurrent.png 395w,
/static/4d707db27b8df0d974a1348e47a10f28/2e237/concurrent.png 790w,
/static/4d707db27b8df0d974a1348e47a10f28/471ef/concurrent.png 1185w,
/static/4d707db27b8df0d974a1348e47a10f28/5d6a0/concurrent.png 1580w,
/static/4d707db27b8df0d974a1348e47a10f28/8579d/concurrent.png 2412w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>리액트는 렌더링이 동시성을 가지기 위해 다음의 요구사항을 만족해야 했습니다.</p>
<ol>
<li>렌더링 작업을 중지, 재개할 수 있어야 한다. 필요에 의해서는 이전 렌더링 작업을 버리고 다시 시작할 수 있어야 한다.</li>
<li>렌더링 간의 의존성이 없으며 멱등성을 보장해야 한다.</li>
<li>리액트가 브라우저를 차단하지 않도록 적절히 스위칭 할 줄 알아야 한다.</li>
</ol>
<h1 id="1-렌더링-작업을-중지-재개할-수-있어야-한다-필요에-의해서는-이전-렌더링-작업을-버리고-다시-시작할-수-있어야-한다" style="position:relative;"><a href="#1-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9E%91%EC%97%85%EC%9D%84-%EC%A4%91%EC%A7%80-%EC%9E%AC%EA%B0%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4-%ED%95%84%EC%9A%94%EC%97%90-%EC%9D%98%ED%95%B4%EC%84%9C%EB%8A%94-%EC%9D%B4%EC%A0%84-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9E%91%EC%97%85%EC%9D%84-%EB%B2%84%EB%A6%AC%EA%B3%A0-%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%A0-%EC%88%98-%EC%9E%88%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4" aria-label="1 렌더링 작업을 중지 재개할 수 있어야 한다 필요에 의해서는 이전 렌더링 작업을 버리고 다시 시작할 수 있어야 한다 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. 렌더링 작업을 중지, 재개할 수 있어야 한다. 필요에 의해서는 이전 렌더링 작업을 버리고 다시 시작할 수 있어야 한다.</h1>
<p>16이전에는 콜스택 기반의 재귀호출 방식이었기 때문에 한번 렌더링을 시작하면 완료되기까지 중단할 수 없었습니다. 가령 다음과 같은 코드가 있습니다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>input<span class="token punctuation">,</span> setInput<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>“리액트”<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>
      <span class="token operator">&lt;</span>input
        value<span class="token operator">=</span><span class="token punctuation">{</span>input<span class="token punctuation">}</span>
        onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
          <span class="token function">setInput</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">{</span>input<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">t</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>BusyText text<span class="token operator">=</span><span class="token punctuation">{</span>t<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>DOM에 반영된 모습은 다음과 같습니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABcUlEQVQoz2WQzW8SURTF5y/U0pl5HzPDfFFRQBAow8dGMWkkranBQNTGxC5cmLjprmnStAuSNumGf+nnewMoiYuT++6955x733W01mygSiilDRRBoKm4Pqqa8bo7wFVRmdu67VveTvPPQ+PsG+0TXKHo1yMu3ze4ePuKX7MOw0bMoSf+W2Bf52wK+m9TGoSBIg18Jo2Qq9MmP6cvuJl3mXYSYuUSh6rk7Zvt3k5gzCzUNuaR4GUsSKxISiJR4cB+1T9ACEE11NSrgprhhdZoq7OnKDeseJJDX6KkTy30SQLJc1cYE0mivdJU6aCMNn9mehax4eWGr4RXnsFqfHMmZ/om5ayfMi9SGllopkpOejkfBzmfxzWGzdQME7zrZCwnNc5HR8wGR6YmaeYhi7HlZpwWdVomd27nba4/tblfdPnQS8upjxcFqy/HPH0f8XvWQvgeV2dtHr4V3C/7rL4OiJTHSTdl/WPC3aLH+nLCeZHxB8grMP0vsDs0AAAAAElFTkSuQmCC'); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="react dom" title="react dom" src="/static/5f20953be26ec9cb1ba3e6a9cdb95a04/2e237/react_dom.png" srcset="/static/5f20953be26ec9cb1ba3e6a9cdb95a04/18f77/react_dom.png 198w,
/static/5f20953be26ec9cb1ba3e6a9cdb95a04/2cb6c/react_dom.png 395w,
/static/5f20953be26ec9cb1ba3e6a9cdb95a04/2e237/react_dom.png 790w,
/static/5f20953be26ec9cb1ba3e6a9cdb95a04/471ef/react_dom.png 1185w,
/static/5f20953be26ec9cb1ba3e6a9cdb95a04/5d6a0/react_dom.png 1580w,
/static/5f20953be26ec9cb1ba3e6a9cdb95a04/82e86/react_dom.png 1978w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>사용자가 “앵귤러”를 입력했을 때의 렌더링 과정은 다음과 같습니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 29.292929292929294%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABZElEQVQY00WRQU8iQRCF+Y+uPd09zAzDDAgrsnpgITEaPZhJ1KgJgT3ubsJpQRNEN8NO1gsJQeE/fdYA0cNLVdervFdVXUiShF6vR7fbpd//wdX1JdbVGJPDoLXBaL2OOTzXEBQtrjU4OWc2vXqbF0ajEfP5nNlsxuvrG0/PE4qBwitpPF9TFJitQUXyn6cxD0mN2++RGKlPU7NBYTAYkGUZaZqS/csY3f/B9Rxc38FuEYaKKNzF9xV7ZYdYzMrSY40itAorG3xRGuXIhMPhkOVyycvLfxaLBZPJGOspAt9QLRsasQjkImXLQVVqkUweaJpVTT22hCVDPXJoCB8F7mbl1WrFdDpdx8fxmB2luDjyuU++8vusSi00/Dqvk94e0j+p0xShp5tD/sr7uBFwchCQ3n3j4bJJIY5j2u02nU6HVqtFpVL5uEdRPiA/vtb64/i12h77+w2ZrCR1Z83lsNJvhX8Hpw0Z2QxSF9wAAAAASUVORK5CYII='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="callstack render" title="callstack render" src="/static/939c52af7da5419a393b03d42e101942/2e237/callstack_render.png" srcset="/static/939c52af7da5419a393b03d42e101942/18f77/callstack_render.png 198w,
/static/939c52af7da5419a393b03d42e101942/2cb6c/callstack_render.png 395w,
/static/939c52af7da5419a393b03d42e101942/2e237/callstack_render.png 790w,
/static/939c52af7da5419a393b03d42e101942/471ef/callstack_render.png 1185w,
/static/939c52af7da5419a393b03d42e101942/5d6a0/callstack_render.png 1580w,
/static/939c52af7da5419a393b03d42e101942/05883/callstack_render.png 2808w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<ol>
<li>Reconciler는 현재 컴포넌트를 호출합니다.</li>
<li>반환한 요소와 이전 요소와의 차이점을 찾습니다.</li>
<li>변경 사항을 Renderer에게 전달합니다.</li>
<li>Renderer는 변경 사항을 반영합니다.</li>
<li>Reconciler는 하위 자식 또는 형제 노드를 대상으로 1번을 진행합니다.</li>
</ol>
<p>여기서 1의 요구사항대로 중간에 렌더링을 중단할 수 있다고 해봅시다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 27.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABV0lEQVQY0z1RTU/CQBDtb5TQ3W272/IR+SjQFlKNiSghsYakooYT/8CLBw6mkibtDQ4EL/yg5ywVDy/zZuftzNsdYzqdIkkSzOdzaO77PhhjEEIQ+D8YF7AtAdcR8JyK67NLnf9xI01TrNdrrFYrLJdLRNEY9bpZNSRRJaTITNx1bXwmHXy9DPAwUFSvdBeNhlGWJbbbLbIsQ1EWiG8imLwGYQuKHBbBsxikMKEotqQGhyTu0FnDNmGRszqjVxCMw+GAoiigG+/3e8S3IbioodWw0WtzdJt0yaWm0kLfowH0VEnDNPekTY05rhVDx9XfYcE4nU7I8xy73Q4/xyOCMELTucLHUw+bRR/PYw+Tjo3sNcD3W4h7X+FxIPFNeUb5qO1gMWkifw+xSQMYs9nsvBCNOI6hlDovRdE0DYccWfQ3ihbRbrgIRkOMhsMz1051TWtccqsd/gK4+RUoLncnHgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="pending callstack render" title="pending callstack render" src="/static/047e73f6baa90c9a8ef770829d7cf6f0/2e237/pending_callstack_render.png" srcset="/static/047e73f6baa90c9a8ef770829d7cf6f0/18f77/pending_callstack_render.png 198w,
/static/047e73f6baa90c9a8ef770829d7cf6f0/2cb6c/pending_callstack_render.png 395w,
/static/047e73f6baa90c9a8ef770829d7cf6f0/2e237/pending_callstack_render.png 790w,
/static/047e73f6baa90c9a8ef770829d7cf6f0/471ef/pending_callstack_render.png 1185w,
/static/047e73f6baa90c9a8ef770829d7cf6f0/5d6a0/pending_callstack_render.png 1580w,
/static/047e73f6baa90c9a8ef770829d7cf6f0/20f38/pending_callstack_render.png 2818w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>“앵귤러”의 렌더링이 <code class="language-text">&lt;input/></code>과 첫 번째 <code class="language-text">&lt;BusyText/></code>까지만 진행되고 나머지는 진행되지 않는 채로 브라우저가 페인트를 진행해버립니다. 여기서 리액트는 트리의 일관성을 잃어버리고 사용자는 기대하던 UI와는 어긋난 UI를 확인하게 됩니다.</p>
<p>리액트는 이 문제를 해결하기 위해 16에서 콜스택을 버리고 Fiber Architecture를 도입했습니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 41.919191919191924%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgUlEQVQoz3WSX0sbQRTF8xltMv92ZrPZ7GQNBjdtomDb0NWCUCiUgg8+BJTYxuhDv+Kvd9bYSrEPl5m5c8+558ydnrWW18IYg88yjpqGk/YTJ+ctp6sVRVF0d857jNZPIednTO9/ZNZZVL/PePGWd9dXnK6vWV59p39wQChLJssFRZyQ5cO/GFl7r5Lt91pptMsoZ1Mmx1PyukZpUSfN6mhpGsf82BCCQZuEeaHwJVGykQqCd0yXc842N7y/u+XDzZpccrqzrAm5ktDSwAh+T2j+UZcUZCFwWI+ox4EogGpSUtYVMQ4ZZZoYFJlNtXZPtMf/sSxESZUVe1UccVQPKbwMxSiiVxil0APZuzc4o4XsibQKuiNOiu3zG6pkzzmyUdGpqnLprAYMrKMqbDecBFBSHHJpWHq0TDjlvFWMw4A8l2eQH6GFqzf/9pX2YcvF45bV7RpXOmaXF5zLud39kHXH8LAgni1Ybe9o7zeSuycuZ3gR8PHnhs87iV+PNF8u+Q3bllowZwhkXgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="virtual dom" title="virtual dom" src="/static/e8d75a5c60320253b791b92547c1c32b/2e237/virtual_dom.png" srcset="/static/e8d75a5c60320253b791b92547c1c32b/18f77/virtual_dom.png 198w,
/static/e8d75a5c60320253b791b92547c1c32b/2cb6c/virtual_dom.png 395w,
/static/e8d75a5c60320253b791b92547c1c32b/2e237/virtual_dom.png 790w,
/static/e8d75a5c60320253b791b92547c1c32b/471ef/virtual_dom.png 1185w,
/static/e8d75a5c60320253b791b92547c1c32b/5d6a0/virtual_dom.png 1580w,
/static/e8d75a5c60320253b791b92547c1c32b/4ca46/virtual_dom.png 1944w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>리액트는 DOM에 바로 작업하는 게 아닌 Virtual DOM을 따로 구성했습니다. 그리고 이 노드 하나가 Fiber라고 부릅니다. 이 Fiber에는 트리 정보뿐만 아니라 컴포넌트, 컴포넌트의 상태, 라이프 사이클 등이 모두 담겨 있습니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 40.90909090909091%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABc0lEQVQoz2WSy0rDQBSG84SlSZtkJjOTq2ntxRsURd2oC7sSRNLuFUGUxkXfQUHBQhvoovouvzNj7IUuPk7O4eQ7mTMx0jRFGIaIomgDVSeEgFAKKlHPLnElZAOyBpUYnHNUKhWYprmkWq3qIUpECdWi0IvQEftI/SaiuIUo6SJOWhBhBM4ZOPP0cCPLMozHY4xGI+R5rqPK+/1r1Ot12eTp6dzjUnQgRR3sSGGS7qEdJmgKHx1foBsEEFzAyPNXLL5/MJ0VmBWFjirPBkNUTQsBp2j6DnzBQRiHK8UuE3Ak1GMQapg8BZdf53kejJenR8ynX5h8vEnedVT54O4WwjGxGxAwKvcjm2m5p3UILSn3aIyfH7CYFygmn0tUfj+8AbPN8sh0+4JcV6PFZV1hnBy2cXl+jIuz3h+nPVzJ/KiTwnbcsnH1kpIJIfSlBXJv/7Wl0LZt1Go1+L6PRqMBxhgsy4LjOKtmsilUveq3iuN4S/gLULNrmaFm1kwAAAAASUVORK5CYII='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="callstack to func" title="callstack to func" src="/static/ff2c68dac3560349bec8766976261f47/2e237/callstack_to_func.png" srcset="/static/ff2c68dac3560349bec8766976261f47/18f77/callstack_to_func.png 198w,
/static/ff2c68dac3560349bec8766976261f47/2cb6c/callstack_to_func.png 395w,
/static/ff2c68dac3560349bec8766976261f47/2e237/callstack_to_func.png 790w,
/static/ff2c68dac3560349bec8766976261f47/471ef/callstack_to_func.png 1185w,
/static/ff2c68dac3560349bec8766976261f47/5d6a0/callstack_to_func.png 1580w,
/static/ff2c68dac3560349bec8766976261f47/045f9/callstack_to_func.png 2350w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<div id="sync_loop">
이어서 콜 스택 기반의 재귀호출 방식을 수정했습니다. 콜 스택 프레임 하나를 함수로 대체하고 재귀 호출이 아닌 참조 포인터 기반으로 트리를 탐색합니다.</div>
<p>Sync Render와는 다르게 Concurrent Render는 메인 스레드를 비워주기 위해 추가 조건을 하나 더 확인합니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1831">reconciler > ReactFiberWorkLoop.js</a></p>
<div id="concurrent_loop">
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">shouldYield()</code>는 Scheduler에게 현재 메인 스레드를 비워주어야 하는지 물어보는 거라고 이해하시면 됩니다.</p>
<blockquote>
<p>Scheduler는 리액트 16에서 <strong>리액트 - 브라우저 스위칭</strong>을 담당하기 위해 추가된 패키지입니다.</p>
</blockquote>
<p>Concurrent Render에서 Reconciler는 현재의 렌더링을 중단해야 한다면 <code class="language-text">workInProgress</code>와 같은 포인터들을 그대로 유지한 채 아직 렌더링이 끝나지 않았다는 것을 Scheduler에게 콜백(렌더링 시작 기능을 하는)을 반환하는 방식으로 알려 줍니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L959-L963">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>callbackNode <span class="token operator">===</span> originalCallbackNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
<blockquote>
<p>여기서의 <code class="language-text">callbackNode</code>는 Scheduler에게 콜백을 등록하면 반환되는 객체입니다. Reconciler는 업데이트가 발생하면 렌더링 작업을 예약하기 위해 <code class="language-text">ensureRootIsScheduled()</code>를 통해 Scheduler에게 콜백을 등록합니다. 그리고 해당 정보를 root에 기입합니다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span>
  schedulerPriorityLevel<span class="token punctuation">,</span>
  <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span>
<span class="token punctuation">)</span>

root<span class="token punctuation">.</span>callbackPriority <span class="token operator">=</span> newCallbackPriority
root<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> newCallbackNode</code></pre></div>
<p>이때의 정보는 추후에 해당 VDOM 내에서 새로운 업데이트가 발생하여 추가 렌더링 작업이 필요한 경우, 기존 예약된 렌더링과 우선순위를 비교하여 예약된 렌더링을 취소해야 할지 결정하는 데에 쓰입니다.</p>
</blockquote>
<p>Concurrent Loop의 과정은 다음과 같습니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 35.85858585858586%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABfklEQVQoz12RW1NaUQxG+ZFw7vcb+3iuBUHqKEplKFj1gYfSTmsf+mqn4jj+vtVAh9H2IZPsTPZKvqRjmiZvzTh4w8DyPJwsJS4KzqfnhPIOXIcwCPAk1qVmV6frOpqm7X3nX6DxF2hZaN0u/fcTmrtrTr9+pmgbXMnvoE2e0xZHpGGIIZC6rtlsNsxms1fgrtNrbKL1egRlyWB5xfjuE6eXl/i2sweWAszThFQmzcVW8yu+39+zXq//m1Cgmm7geC6Rb1GOGqrVgpP1LUkaEFi6SPaIBKqikFbW0SYxbVVxNp0yHA7pGG/2YJgWWRJQqZBB0aeNXdxelzqwmZSKQRbRRA7Heca4HZBniiRRxFmOI432O7RsG8txcHyX+fyCUVPIdD5Hic/oeMhkfCJNIsp+RKYUMznOTm4l6wjTvqjxsYVxUNkplwuWz49cvzwxuV3i14oPvx/4KLnpzx+4icv42xcW2wcWj7+I2xx1ccbNy1b+bHl3s6InBzwA/wDfAjk2ShksvwAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="concurrent loop" title="concurrent loop" src="/static/5c64b4a5dbb21af0504a6893976b3bcb/2e237/concurrent_loop.png" srcset="/static/5c64b4a5dbb21af0504a6893976b3bcb/18f77/concurrent_loop.png 198w,
/static/5c64b4a5dbb21af0504a6893976b3bcb/2cb6c/concurrent_loop.png 395w,
/static/5c64b4a5dbb21af0504a6893976b3bcb/2e237/concurrent_loop.png 790w,
/static/5c64b4a5dbb21af0504a6893976b3bcb/471ef/concurrent_loop.png 1185w,
/static/5c64b4a5dbb21af0504a6893976b3bcb/5d6a0/concurrent_loop.png 1580w,
/static/5c64b4a5dbb21af0504a6893976b3bcb/d3bd3/concurrent_loop.png 2822w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>이제 돔에 바로 반영하지 않고 콜스택도 쓰지 않기 때문에 렌더링을 <code class="language-text">&lt;BusyText text=“액” /></code>까지만 진행했다가 다시 중단한 위치에서 참조 포인터만 가지고 재개할 수 있습니다.</p>
<p>이런 기능을 가진 Concurrent Render를 모든 Lane을 대상으로 적용하지 않습니다. Lane에는 우선순위가 있고 이 중에는 사용자 인풋을 차단하면서까지 빠르게 반영해야 하는 Lane들도 있습니다.</p>
<h2 id="sync-lane" style="position:relative;"><a href="#sync-lane" aria-label="sync lane permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sync Lane</h2>
<p>Sync Lane은 얼마나 빠르게 처리해야 할까요?<br>
Sync Lane은 Discrete Event에서 생성된 업데이트에 할당되는 Lane이며 Discrete Event에는 click, input 등이 있습니다. 대부분의 개발자는 input 이벤트에 다음과 같은 형태의 핸들러를 작성할 겁니다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span>input<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">setInput</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span></code></pre></div>
<p>해당 핸들러에서 발생하는 업데이트를 다음과 같이 배치처리하려고 하면 비정상적으로 상태가 반영됩니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 16.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA4ElEQVQI1z2PsU7CUABF+wsE+Adg1F9gYwGWtu9Z2r7XFp+NglgUMCExKImDsyZ+gAMDODg4+Q/EQRYn/+P4NMbh5gx3uOc682aT81aLII6JwhClFL7v/1JpTRZFLDsdLlyXxQ9tt2i3GUtBPrtldP3I8eUd6cmUnj7Eea9WeavXGUwmnA6HFEWBMYZ+luEGAUfdLp+lEi+1Gh+VCptGg125zNP+HjfrLc9buH/9YrnaMbh6wPE9D8+uSikRQvwnsmY6SdDW1Fjz7I+pfWJsl6qYJD+jP5qj8zEyTBAHPb4BtGyFUvT+0I8AAAAASUVORK5CYII='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="sync batch" title="sync batch" src="/static/6ecbb1d6b04b4d20084b68a06a6e912d/2e237/sync_batch.png" srcset="/static/6ecbb1d6b04b4d20084b68a06a6e912d/18f77/sync_batch.png 198w,
/static/6ecbb1d6b04b4d20084b68a06a6e912d/2cb6c/sync_batch.png 395w,
/static/6ecbb1d6b04b4d20084b68a06a6e912d/2e237/sync_batch.png 790w,
/static/6ecbb1d6b04b4d20084b68a06a6e912d/471ef/sync_batch.png 1185w,
/static/6ecbb1d6b04b4d20084b68a06a6e912d/b67f3/sync_batch.png 1338w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<img src="/path/to/dir/f0d200523a9a68fadf649583b925e056/simul_sync_batch.gif" width="100%">
<p>이와 같이 개별적으로 처리해야 하는 이벤트가 있습니다. 모두 사용자 액션으로부터 발생하는 이벤트이기 때문에 개별적인 처리와 함께 높은 UI 응답성도 가져야 합니다. 이를 위해 Discrete Event에서 발생하는 업데이트에는 Sync Lane을 할당하고 Scheduler에게 렌더링 콜백(<code class="language-text">performSyncWorkOnRoot()</code>)을 등록하는 게 아닌 Reconciler의 내부 큐(<code class="language-text">syncQueue</code>)에 콜백을 추가합니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L759-L769">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">currentTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">const</span> nextLanes <span class="token operator">=</span> <span class="token function">getNextLanes</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">const</span> newCallbackPriority <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>nextLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">   <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
<p><a class="code_link_6" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js#L23-L33">reconciler > ReactFiberSyncTaskQueue.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">callback</span><span class="token operator">:</span> SchedulerCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>syncQueue <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    syncQueue <span class="token operator">=</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    syncQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>해당 콜백은 Scheduler의 콜백보다 먼저 실행되어야 하기 때문에 Micro Task Queue를 활용합니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L778-L791">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">currentTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">scheduleSyncCallback</span><span class="token punctuation">(</span><span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">   <span class="token function">queueMicrotask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token function">flushSyncCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
<p><a class="code_link_6" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js#L58-L68">reconciler > ReactFiberSyncTaskQueue.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">flushSyncCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> isSync <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> syncQueue<span class="token punctuation">;</span>
  <span class="token function">setCurrentUpdatePriority</span><span class="token punctuation">(</span>DiscreteEventPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> callback <span class="token operator">=</span> queue<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      callback <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>isSync<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// performSyncWorkOnRoot</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  syncQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>내부 큐에서 콜백을 꺼내 실행시킵니다. 이때의 콜백은 <code class="language-text">performSyncWorkOnRoot()</code>가 됩니다. <code class="language-text">performSyncWorkOnRoot()</code>는 동기식 렌더링(Sync Render)을 시작하는 함수입니다. 해당 함수에서 렌더링 루프를 실행시키는데, 이때의 루프는 위에서 살펴봤던 <code class="language-text">workLoopSync()</code>가 됩니다.</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">performSyncWorkOnRoot</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
 <span class="token keyword">let</span> lanes <span class="token operator">=</span> <span class="token function">getNextLanes</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> NoLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
 <span class="token keyword">let</span> exitStatus <span class="token operator">=</span> <span class="token function">renderRootSync</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">renderRootSync</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Render Phase 설정</span>
  <span class="token keyword">const</span> prevExecutionContext <span class="token operator">=</span> executionContext<span class="token punctuation">;</span>
  executionContext <span class="token operator">|=</span> RenderContext<span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
  <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
<p>이를 바탕으로 연속적인 “리액트” 입력의 개별 렌더링 반영 과정을 살펴보면 다음과 같습니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 596px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 121.71717171717171%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAAFK0lEQVQ4y42U21NTVxTGY7Xt1PrQzrQv7UO1T0774B9Rq9TRlsDJhZB7cnJyQu5BTLQkEEAwUIsKKoJcJIwG8YIVorZqFARvdFBbKx11rFpF5KJOR2faab+ufRJAbTvThy87J7Ozzt7fb61PZjIaYRdF6JxOaF0uSYLdDsHGQ6s3wmAVYSQZMtKbBahVCihyvgBHUilykZeXB7VaLUnmDwTgtNnQkJWF9qWfoG3ZMggmE3yrC1G6PYkNB26iInEVFZ3XsH7vCDbs/RFCYQXswRo4w/UwudbRC5RSUSaZw+uFkJ2NpzIZkNGJ99+DSCctbxtAx5lJdA48QEf/A3SdHcemnl8QTYxgR2oCbYNP8WVjCgouh4pp0gWdPh/43FzcXrAAz16Zg2dzX0HjkiUQ3W6sbz+H9oHHODQ0iZ7hRzg49Ai1vXcR2TWE6u5b2Ng7ijV1R6DkcmcLeumEInkW0OkQ1GpRRKtBEODz+7D26wSi8e9R0noWJW3nEGk9jzI6tbmgCMaCICzeCHRWF11ZNXtlI0Fxezzg/X5YyE8rrR6XGw4CpVJy0NAmjSYvs2rIeBWByIEyZxUU8pVQcfIXofjoyk6HAxHaXE4/lNFqsYvwBfwI1cTpdIMobjyF8M7TpD6UNJ2ESQxAx3uhF4ugNdull8yc0ElX5uVyjL7+Gv7KQOlYvBh2twuV8fNo6X+MllMP0XjyIdr6JrE5eQ/FrRewJXkXTalJBOuZh89BKaCC9pwcPHl13gzl5IeL4CAojPKewUkcHR7HsUsTSA5PovbwLYnytuMP0XrmN6xtSL0EhVGmvot9loUtny7FpuXLodfr4fZ5UbrjKKoP3Ub1gev4qvsGYgdvIrZvBEJRJYRQLRzhbTC7izN9SP6yglarFYHCQtiCQVhDa8GHQggQHK/HjXytHgaLQNNhk2SgKdEZrdJ0cNkrwck/B5crh1JJoJQKKkpQPES4gKAU5+cjSm8oodUspqEEY7sQae5HuPEkIk0phJtOIdJ4AgbeBX8sQW3EgKUkcK5oE5QKLt3YNvLw1zfn4/c5MvxBav/4I6mxGZTmvsfYmRpDA3nWcnoCtQQlEr+E+mOj6B6awjfU9Awc6wCO4zKjR5SfzJs7A6V34QcEJT16ibNTBGUC316ewhGCsrn3DtbUH5O8bT49JY1m3YknVLA/XdBHjSxYLKhZsQJbKRjqKCRYArlpUkobWDjcQPW+n1Czn4Kh65oExSTSrYo2wFMZh6usGb6qOPhAueSjTCS/ggxIOAxTaamkQnouIg+NvAN2fwSCr1gS+867Q+n4YiC0Fqi1Jqh1Zqg0htlJ4Sm+qletxHY64fas5RBpnl1UsGTrYVR2jaB892XSFVTs+QFViSuw0gyHdxxHXfIOYvt/pra6gcrOq9Ca7JCxOWYNeW/+GzMeXnj3HXgKHCjfNYiOgSkkBsYovsbQdW4ctT23Ee28TqDGcejiOOJ9DyjexrApeR96mzfdNqzgyNtvSaP3J6ln0UI4KcErWHydeTQbXxenUHd0FO7yFkQ7hlH/3Tg2H7lPGkVV913oKXlkfrqySH0Y0mlRSsHA+tDK4qswgHUbdyPaPiT1GYuwCKmsbZCa3Q6t1U1gYrAGKsCvrpKiTJ2XD5mO/OJ5HkbykeUgE3u2mM1SirDIel4zUUXRpuSySXJJKgoICQr7UCqVhFxJm9Kr9KxSZfJP/Q+lo4qKa57TdDhM59i02B+0lNzMQ6fTlSn64p7pfS//9p8F/++f/01/A/VzieZk4fv4AAAAAElFTkSuQmCC'); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="sync update" title="sync update" src="/static/f5e1ed3a3ff5010c7a7a424e8324e0d2/699b7/sync_update.png" srcset="/static/f5e1ed3a3ff5010c7a7a424e8324e0d2/18f77/sync_update.png 198w,
/static/f5e1ed3a3ff5010c7a7a424e8324e0d2/2cb6c/sync_update.png 395w,
/static/f5e1ed3a3ff5010c7a7a424e8324e0d2/699b7/sync_update.png 596w" sizes="(max-width: 596px) 100vw, 596px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<h2 id="input-continuous-lane-default-lane" style="position:relative;"><a href="#input-continuous-lane-default-lane" aria-label="input continuous lane default lane permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Input Continuous Lane, Default Lane</h2>
<p>Input Continuous Lane은 <a href="https://github.com/facebook/react/blob/v18.2.0/packages/react-dom/src/events/ReactDOMEventListener.js#L471-L492" target="blank">Continuous Event</a>에 해당하는 drag, scroll 이벤트 등에서 생성된 업데이트에 할당됩니다. Default Lane은 리액트 컨트롤 영역 밖에서 발생한, 대부분 비동기 함수에서 생성되는 업데이트에 할당됩니다. 이 둘을 같이 설명하는 이유는 렌더링 방식이 같아서입니다.</p>
<p>개별적으로 처리해야 하는 Sync Lane과 다르게 이 둘은 일련의 업데이트를 일괄처리할 수 있습니다. 다만 Sync Lane과 마찬가지로 랜더링이 진행된다면 빠르게 UI 응답을 해야하기 때문에 Sync Render로 진행됩니다.</p>
<p>Continuous Event는 사용자 액션이기 때문에 해당 업데이트의 렌더링 작업이 다른 요소로 인해 지연되면 안 됩니다. Default Lane 또한 앞의 두 Lane보다 우선순위가 떨어지고 비동기라 할지라도 여전히 해당 업데이트의 UI는 사용자가 관심 있어 하는 영역이기 때문에 렌더링을 시작했다면 빠르게 완료하고 UI를 반영하기 위해 Sync Render로 진행하는 것입니다.</p>
<p>하지만 콜백은 Sync Render와는 다르게 Scheduler에게 등록합니다.</p>
<div id="scheduleCallback-priority">
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L799-L820">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">currentTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">const</span> newCallbackPriority <span class="token operator">=</span> <span class="token function">getHighestPriorityLane</span><span class="token punctuation">(</span>nextLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCallbackPriority <span class="token operator">===</span> SyncLane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*...*/</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token keyword">let</span> schedulerPriorityLevel<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token function">lanesToEventPriority</span><span class="token punctuation">(</span>nextLanes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">case</span> <span class="token literal-property property">DiscreteEventPriority</span><span class="token operator">:</span></span><span class="gatsby-highlight-code-line">        schedulerPriorityLevel <span class="token operator">=</span> ImmediateSchedulerPriority<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">break</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">case</span> <span class="token literal-property property">ContinuousEventPriority</span><span class="token operator">:</span></span><span class="gatsby-highlight-code-line">        schedulerPriorityLevel <span class="token operator">=</span> UserBlockingSchedulerPriority<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">break</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">case</span> <span class="token literal-property property">DefaultEventPriority</span><span class="token operator">:</span></span><span class="gatsby-highlight-code-line">        schedulerPriorityLevel <span class="token operator">=</span> NormalSchedulerPriority<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">break</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">case</span> <span class="token literal-property property">IdleEventPriority</span><span class="token operator">:</span></span><span class="gatsby-highlight-code-line">        schedulerPriorityLevel <span class="token operator">=</span> IdleSchedulerPriority<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">break</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">default</span><span class="token operator">:</span></span><span class="gatsby-highlight-code-line">        schedulerPriorityLevel <span class="token operator">=</span> NormalSchedulerPriority<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">break</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line">     newCallbackNode <span class="token operator">=</span> <span class="token function">scheduleCallback</span><span class="token punctuation">(</span></span><span class="gatsby-highlight-code-line">      schedulerPriorityLevel<span class="token punctuation">,</span></span><span class="gatsby-highlight-code-line">      <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span>  <span class="token punctuation">}</span>

  <span class="token comment">// 콜백(Concurrent or Sync Render) 예약 정보를 root에 기입한다.</span>
  root<span class="token punctuation">.</span>callbackPriority <span class="token operator">=</span> newCallbackPriority<span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> newCallbackNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p><code class="language-text">schedulerPriorityLevel</code>은 <code class="language-text">lanesToEventPriority()</code>를 통해 Lane의 우선순위를 Scheduler의 우선순위로 변환한 것입니다. 해당 우선순위와 함께 콜백을 Scheduler에게 등록하면 Scheduler는 적절한 시점에 콜백을 실행합니다. 등록과 실행 사이에는 간격이 존재하기 때문에 이 간격 사이에 생성되는 업데이트는 모두 일괄처리될 것입니다.</p>
<p>렌더링 방식은 말씀드렸지만, Sync Render로 진행됩니다. 다만 렌더링 시작 함수가 Sync Lane은 <code class="language-text">performSyncWorkOnRoot()</code>였지만, 이 두 Lane은 <code class="language-text">performConcurrentWorkOnRoot()</code>입니다. 그 이유는 개별 처리와 일괄 처리 구분하기 위함이며 실제 구현 코드는 다음 Transition Lane에서 같이 확인하도록 하겠습니다.</p>
<blockquote>
<p>이 부분이 리액트 18의 개선 사항 중 하나인 Auto Batching의 구현사항입니다. <a href="#auto-batching">Auto Batching 섹션</a>에서 추가 내용을 확인하세요.</p>
</blockquote>
<h2 id="transition-lane" style="position:relative;"><a href="#transition-lane" aria-label="transition lane permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transition Lane</h2>
<p>렌더링 콜백을 등록하는 코드는 Input Continuous Lane, Default Lane과 똑같기 때문에 생략하고 이전에 확인하지 않았던 렌더링 방식을 결정하는 부분을 바로 확인해보겠습니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L877-L883">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">performConcurrentWorkOnRoot</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> didTimeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">let</span> lanes <span class="token operator">=</span> <span class="token function">getNextLanes</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> shouldTimeSlice <span class="token operator">=</span>
    <span class="token operator">!</span><span class="token function">includesBlockingLane</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">includesExpiredLane</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> exitStatus <span class="token operator">=</span> shouldTimeSlice
    <span class="token operator">?</span> <span class="token function">renderRootConcurrent</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">renderRootSync</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><a class="code_link_6" target="blink" href="https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1789">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">renderRootConcurrent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
<p>렌더링 방식은 <code class="language-text">shouldTimeSlice</code> 플래그를 기준으로 Sync와 Concurrent로 분기<up>9,10</up>되는 것을 확인할 수 있습니다. Concurrent Render는 렌더링 대상(<code class="language-text">lanes</code>)에 Blocking Lane과 Expired Lane이 포함되지 않은 경우<up>6,7</up>에만 선택됩니다.</p>
<blockquote>
<p><strong>ExpiredLane</strong><br>
Lane이 만료되는 것은 IO Bound인 Lane(Transition, Retry)에만 해당합니다. Concurrent Render에서 특정 경로가 보류된다면 해당 Lane은 suspendedLanes으로 관리되고 추후에 요청이 완료되면 pingedLanes로 관리됩니다. 보류되었던 모든 경로의 요청이 완료되면 이때부터는 CPU-Bound입니다. 더 이상 네트워크에 의존적인 부분이 없기 때문입니다.<br>
하지만 Concurrent Render는 렌더링 중에도 우선순위가 더 높은 Lane에 Interrupt 될 수 있기 때문에 완료되지 못하고 지속해서 처리가 밀릴 수 있습니다. 이런 기아 현상을 방지하고자 Pinged 상태인 Lane에 만료 시간을 두고 만료가 된다면 더 이상 Interrupt 되지 않도록 Sync Render 방식으로 진행해버립니다.</p>
</blockquote>
<p>다음은 Blocking Lane에 해당하는 Lane입니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberLane.new.js#L475-L479">reconciler > ReactFiberLane.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">includesBlockingLane</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> SyncDefaultLanes <span class="token operator">=</span> InputContinuousLane <span class="token operator">|</span> DefaultLane
  <span class="token keyword">return</span> <span class="token punctuation">(</span>lanes <span class="token operator">&amp;</span> SyncDefaultLanes<span class="token punctuation">)</span> <span class="token operator">!==</span> NoLanes
<span class="token punctuation">}</span></code></pre></div>
<p>Sync Lane은 렌더링 콜백으로 <code class="language-text">performSyncWorkOnRoot()</code>을 사용하였고 Input Continuous Lane과 Default Lane은 <code class="language-text">performConcurrentWorkOnRoot()</code>를 사용했지만, 여기서 Blocking Lane으로 취급되면서 결국, Sync Lane과 같은 방식인 <code class="language-text">renderRootSync()</code>를 사용하게 됩니다. 결국 Concurrent Render를 사용하는 Lane은 Transition Lane과 Retry Lane밖에 없습니다.</p>
<h1 id="2-렌더링-간의-의존성이-없으며-멱등성을-보장해야-한다" style="position:relative;"><a href="#2-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B0%84%EC%9D%98-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%B4-%EC%97%86%EC%9C%BC%EB%A9%B0-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4" aria-label="2 렌더링 간의 의존성이 없으며 멱등성을 보장해야 한다 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. 렌더링 간의 의존성이 없으며 멱등성을 보장해야 한다.</h1>
<p>다음과 같은 Concurrent Render의 상황을 고려해봅시다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 29.7979797979798%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABMElEQVQY03VQ207CQBTsLyJ0793dQlujJkBMrEGFGsWAGl9MjLeQoIDwl+PZwoOa+DCZc50zu5GUEn8hhKgRYhbH6N5OUM5ecfxwh7jZhFQKQoY+zdEMD/luPvoltiv+zDnjUNYhK9qwiQLj4WDobdnEDL7R2B6h+eg/h5yTuNIwRqN/P8X5fIb+5BpK7sFYAZUQiB1voDsoUb49oze9QVQ/j1wIxmoER1preG+RpQZtw3BUeNgsR8dJ5KYJr1pIdQuJJveKgxsDTjuSOJIUCJtAeUds4YsMRZYgdQqa6lzEGF0MMB6PEcck5A10YmAIngTDEUdfEcQUaUW+18Vw9YFqvcBwOcfo6xOm42AO9zFcL+u8IrZ5ivysxGizxCXh9P2FXHEcXFX1brVZ4eTpEd9qbgXcT49g1gAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="concurrent render inconsistent" title="concurrent render inconsistent" src="/static/d97cfaa4c22d4b6f9467df25216af292/2e237/concurrent_render_inconsistent.png" srcset="/static/d97cfaa4c22d4b6f9467df25216af292/18f77/concurrent_render_inconsistent.png 198w,
/static/d97cfaa4c22d4b6f9467df25216af292/2cb6c/concurrent_render_inconsistent.png 395w,
/static/d97cfaa4c22d4b6f9467df25216af292/2e237/concurrent_render_inconsistent.png 790w,
/static/d97cfaa4c22d4b6f9467df25216af292/471ef/concurrent_render_inconsistent.png 1185w,
/static/d97cfaa4c22d4b6f9467df25216af292/5d6a0/concurrent_render_inconsistent.png 1580w,
/static/d97cfaa4c22d4b6f9467df25216af292/e2cbf/concurrent_render_inconsistent.png 2138w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>렌더링을 <code class="language-text">&lt;BusyText text=“앵” /></code>까지 완료한 후에 <code class="language-text">&lt;Slider/></code>와 같이 우선순위가 더 높은 업데이트가 발생하게 된다면 현재의 위치에서 렌더링을 중단하고 <code class="language-text">&lt;Slider/></code>의 업데이트를 먼저 처리할 것입니다. 여기서 문제는 이대로 Virtual DOM을 DOM에 반영해버리면 <code class="language-text">&lt;Slider/></code> 트리는 렌더링이 완료되었지만, 이전에 진행하던 트리는 아직 작업 중인 상태로 반영돼버립니다.
이렇게 되면 결국 15 버전과 마찬가지로 UI의 일관성을 잃어버리게 됩니다.</p>
<p>그래서 리액트는 Virtual DOM을 더블 버퍼링 형태로 관리합니다.</p>
<span class="gatsby-resp-image-wrapper" style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; ">
      <span class="gatsby-resp-image-background-image" style="padding-bottom: 33.83838383838384%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQoz1WR3U7CQBCFeUdtu39su1taWihgA7ZFRVACmhgTExDvvDDxOY/TNsFyMZmd3Zlvzuz0GGPgnKP2XZNSwOMC48Dge1nhMU3geN5lLsXd+tr3uoFQElxKAiloE0L5BlzQme6U+Ae1uQpC9y9gZ6DnuvCHMaavO0RFQXGdoMAZh5IK1g4gCcxJseCy8cn9EtP9FirwG6UtuAOU1mLyUMGkQ7iuByEkFYvG95U+g+omHlk0zzG+K8Co4YXCGiZonHSSYPayw2hxA+VcNQDm8gbKWauMOaSESVijMSrnyNYrWM0hPbcRVSvtWfrs0PYR+rQE5xq+dGECGpNi3wZgnSXoOEY0its3nyZgLgYDH4EWCCMDqTV6m98f6Mgif39Dtllhsl0j2z4hvs1Rfh5oKYI6t8DqdEC+f4bJUlRfR4SzDOXpCDNOUB4+MCwW+AOHxCsYql39hgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"></span>
  <img class="gatsby-resp-image-image" alt="workInProgress tree" title="workInProgress tree" src="/static/9eb60b79b7dde311b314ea1953e0fabf/2e237/workInProgress_tree.png" srcset="/static/9eb60b79b7dde311b314ea1953e0fabf/18f77/workInProgress_tree.png 198w,
/static/9eb60b79b7dde311b314ea1953e0fabf/2cb6c/workInProgress_tree.png 395w,
/static/9eb60b79b7dde311b314ea1953e0fabf/2e237/workInProgress_tree.png 790w,
/static/9eb60b79b7dde311b314ea1953e0fabf/471ef/workInProgress_tree.png 1185w,
/static/9eb60b79b7dde311b314ea1953e0fabf/5d6a0/workInProgress_tree.png 1580w,
/static/9eb60b79b7dde311b314ea1953e0fabf/8da59/workInProgress_tree.png 2742w" sizes="(max-width: 790px) 100vw, 790px" style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;" loading="lazy">
    </span>
<p>한쪽은 이미 DOM에 반영된 트리이고 root가 이를 가리키고 있습니다. 반대쪽은 렌더링 중인 작업용 트리입니다. 작업용 트리는 언제든지 진행 중이던 내용을 폐기 처리하고 다시 작업할 수 있습니다. 왜냐하면, 이미 DOM에 반영된 트리가 반대쪽에 더럽혀지지 않고 존재하고 있기 때문입니다.</p>
<p>렌더링 과정에서 작업용 트리를 완성해가는 단계를 <strong>Render Phase</strong>라고 합니다. Concurrent Render는 이 Render Phase가 비동기 점진적으로 진행(<a href="#concurrent_loop">Concurrent Loop</a>)되고 Sync Render는 메인 스레드를 비우지 않고 동기적으로 진행(<a href="#sync_loop">Sync Loop</a>)됩니다.</p>
<blockquote>
<p><strong>이전 렌더링 작업 정리하기</strong><br>
진행 중이던 렌더링이 현재의 렌더링과 다르다면 이전 작업을 정리하고 신규 작업용 트리를 만들어 진행합니다.
<a class="code_link_7" target="blink" href="https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1755-L1775">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">renderRootConcurrent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressRoot <span class="token operator">!==</span> root <span class="token operator">||</span> workInProgressRootRenderLanes <span class="token operator">!==</span> lanes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">prepareFreshStack</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/*...*/</span>
  <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
</blockquote>
<p>작업용 트리의 렌더링이 완료되면 해당 트리를 기준으로 DOM에 반영하는 과정을 거칩니다. 이 과정을 <strong>Commit Phase</strong>라고 하고 이때는 Concurrent Render나 Sync Render나 모두 동기로 동작합니다. 이 단계에서는 이미 돔에 반영하고 있기 때문에 동기적으로 처리하지 않으면 브라우저가 페인트를 진행해버리면서 UI의 일관성이 깨질 수 있기 때문입니다. 이 단계 까지 완료되면 roo가 가리키고 있는 <code class="language-text">current</code> 포인터도 작업용 트리로 수정합니다.</p>
<p>렌더링은 이런 단계별 Phase와 함께 Lane을 기준으로 동작하기 때문에 이전 렌더링의 상황이 어떻든 아무런 의존성을 갖지 않습니다.</p>
<blockquote>
<p>Concurrent Render의 Render Phase에서는 상황에 따라 하나의 컴포넌트가 여러 번 마운트 - 언마운트될 수 있기 때문에 멱등성 보장이 무엇보다 중요해졌습니다. <a href="#멱등성">멱등성 섹션</a>에서 추가 내용을 확인하세요.</p>
</blockquote>
<h1 id="3-리액트가-브라우저를-차단하지-않도록-적절히-스위칭-할-줄-알아야-한다" style="position:relative;"><a href="#3-%EB%A6%AC%EC%95%A1%ED%8A%B8%EA%B0%80-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%A5%BC-%EC%B0%A8%EB%8B%A8%ED%95%98%EC%A7%80-%EC%95%8A%EB%8F%84%EB%A1%9D-%EC%A0%81%EC%A0%88%ED%9E%88-%EC%8A%A4%EC%9C%84%EC%B9%AD-%ED%95%A0-%EC%A4%84-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4" aria-label="3 리액트가 브라우저를 차단하지 않도록 적절히 스위칭 할 줄 알아야 한다 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. 리액트가 브라우저를 차단하지 않도록 적절히 스위칭 할 줄 알아야 한다.</h1>
<p>Scheduler의 중요한 기능 중 하나는 메인 스레드를 비워주어야 하는지 알고 있는 것입니다.</p>
<h2 id="shouldyieldtohost" style="position:relative;"><a href="#shouldyieldtohost" aria-label="shouldyieldtohost permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>shouldYieldToHost</h2>
<p>브라우저를 차단하지 않는다는 의미는 브라우저가 메인 스레드를 점유해야 할 때를 알 수 있다는 의미이고 반대로 브라우저가 이를 필요로 하지 않다면 평소보다 조금 더 메인 스레드를 점유하고 대기중인 콜백들을 실행해도 된다는 의미가 됩니다. Scheduler는 어떤 방식으로 이와 같은 동작을 구현했는지 <code class="language-text">shouldYieldToHost()</code>를 통해 알아보겠습니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L441-L446">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">let</span> frameInterval <span class="token operator">=</span> frameYieldMs<span class="token punctuation">;</span> <span class="token comment">// 5ms</span>

<span class="token keyword">function</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> timeElapsed <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>timeElapsed <span class="token operator">&lt;</span> frameInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/*...*/</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Scheduler에는 등록된 콜백을 반복해서 실행하는 동작이 있으며, 해당 동작을 시작하기 전에 시작 시점을 <code class="language-text">startTime</code>에 기록합니다. <code class="language-text">startTime</code>는 현재까지 메인 스레드를 얼마나 점유 했는지(<code class="language-text">timeElapsed</code>) 확인<up>5</up>할 때 쓰입니다.</p>
<p>먼저 점유한 시간이 <code class="language-text">frameInterval</code> 보다 크지 않다면<up>6</up> 메인 스레드를 양보하지 않습니다. 여기서 <code class="language-text">frameInterval</code>의 5ms는 그냥 설정된 시간은 아닙니다. Google의 RAIL 모델에서 응답 시간에 따른 사용자의 인식을 설명한 섹션이 있습니다(<a href="https://web.dev/i18n/ko/rail/#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%97%90%EA%B2%8C-%EC%A7%91%EC%A4%91" target="blank">참고</a>).</p>
<p>초당 60프레임을 그리기 위해서는 하나의 프레임을 16ms 안에 그려야 합니다. 여기에는 Javascript의 실행 시간 외에도 해당 프레임을 그리기 위한 브라우저, 기기 동작 시간도 포함됩니다. 이를 기반으로 리액트의 Scheduler는 주기적으로 하나의 프레임 시간 안에 여러 번 양보하도록 합니다.</p>
<p>하지만 양보하기에 앞서 유저 인풋이 발생하지 않았거나 페인트할 필요가 없는 경우에는 굳이 메인 스레드 비워줄 필요는 없습니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L456-L479">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>timeElapsed <span class="token operator">&lt;</span> frameInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableIsInputPending<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token comment">/*...*/</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Javascript에서 유저 인풋이 발생했는지 확인하기 위해서 Facebook에서 제안한 <a href="https://developer.chrome.com/articles/isinputpending/" target="blank">isInputPending()</a> API를 사용합니다. <code class="language-text">enableIsInputPending()</code>은 호스트 환경이 <code class="language-text">isInputPending()</code> API를 지원하는지 나타냅니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L456-L479">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>timeElapsed <span class="token operator">&lt;</span> frameInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableIsInputPending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>needsPaint<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>    <span class="token comment">/*...*/</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>유저 인풋을 확인하기에 앞서 먼저 대기 중인 페인트 작업이 있는지 확인합니다. 여기서의 페인트는 <em>렌더링이 Commit Phase까지 완료되어 DOM에 반영하였지만, 브라우저가 아직 페인트를 진행하지 않은 상태</em>를 뜻합니다. 해당 상태는 리액트가 컨트롤 하는 영역이기 때문에 <code class="language-text">needsPaint</code> 내부 변수를 통해 페인트가 대기 중인지 확인할 수 있습니다(<a href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2206" target="blank">참고</a>).</p>
<p>대기 중인 페인트가 없다면 이번에는 유저 이벤트가 발생했는지 확인합니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L461-L478">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">const</span> continuousInputInterval <span class="token operator">=</span> continuousYieldMs<span class="token punctuation">;</span> <span class="token comment">// 50ms</span>
<span class="token keyword">const</span> maxInterval <span class="token operator">=</span> maxYieldMs<span class="token punctuation">;</span> <span class="token comment">// 300ms</span>

<span class="token keyword">function</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>timeElapsed <span class="token operator">&lt;</span> frameInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableIsInputPending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>needsPaint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="gatsby-highlight-code-line"></span><span class="gatsby-highlight-code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeElapsed <span class="token operator">&lt;</span> continuousInputInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">return</span> <span class="token function">isInputPending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timeElapsed <span class="token operator">&lt;</span> maxInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">return</span> <span class="token function">isInputPending</span><span class="token punctuation">(</span>continuousOptions<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// options으로 continuous input도 포함되도록 할 수 있다.</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">continuousInputInterval</code>이 50ms인 이유도 마찬가지로 RAIL 모델에서 확인할 수 있습니다(<a href="https://web.dev/i18n/ko/rail/#%EC%9D%91%EB%8B%B5-50ms-%EB%AF%B8%EB%A7%8C%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC" target="blank">참고</a>). 사용자는 동작으로부터 0~100ms 안에 응답이 온다면 즉각적으로 반응했다고 인지한다고 합니다. 다만 여기서도 마찬가지로 여러 요소들이 포함되기 때문에 50ms 안에 유저 인풋을 처리하도록 권장하고 있습니다.</p>
<p><code class="language-text">shouldYieldToHost()</code>에서도 Lane과 마찬가지로 유저 이벤트에 우선순위를 두고 있습니다. 50ms 이내의 처리 대상 이벤트는 유저의 Discrete input만 해당합니다<up>15</up>. Continuous input은 300ms(<code class="language-text">maxYieldMs</code>)안에서 처리하도록 하고 있습니다<up>17</up>. 다르게 처리하는 이유는 RAIL 설명을 참고하면 <em>“사용자 입력에 즉시 응답하는 것이 항상 올바르지는 않다”</em>에 해당하는 것 같습니다.</p>
<p>마지막으로 페인트, 유저 인풋이 없어도 메인 스레드를 무한정 점유하지 않고 300ms 이상을 점유했다면 양보하도록 합니다<up>20</up>.</p>
<p><code class="language-text">shouldYieldToHost()</code>을 활용하여 Reconciler는 Concurrent Render에서 브라우저를 차단하지 않고 점진적으로 렌더링 작업을 수행할 수 있습니다. <code class="language-text">shouldYieldToHost()</code>는 Reconciler 말고도 Scheduler에서도 사용됩니다. Scheduler는 예약된 콜백을 관리합니다. 그리고 이 콜백을 우선순위에 맞게 실행시켜야 하는 책임도 있습니다. 여기서 Reconciler와 마찬가지로 콜백의 실행을 계속 이어가도 되는지 <code class="language-text">shouldYieldToHost()</code>를 통해 확인합니다.</p>
<p>이 외에도 브라우저를 차단하지 않고 스위칭할 수 있도록 등록된 콜백을 관리하고 처리할 줄 알아야 합니다.</p>
<h2 id="scheduler가-콜백을-관리하는-방법" style="position:relative;"><a href="#scheduler%EA%B0%80-%EC%BD%9C%EB%B0%B1%EC%9D%84-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95" aria-label="scheduler가 콜백을 관리하는 방법 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scheduler가 콜백을 관리하는 방법</h2>
<p>Scheduler는 콜백을 두개의 최소 힙 큐로 나누어 관리합니다. 하나는 실행되어야 하는 콜백이 등록되는 <code class="language-text">taskQueue</code>와 다른 하나는 실행 대기 중인 콜백을 등록하는 <code class="language-text">timerQueue</code>입니다. 콜백은 Scheduler 내부에서 Task라는 모델로 관리됩니다. Task에는 다음과 같은 콜백의 정보가 함께 저장됩니다.</p>
<blockquote>
<p>콜백을 등록할 때 <code class="language-text">scheduleCallback()</code>의 옵션으로 delay를 설정한 경우에만 타이머 Task로 관리됩니다. 이를 활용한 코드를 찾을 수 없어 어떠한 경우에 사용하는지 알기 어려워 이 이후부터 타이머와 관련된 부분은 생략하도록 하겠습니다.</p>
</blockquote>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">type Task <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">id</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> Callback <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">priorityLevel</span><span class="token operator">:</span> PriorityLevel<span class="token punctuation">,</span> <span class="token comment">// 콜백의 우선순위. 만료까지 여유가 있다면 지연시킬 수 있는 정도를 결정한다.</span>
  <span class="token literal-property property">startTime</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token comment">// 콜백을 실행해야하는 시점을 나타낸다.</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token comment">// 만료 시간이 지나면 더 이상 실행을 지연하지 않는다.</span>
  <span class="token literal-property property">sortIndex</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token comment">// 큐에서의 정렬 기준, 큐 내 요소들의 우선순위</span>
<span class="token punctuation">}</span></code></pre></div>
<p>이 Task는 Reconciler가 렌더링 콜백을 Scheduler에게 등록할 때 생성됩니다. 이때 콜백과 함께 넘겨준 것이 콜백의 우선순위였습니다(<a href="#scheduleCallback-priority">scheduleCallback</a>).</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L323-L352">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token comment">// Times out immediately</span>
<span class="token keyword">var</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// Eventually times out</span>
<span class="token keyword">var</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
<span class="token comment">// Never times out</span>
<span class="token keyword">var</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span> <span class="token operator">=</span> maxSigned31BitInt<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">unstable_scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> startTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> timeout<span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token literal-property property">ImmediatePriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span> <span class="token comment">// -1ms</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">UserBlockingPriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span> <span class="token comment">// 250ms</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">IdlePriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span> <span class="token comment">// 1073741823ms</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">LowPriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span> <span class="token comment">// 10000ms</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">NormalPriority</span><span class="token operator">:</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span> <span class="token comment">// 5000ms</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> timeout<span class="token punctuation">;</span>

  <span class="token keyword">var</span> newTask <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> taskIdCounter<span class="token operator">++</span><span class="token punctuation">,</span>
    callback<span class="token punctuation">,</span>
    priorityLevel<span class="token punctuation">,</span>
    startTime<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
    <span class="token literal-property property">sortIndex</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>콜백의 실행 시점을 나타내는 데이터에는 <code class="language-text">startTime</code>과 <code class="language-text">expirationTime</code>이 있습니다.</p>
<p><code class="language-text">startTime</code>은 콜백이 실행되어야 하는 시점을 나타냅니다. 코드를 보면 <code class="language-text">startTime</code>은 현재 시간이 됩니다<up>12</up>. 이 말인 즉슨 등록되는 콜백은 모두 바로 실행되어야 하는 대상이라는 의미입니다.<br>
<code class="language-text">expirationTime</code>은 바로 실행했으면 좋겠지만, 여유가 안된다면 어느 정도의 지연은 허용하는데, 이때의 지연 정도를 나타내며 콜백의 우선순위에 따라 결정됩니다<up>15~30</up>.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L373-L374">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">unstable_scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*..*/</span>
  <span class="token keyword">var</span> newTask <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> taskIdCounter<span class="token operator">++</span><span class="token punctuation">,</span>
    callback<span class="token punctuation">,</span>
    priorityLevel<span class="token punctuation">,</span>
    startTime<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
    <span class="token literal-property property">sortIndex</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// taskQueue의 정렬 기준은 지연 정도를 나타내는 expirationTime이다.</span>
<span class="gatsby-highlight-code-line">  newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime</span><span class="gatsby-highlight-code-line">  <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span></span>
  <span class="token comment">/*..*/</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">taskQueue</code>에 등록된 모든 Task는 실행 대상이므로 정렬 기준은 <code class="language-text">startTime</code>이 아닌 만료 시간이 임박한 콜백이 되어야 하므로 <code class="language-text">expirationTime</code>이 됩니다<up>14</up>.</p>
<blockquote>
<p>리액트는 최소힙 구현을 동작과 데이터를 분리하여 구현하였습니다(<a href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/SchedulerMinHeap.js" target="_">참고</a>).</p>
</blockquote>
<p>이제 <code class="language-text">taskQueue</code>에 있는 Task를 실행해주어야 합니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L381-L387">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">unstable_scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*..*/</span>
  newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime
  <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHostCallbackScheduled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isPerformingWork<span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MessageChannel</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line"></span><span class="gatsby-highlight-code-line">  <span class="token keyword">return</span> newTask<span class="token punctuation">;</span></span><span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Scheduler는 <code class="language-text">taskQueue</code>를 비우는 반복문 역할을 하는 <code class="language-text">flushWork()</code>을 비동기로 실행(<a href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L569-L574" target="_">MessageChannel을 활용</a>)시킵니다<up>9</up>. 마지막으로 등록된 콜백을 반환<up>11</up>하면서 Reconciler에서 root에 해당 콜백을 callbackNode에 기록할 수 있도록 합니다.</p>
<p>이제 Scheduler는 브라우저를 최대한 차단하지 않는 선에서 <code class="language-text">taskQueue</code>를 모두 비우면 됩니다.</p>
<p><code class="language-text">flushWork()</code>는 내부적으로 <code class="language-text">taskQueue</code>을 비울 반복문인 <code class="language-text">workLoop()</code>을 호출합니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L147-L244">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">flushWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">hasTimeRemaining</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span> <span class="token literal-property property">initialTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">workLoop</span><span class="token punctuation">(</span>hasTimeRemaining<span class="token punctuation">,</span> initialTime<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">hasTimeRemaining</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span> <span class="token literal-property property">initialTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currentTime <span class="token operator">=</span> initialTime
  currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span> <span class="token comment">// 등록된 Task 중 만료 시간이 가장 임박한 Task를 선택한다.</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*...*/</span>

    currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/*...*/</span>
<span class="token punctuation">}</span></code></pre></div>
<p>반복은 브라우저를 차단하지 않는 선에서 진행됩니다. 다만, 브라우저가 항상 1순위는 아닙니다. 브라우저에게 메인 스레드를 매번 양보한다면 리액트 앱의 응답성은 현저히 떨어질 것입니다. 그렇기 때문에 차단을 감안하고 콜백을 실행시켜야 하는 상황도 있습니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L147-L244">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">hasTimeRemaining</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span> <span class="token literal-property property">initialTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currentTime <span class="token operator">=</span> initialTime
  currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">     <span class="token keyword">if</span> <span class="token punctuation">(</span></span><span class="gatsby-highlight-code-line">      currentTask<span class="token punctuation">.</span>expirationTime <span class="token operator">></span> currentTime <span class="token operator">&amp;&amp;</span></span><span class="gatsby-highlight-code-line">      <span class="token punctuation">(</span><span class="token operator">!</span>hasTimeRemaining <span class="token operator">||</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">break</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>
    <span class="token comment">/*...*/</span>

    currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>브라우저에 양보를 해야 할 때<up>9</up> 아직 Task가 만료되지 않았다면<up>8</up> 잠시 실행을 보류하고 반복문을 종료합니다. 반복문을 종료할 때 중요한 점은 아직 남아있는 Task가 있음을 알려<up>19~23</up> 반복문이 다시 실행될 수 있게 하는 것입니다.</p>
<p>아직 브라우저에 양보할 때가 아니거나 Task가 만료되었다면 콜백을 실행시킵니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L204-L231">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight has-highlighted-lines" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">hasTimeRemaining</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span> <span class="token literal-property property">initialTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currentTime <span class="token operator">=</span> initialTime
  currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="gatsby-highlight-code-line">    <span class="token keyword">const</span> callback <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>callback<span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 콜백을 실행할 예정이므로 Task를 초기화한다.</span></span><span class="gatsby-highlight-code-line"></span><span class="gatsby-highlight-code-line">      <span class="token keyword">const</span> continuationCallback <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> continuationCallback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">        currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> continuationCallback<span class="token punctuation">;</span> <span class="token comment">// 콜백이 완료되지 않았기 때문에 다시 추가한다.</span></span><span class="gatsby-highlight-code-line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">        <span class="token comment">// Task Queue의 최상단 콜백이 현재 실행이 완료된 콜백이라면 제거한다.</span></span><span class="gatsby-highlight-code-line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">          <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">        <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line">      <span class="token punctuation">}</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span><span class="gatsby-highlight-code-line">      <span class="token comment">// Task의 콜백이 비어있다는 것은 이미 실행이 완료된 Task를 의미함으로 제거한다.</span></span><span class="gatsby-highlight-code-line">      <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span></span>
    currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>기억을 더듬어 Concurrent Render에서 렌더링이 아직 완료되지 않고 중단했을 때 이를 알리기 위한 렌더링 함수를 반환하는 부분이 있었습니다. 이때 반환받는 곳이 여기<up>14</up>입니다.</p>
<p>마지막으로 현재의 반복문이 완료된 상태로 종료된 게 아니라면 메인 스레드를 브라우저에 잠시 양보한 후 다시 시작해야 합니다.</p>
<p><a class="code_link" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/scheduler/src/forks/Scheduler.js#L515-L548">scheduler > Scheduler.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">‎
<span class="token keyword">const</span> <span class="token function-variable function">performWorkUntilDeadline</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> hasMoreWork <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    hasMoreWork <span class="token operator">=</span> <span class="token function">scheduledHostCallback</span><span class="token punctuation">(</span>hasTimeRemaining<span class="token punctuation">,</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return flushWork() > workLoop()</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasMoreWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">schedulePerformWorkUntilDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MessageChanne</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>이를 바탕으로 Concurrent Render가 중간에 중단되었어도 이제 자연스레 다음 틱에 렌더링을 다시 시작할 수 있습니다.</p>
<h1 id="auto-batching" style="position:relative;"><a href="#auto-batching" aria-label="auto batching permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto Batching</h1>
<p>리액트 18 이전에는 React 이벤트 시스템 안에서 발생한 업데이트만 일괄처리할 수 있었지만, 지금은 Lane을 통해 모든 업데이트를 구분할 수 있게 되었고 개별 처리와 일괄 처리 렌더링 시작을 나누면서 기존 문제점을 개선할 수 있게 되었습니다. 여기에서 Auto Batching을 비활성화하고 개별적인 업데이트 렌더링을 가져가고 싶다면 Reconciler의 flushSync()을 사용하면 됩니다. <strong>case 10</strong>에셔 확인해보세요.</p>
<iframe src="https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_10.js&runonclick=1"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="use-case"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
<p><code class="language-text">flushSync()</code>의 내부 구현사항은 다음과 같습니다.</p>
<p><a class="code_link_2" target="blink" href="https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1386-L1388">reconciler > ReactFiberWorkLoop.js</a></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber 0" class="language-js line-numbers"><code class="language-js">‎
<span class="token keyword">function</span> <span class="token function">flushSync</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*...*/</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">setCurrentUpdatePriority</span><span class="token punctuation">(</span>DiscreteEventPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>executionContext <span class="token operator">&amp;</span> <span class="token punctuation">(</span>RenderContext <span class="token operator">|</span> CommitContext<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> NoContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">flushSyncCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">fn</code> 콜백을 실행하기 전에 업데이트의 우선순위를 <code class="language-text">DiscreteEventPriority</code>로 설정해<up>5</up> 놓습니다. 이렇게 설정하면 콜백에서 생성되는 업데이트<up>6</up>는 모두 Sync Lane이 할당되고 렌더링 콜백은 Reconciler의 내부 큐에 추가됩니다.
그리고 나서 동기적으로 바로 <code class="language-text">flushSyncCallbacks()</code>를 실행<up>9</up>시켜 렌더링을 시작합니다.</p>
<h1 id="멱등성" style="position:relative;"><a href="#%EB%A9%B1%EB%93%B1%EC%84%B1" aria-label="멱등성 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>멱등성</h1>
<p>멱등성이란 연산을 여러 번 적용하여도 결과는 달라지지 않는 성질을 뜻합니다. 이 성질이 리액트와 어떤 연관이 있을까요?
리액트 18로 넘어오면서 Render Phase는 렌더링이 완료되지 않아도 여러 번 진행될 수 있고 진행 중이던 작업물을 폐기할 수도 있게 되었습니다. Reconciler는 VDOM을 만들어 가는 과정을 여러 번 반복하여도 반드시 결과가 달라지지 말아야 합니다. 그리고 리액트는 이 과정에서 멱등성을 보장합니다.</p>
<p>다만, 이런 책임이 이제는 리액트에만 있는 것이 아닌 개발자도 이를 보장해주어야 합니다. Sync Render만을 사용했던 18 이전에는 컴포넌트가 렌더링 되면 반드시 Commit 되었습니다. 하지만 이제는 상황이 달라졌습니다. 컴포넌트가 렌더링 되었지만 마운트되지 않을 수도 있고 또는 제거되었지만 같은 상태를 가진 트리를 빠르게 재구축하려 할 수도 있습니다(탭 전환과 같은 상황). 이런 과정에서 useEffect와 같은 함수를 잘못 사용한다면 렌더링 횟수에 따라 결과가 매번 달라질 수 있게 됩니다.</p>
<p>그래서 리액트 측은 이런 개발자의 실수를 미연에 방지하고자 Strict Mode의 동작 방식을 다음과 같이 수정하였습니다.</p>
<p><strong>Before</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">* React mounts the component.
  * Layout effects are created.
  * Effects are created.</code></pre></div>
<p><strong>After</strong></p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">* React mounts the component.
  * Layout effects are created.
  * Effects are created.
* React simulates unmounting the component.
  * Layout effects are destroyed.
  * Effects are destroyed.
* React simulates mounting the component with the previous state.
  * Layout effects are created.
  * Effects are created.</code></pre></div>
<p>개발 과정에서 미리 <strong>Mount - UnMount - Mount</strong>를 진행하여 멱등성이 보장되는지 표면적으로 표시될 수 있도록 하기 위함입니다.</p>
<hr>
<p>지금까지 렌더링이 동시성을 가지기 위한 요구사항을 확인해 보았는데, 조금 긴 내용이라 전환 업데이트의 심플한 상황으로 흐름을 다시 되짚어 보면서 마무리하겠습니다.</p>
<ol>
<li>업데이트가 발생하면 Transition Lane을 할당하고 Scheduler에게 performConcurrentWorkOnRoot 콜백을 등록합니다.</li>
<li>Scheduler는 적절한 타이밍에 콜백을 실행시킵니다.</li>
<li>Reconciler는 렌더링 대상이 Blocking이거나 Expired Lane이 아니기 때문에 Concurrent Render를 진행합니다.</li>
<li>Reconciler는 렌더링을 점진적으로 진행하다 Scheduler로 부터 양보해야 함을 확인하고 렌더링을 중단합니다.</li>
<li>Scheduler는 실행되어야 하는 Task들이 남아 있기 때문에 양보함과 동시에 반복문을 다음 틱으로 넘깁니다.</li>
<li>다음 틱에 반복문을 다시 실행합니다.</li>
<li>Reconciler는 현재 렌더링 대상인 Lane과 이전 진행 중이던 렌더링 Lane이 다르지 않다면 기존 포인터를 기반으로 Concurrent Render를 이어서 진행합니다.</li>
</ol>
<h1 id="마무리" style="position:relative;"><a href="#%EB%A7%88%EB%AC%B4%EB%A6%AC" aria-label="마무리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>마무리</h1>
<p>리액트 18로 넘어오면서 앱에서 발생하는 업데이트와 렌더링을 바라보는 관점이 많이 확장되었기 때문에 이를 이해하는 게 더욱 중요해졌습니다. 앞으로 Data fetch API와 같이 이와 관련된 기능들이 추가될 예정이기도 합니다.</p>
<p>아마 이번 주제와 관련해서 제가 이해하지 못한 이론들이 있을 것으로 생각됩니다. 다만. 리액트 18 기저에 깔린 내용은 이와 크게 다르지는 않습니다. 여기에 부족한 부분은 여러분들이 채워 나가리라 생각하고 이번 주제는 여기서 마무리하도록 하겠습니다. 길고 불친절한 글을 끝까지 읽어 주셔서 감사합니다🙏.</p></div><hr class="custom-hr"/><div class="bio"><div class="author"><div class="author-description"><a class="link" href="/"><img class="author-image" src="/static/felog-f24356c48475809626ea0c2ac67855c6.png" style="width:72px;height:79px"/></a><div class="author-name"><div><a class="author-name-content"><div><div style="float:left"><svg aria-hidden="true" focusable="false" class="bio_fontaswesome" data-prefix="fas" data-icon="envelope" role="img" width="1em" display="inline-block" font-size="inherit" height="1em" overflow="visible" viewBox="0 0 496 512"><path fill="currentColor" d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg> <!-- -->kgc4958@gmail.com</div></div></a></div><div class="author-introduction">오픈소스를 톺아보며 매직 코드라 생각했던 부분들의 동작 원리와 의미, 의도를 파악해보고 서로의 생각을 나누기 위한 블로그</div></div></div></div></div><ul class="navigator"><li class="left_navi"><a rel="prev" href="/react/in-depth-react18-transition_2/">← <!-- -->React 18 톺아보기 - 03. Transition Lane_2</a></li><li class="right_navi"></li></ul><div class="utterences"></div><footer class="footer">©<a>Goidle</a>, Built with<!-- --> <a href="https://github.com/JaeYeopHan/gatsby-starter-bee">Gatsby-starter-bee</a></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-WZKRVFR10G"></script><script>
      
      
      if(true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){window.dataLayer && window.dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-WZKRVFR10G', {"send_page_view":false});gtag('config', 'UA-154981109-1', {"send_page_view":false});
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/react/in-depth-react18-concurrent_render/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-3df9f584718eda9580a2.js"],"app":["/app-fe38415449496a7ca990.js"],"component---node-modules-gatsby-plugin-offline-app-shell-js":["/component---node-modules-gatsby-plugin-offline-app-shell-js-44ceac2081f421b30e8f.js"],"component---src-pages-404-js":["/component---src-pages-404-js-2a7b760bae899f5e9b0c.js"],"component---src-pages-index-js":["/component---src-pages-index-js-b4c60ce3b2e714c9e16c.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-26aea61718c6277f711a.js"]};/*]]>*/</script><script src="/polyfill-3df9f584718eda9580a2.js" nomodule=""></script><script src="/component---src-templates-blog-post-js-26aea61718c6277f711a.js" async=""></script><script src="/cd7d5f864fc9e15ed8adef086269b0aeff617554-6020d22b933a677a17bf.js" async=""></script><script src="/d5d7a013bc6c1e2b6d7db819052c16d7efea5559-707e424af4a0a27cbbeb.js" async=""></script><script src="/styles-0ec71dd62c66cb95665c.js" async=""></script><script src="/app-fe38415449496a7ca990.js" async=""></script><script src="/framework-8de36d3fd07627b19105.js" async=""></script><script src="/webpack-runtime-1fa11aca75e3a2c54418.js" async=""></script></body></html>