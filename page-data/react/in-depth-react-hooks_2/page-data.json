{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react-hooks_2/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"f5d1eff1-d17a-5c1e-a9fb-8a160e1a9ae5","excerpt":"모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 3. Hook은 어떻게 구현되어 있을까? 이전 포스트에 이어서 다음은 update 구현체를 보도록 하겠습니다. update 구현체 1. 훅 객체 가지고 오기 훅의 구현체는 컴포넌트가 마운트된 이후에는 항상 update…","html":"<blockquote>\n<p>모든 설명은 v16.12.0 버전 함수형 컴포넌트 기준입니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.</p>\n</blockquote>\n<h1 id=\"3-hook은-어떻게-구현되어-있을까\"><a href=\"#3-hook%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"3 hook은 어떻게 구현되어 있을까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Hook은 어떻게 구현되어 있을까?</h1>\n<p>이전 포스트에 이어서 다음은 update 구현체를 보도록 하겠습니다.</p>\n<h2 id=\"update-구현체\"><a href=\"#update-%EA%B5%AC%ED%98%84%EC%B2%B4\" aria-label=\"update 구현체 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>update 구현체</h2>\n<h3 id=\"1-훅-객체-가지고-오기\"><a href=\"#1-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%98%A4%EA%B8%B0\" aria-label=\"1 훅 객체 가지고 오기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 훅 객체 가지고 오기</h3>\n<p>훅의 구현체는 컴포넌트가 마운트된 이후에는 항상 update 구현체를 사용합니다. 구현체를 갈아 끼우는 <code class=\"language-text\">renderWithHooks()</code>를 다시 한 번 더 확인해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > renderWithHooks()</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">renderWithHooks</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 훅이 사용되었다면 memoizedState에 훅 리스트가 존재</span>\n  nextCurrentHook <span class=\"token operator\">=</span> current <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> current<span class=\"token punctuation\">.</span>memoizedState <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// mount, update 여부에 따라 구현체 주입</span>\n  ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span>\n    nextCurrentHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> HooksDispatcherOnMount <span class=\"token punctuation\">:</span> HooksDispatcherOnUpdate\n\n  <span class=\"token comment\">// let children = Component(props, refOrContext)</span>\n\n  <span class=\"token comment\">// 컴포넌트 실행 후 처리된 훅 리스트를 저장</span>\n  renderedWork<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> firstWorkInProgressHook\n  <span class=\"token comment\">// 비동기로 훅을 사용할 경우를 대비한 error throw 구현체</span>\n  ReactCurrentDispatcher<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> ContextOnlyDispatcher\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>마운트 이후 컴포넌트가 실행될 때마다 우리가 작성한 <code class=\"language-text\">useState()</code>는 다음의 <code class=\"language-text\">updateState()</code> 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateState()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span>basicStateReducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">updateState()</code>는 그저 <code class=\"language-text\">updateReducer()</code>로 포워딩하는 함수입니다. 그리고 함수 이름에서 알 수 있듯이 <code class=\"language-text\">useReducer()</code>의 update 구현체입니다. <code class=\"language-text\">useState()</code>는 <code class=\"language-text\">action</code>을 처리하는 reducer가 <code class=\"language-text\">basicStateReducer</code>로 고정된 훅입니다. 두 개의 차이는 reducer를 사용자가 넘겨준 reducer를 사용하느냐 아니면 basic을 사용하느냐의 차이만 있습니다.</p>\n<p>첫 시작을 마운트는 훅을 만들었고 업데이트는 이전에 만들어논 훅을 가지고 옵니다. 훅의 head는 <code class=\"language-text\">renderWithHooks()</code>에서 미리 꺼내 놓았던 <code class=\"language-text\">nextCurrentHook</code>을 사용합니다. 그리고 모든 훅은 이 타이밍에 이전 훅을 바로 사용하지 않고 VDOM처럼 작업용 훅 객체 만들어서 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateState() > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer() > updateWorkInProgressHook()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// if (nextWorkInProgressHook !== null) {</span>\n  <span class=\"token comment\">// 리-렌더링시 아래에서 만들어논 객체를 재사용하는 로직..</span>\n  <span class=\"token comment\">// } else {</span>\n  <span class=\"token comment\">// current의 훅 head</span>\n  currentHook <span class=\"token operator\">=</span> nextCurrentHook\n  <span class=\"token comment\">// 작업용 훅 객체를 만든다.</span>\n  <span class=\"token keyword\">const</span> newHook<span class=\"token punctuation\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    memoizedState<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span>\n\n    baseState<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>baseState<span class=\"token punctuation\">,</span>\n    queue<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">,</span>\n    baseUpdate<span class=\"token punctuation\">:</span> currentHook<span class=\"token punctuation\">.</span>baseUpdate<span class=\"token punctuation\">,</span>\n\n    next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// This is the first hook in the list.</span>\n    workInProgressHook <span class=\"token operator\">=</span> firstWorkInProgressHook <span class=\"token operator\">=</span> newHook\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Append to the end of the list.</span>\n    workInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newHook\n  <span class=\"token punctuation\">}</span>\n  nextCurrentHook <span class=\"token operator\">=</span> currentHook<span class=\"token punctuation\">.</span>next\n  <span class=\"token comment\">// }</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>컴포넌트는 실행될 때마다 추가적인 업데이트가 발생할 수 있었습니다. 이때 재실행마다 매번 작업용 훅 객체를 새로만들 필요가 없기 때문에 위에서 만들어놓은 훅 객체를 재사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer() > updateWorkInProgressHook()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// nextWorkInProgressHook를 통해 컴포넌트 재실행으로 인한 호출인지 판단</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextWorkInProgressHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// There's already a work-in-progress. Reuse it.</span>\n    workInProgressHook <span class=\"token operator\">=</span> nextWorkInProgressHook\n    nextWorkInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next\n    <span class=\"token comment\">// current hook</span>\n    currentHook <span class=\"token operator\">=</span> nextCurrentHook\n    nextCurrentHook <span class=\"token operator\">=</span> currentHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> currentHook<span class=\"token punctuation\">.</span>next <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 훅 연결 리스트의 head</span>\n    <span class=\"token comment\">// currentHook = nextCurrentHook;</span>\n    <span class=\"token comment\">// 생략..</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> workInProgressHook\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">renderWithHooks()</code>에서 컴포넌트를 재실행시켜주는 로직을 보면 컴포넌트 실행 직전에 다음과 같이 전역변수를 셋팅했었습니다.\n<code class=\"language-text\">firstWorkInProgressHook</code>은 작업용 훅을 만들때 전역으로 잡아 두었고 <code class=\"language-text\">nextCurrentHook</code>은 current fiber에서 꺼내옵니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > renderWithHooks()</span>\nnextCurrentHook <span class=\"token operator\">=</span> current <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> current<span class=\"token punctuation\">.</span>memoizedState <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\nnextWorkInProgressHook <span class=\"token operator\">=</span> firstWorkInProgressHook\n<span class=\"token comment\">// children = Component(props, refOrContext);</span></code></pre></div>\n<h3 id=\"2-code-classlanguage-textbaseupdatecode와-circular-linked-list\"><a href=\"#2-code-classlanguage-textbaseupdatecode%EC%99%80-circular-linked-list\" aria-label=\"2 code classlanguage textbaseupdatecode와 circular linked list permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. <code class=\"language-text\">baseUpdate</code>와 <em>Circular Linked List</em></h3>\n<p>훅 객체를 만들 때 설명을 생략했던 <code class=\"language-text\">baseUpdate</code>와 <code class=\"language-text\">baseState</code>, 그리고 update가 왜 <em>Circular Linked List</em>인지 알아볼 차례가 왔습니다. 기억나지 않을 수 있으니 해당 부분만 뜯어오겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > mountState() > mountWorkInProgressHook()</span>\n<span class=\"token keyword\">const</span> hook<span class=\"token punctuation\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  memoizedState<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 컴포넌트에 적용된 마지막 상태값</span>\n  queue<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 훅이 여러 번 실행될 때 update들을 queue에 연결리스트로 저장한다.</span>\n  next<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 다음 훅을 가리키는 노드 포인터</span>\n\n  <span class=\"token comment\">// 이하 update 구현체에서 설명</span>\n  baseState<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  baseUpdate<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// reconciler > ReactFiberHooks.js > dispatchAction()</span>\n<span class=\"token comment\">// update를 queue에 연결리스트로 추가</span>\n<span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>last\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// This is the first update. Create a circular list.</span>\n  update<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> last<span class=\"token punctuation\">.</span>next\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Still circular.</span>\n    update<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> first\n  <span class=\"token punctuation\">}</span>\n  last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update\n<span class=\"token punctuation\">}</span>\nqueue<span class=\"token punctuation\">.</span>last <span class=\"token operator\">=</span> update</code></pre></div>\n<p>훅과 <code class=\"language-text\">queue</code>에 대해서 한 번 더 개념을 잡고 가겠습니다.</p>\n<p><code class=\"language-text\">queue</code>는 update를 담고 있습니다. 우리는 항상 update를 이 <code class=\"language-text\">queue</code>에 연결 리스트로 추가해줍니다. 그리고 컴포넌트 업데이트일 때 <code class=\"language-text\">queue</code>에서 update 리스트를 꺼내와 적용시킵니다. 문제는 update를 적용시킬 때 항상 head부터 시작하게 되면 중복 적용될 수가 있습니다.<br>\n그래서 적용된 부분과 아직 적용되지 않은 부분의 경계선을 정해줄 필요가 있습니다. 그래야 이 경계선을 기준으로 적용되지 않은 부분의 update들만 소비할 수 있으며 이미 적용된, 더는 사용하지 않을 update 객체를 건너뛰고 동시에 gc를 위해 참조도 끊어줄 수 있습니다.</p>\n<p>그럼 이 경계선에 대한 지식은 누가 알고 있어야 할까요? 리액트는 이 지식을 <code class=\"language-text\">queue</code>가 아닌 훅 객체가 알고 있어야 한다고 생각했습니다. 그리고 그 정보는 <code class=\"language-text\">baseUpdate</code>, <code class=\"language-text\">baseState</code>에 담기게 됩니다. <code class=\"language-text\">baseUpdate</code>는 적용된 update의 tail 포인터이며 <code class=\"language-text\">baseState</code>는 tail update를 실행한 괏값입니다. 이제 이 base를 기준으로 next는 모두 적용되지 않은 훅 리스트입니다.</p>\n<p>근데 <code class=\"language-text\">queue</code>는 <code class=\"language-text\">last</code>에 마지막 update만 담고 있습니다. 이러면 tail만 알 수 있지 head는 모릅니다. 더군다나 훅 객체의 <code class=\"language-text\">baseUpdate</code>도 처음에는 적용된 update가 없으므로 null입니다.</p>\n<p>이러한 케이스 때문에 컴포넌트가 첫 업데이트를 실행하기 전까지는 head를 어딘가에서 물고 있어야 하므로 <code class=\"language-text\">update</code>가 저장되는 <code class=\"language-text\">queue</code>를 <em>Circular Linked List</em>로 만들어 tail update의 next가 head를 물고 있게 해준겁니다.</p>\n<p>컴포넌트가 한번이라도 업데이트 되면 이 <em>Circular Linked List</em>를 끊어주고 모든 update를 적용시킨 후 <u>tail update와 그 결괏값</u>을 훅의 <code class=\"language-text\">baseUpdate</code>, <code class=\"language-text\">baseState</code>에 할당합니다.</p>\n<p>이 이유 때문에 <code class=\"language-text\">dispatchAction()</code>에서 update를 연결 리스트로 추가하는 로직을 보면 <code class=\"language-text\">last</code>의 next가 있는지 확인하는 부분이 바로 head를 훅의 <code class=\"language-text\">baseUpdate</code>에서 물고 있는지 아니면 <code class=\"language-text\">queue</code>에서<em>Circular Linked List</em>를 통해 물고 있는지 확인하는 의미가 되겠습니다.</p>\n<h3 id=\"3-update-적용-시키기\"><a href=\"#3-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0\" aria-label=\"3 update 적용 시키기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. update 적용 시키기</h3>\n<p>render phase update에서 모든 update을 <code class=\"language-text\">renderPhaseUpdates</code> 맵에 담아두었던 걸 기억하시나요? 이 맵에 있는 update 리스트를 소비하는 로직이 다음 하이라이트 부분입니다. 해당 로직은 <code class=\"language-text\">updateReducer()</code> 의 나머지 로직을 먼저 보고 난 후에 확인하도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const hook = updateWorkInProgressHook();</span>\n\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>queue\n  queue<span class=\"token punctuation\">.</span>lastRenderedReducer <span class=\"token operator\">=</span> reducer <span class=\"token comment\">// updateState는 basicStateReducer</span>\n  <span class=\"token comment\">// 컴포넌트 재실행 판단</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numberOfReRenders <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// renderPhaseUpdates 소비 로직..</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 훅을 가지고 왔으니 <code class=\"language-text\">queue</code>에 있는 update를 적용시킬 차례입니다. 로직은 간단합니다.</p>\n<ol>\n<li>적용시킬 update의 head를 가지고 온다.</li>\n<li>훅의 <code class=\"language-text\">baseUpdate</code> 또는 <code class=\"language-text\">queue</code>의 <code class=\"language-text\">last.next</code></li>\n<li><em>Circular Linked List</em> 라면 더이상 head를 <code class=\"language-text\">queue</code>가 알고 있을 필요가 없으니 last의 next에 null을 할당하여 연결을 끊어준다.</li>\n<li>head부터 tail까지 순회하면서 <code class=\"language-text\">reducer</code>에 <code class=\"language-text\">action</code>을 던져 결괏값을 취한다.</li>\n<li>update를 모두 실행했다면 결과를 저장한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 생략..</span>\n  <span class=\"token comment\">// 컴포넌트 재실행 판단</span>\n  <span class=\"token comment\">// if (numberOfReRenders > 0) {</span>\n  <span class=\"token comment\">// renderPhaseUpdates 소비 로직..</span>\n  <span class=\"token comment\">// }</span>\n  <span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>last\n  <span class=\"token keyword\">const</span> baseUpdate <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseUpdate <span class=\"token comment\">// 적용된 리스트의 tail update</span>\n  <span class=\"token keyword\">const</span> baseState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseState\n\n  <span class=\"token comment\">// 1. 적용시킬 update의 head를 가지고 온다.</span>\n  <span class=\"token keyword\">let</span> first\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>baseUpdate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 첫 업데이트가 커밋된 이후에는 baseUpdate가 존재하기 때문에</span>\n      <span class=\"token comment\">// 더 이상 Circular Linked List는 필요가 없다. 다음 컴포넌트 업데이트 부터는 연결을 끊어준다.</span>\n    <span class=\"token punctuation\">}</span>\n    first <span class=\"token operator\">=</span> baseUpdate<span class=\"token punctuation\">.</span>next <span class=\"token comment\">// baseUpdate의 head 참조</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    first <span class=\"token operator\">=</span> last <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> last<span class=\"token punctuation\">.</span>next <span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// Circular Linked List의 head 참조</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 2. head부터 tail까지 순회하면서  reducer에 action을 던져 결괏값을 취한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> baseState\n    <span class=\"token keyword\">let</span> prevUpdate <span class=\"token operator\">=</span> baseUpdate\n    <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> first\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action\n      newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span>\n      prevUpdate <span class=\"token operator\">=</span> update\n      update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> update <span class=\"token operator\">!==</span> first<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// 3. update를 모두 실행했다면 결과를 저장한다.</span>\n    hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState\n    hook<span class=\"token punctuation\">.</span>baseUpdate <span class=\"token operator\">=</span> prevUpdate <span class=\"token comment\">// 적용된 tail update</span>\n    hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> newState\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>dispatch\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음은 생략했던 <code class=\"language-text\">renderPhaseUpdates</code>을 사용하여 update를 적용시키는 방법을 알아보겠습니다.</p>\n<h3 id=\"4-render-phase-update-적용-시키기\"><a href=\"#4-render-phase-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0\" aria-label=\"4 render phase update 적용 시키기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. render phase update 적용 시키기</h3>\n<p>update를 소비하는 로직은 바로 위에서 본 로직과 별 다르지 않기 때문에 설명은 생략합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// reconciler > ReactFiberHooks.js > updateReducer()</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const hook = updateWorkInProgressHook();</span>\n  <span class=\"token comment\">// const queue = hook.queue;</span>\n  <span class=\"token comment\">// queue.lastRenderedReducer = reducer;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numberOfReRenders <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>dispatch\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>renderPhaseUpdates <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> firstRenderPhaseUpdate <span class=\"token operator\">=</span> renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstRenderPhaseUpdate <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState\n        <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> firstRenderPhaseUpdate\n\n        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action\n          newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span>\n          update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n\n        hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">.</span>baseUpdate <span class=\"token operator\">===</span> queue<span class=\"token punctuation\">.</span>last<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// queue의 마지막이 이미 다 적용된 update라면</span>\n          <span class=\"token comment\">// 처리해야 할 update가 남아 있지 않은 것이기 때문에 여기서 처리된 state를 할당해도 된다.</span>\n          hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> newState\n        <span class=\"token punctuation\">}</span>\n\n        queue<span class=\"token punctuation\">.</span>lastRenderedState <span class=\"token operator\">=</span> newState\n\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>newState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 생략..</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기까지가 훅 update 구현체 전부입니다.<br>\n다음의 리액트 흐름 중 1번과 3번의 일부분(<down>재조정 작업 중 컴포넌트를 실행해서 update를 적용 시켜주는 부분</down>)을 보았습니다.</p>\n<ol>\n<li>훅을 통해 컴포넌트 상태를 업데이트한다.</li>\n<li>VDOM 재조정을 해줄 Work를 scheduler에게 스케줄링 시키고 scheduler가 스케줄링된 Task를 꺼내 실행한다</li>\n<li>Work을 통해 VDOM 재조정 작업을 진행한다.</li>\n<li>완성된 VDOM을 commit phase에서 처리하여 DOM에 적용시킨다.</li>\n<li>사용자의 상호작용으로 이벤트가 발생하고 해당 이벤트에 등록된 핸들러가 실행되면서 다시 1번으로 되돌아간다.</li>\n</ol>\n<p>useReducer는 useState와 같은 구현체 쓰고 useEffect는 commit phase 때 추가 적으로 확인하게 될 것으로 이를 제외한 나머지 훅들도 궁금하신 분들은 직접 한번 분석해보시길 추천해 드립니다.</p>\n<p>다음 포스트는 2번 scheduler를 분석합니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">목록</th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><a href=\"/react/in-depth-react-hooks_1/\">React 톺아보기- 03. Hooks_1</a></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><a href=\"/react/in-depth-react-scheduler_1/\">React 톺아보기- 04. Scheduler_1</a></td>\n</tr>\n</tbody>\n</table>","frontmatter":{"title":"React 톺아보기- 03. Hooks_2","date":"2020-06-15","keywords":["리액트","react","fiber","hook","hooks","useState","useEffect","useLayoutEffect","useCallback"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react/in-depth-react-hooks_2/","previous":{"fields":{"slug":"/react/in-depth-react-hooks_1/"},"frontmatter":{"title":"React 톺아보기- 03. Hooks_1","category":"react"}},"next":{"fields":{"slug":"/react/in-depth-react-scheduler_1/"},"frontmatter":{"title":"React 톺아보기- 04. Scheduler_1","category":"react"}}}}}