{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react18-transition_2/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"a1345fd0-de0c-5b60-9f76-81c64bea90e8","excerpt":"Lane 모델이 해결하고자 하는 문제점을 다음과 같이 짚어보았습니다. 업데이트의 개념 분리 불필요한 렌더링 건너뛰기 우선순위가 더 높은 업데이트를 먼저 처리하기 위 세 개 모두 Transition Lane과 연관있는 기능이며 Transition Lane을 설명하기에 적절한 주제입니다. 하나씩 짚어보며 설명을 이어가겠습니다. 1. 업데이트의 개념 분리 Lane 모델에서 업데이트 개념 분리를 설명할 때 CPU와 IO Bound라는 개념을 언급했습니다. 일반적인 모든 렌더링은 CPU…","html":"<p>Lane 모델이 해결하고자 하는 문제점을 다음과 같이 짚어보았습니다.</p>\n<ul>\n<li>업데이트의 개념 분리</li>\n<li>불필요한 렌더링 건너뛰기</li>\n<li>우선순위가 더 높은 업데이트를 먼저 처리하기</li>\n</ul>\n<p>위 세 개 모두 Transition Lane과 연관있는 기능이며 Transition Lane을 설명하기에 적절한 주제입니다. 하나씩 짚어보며 설명을 이어가겠습니다.</p>\n<h1 id=\"1-업데이트의-개념-분리\" style=\"position:relative;\"><a href=\"#1-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EC%9D%98-%EA%B0%9C%EB%85%90-%EB%B6%84%EB%A6%AC\" aria-label=\"1 업데이트의 개념 분리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 업데이트의 개념 분리</h1>\n<p>Lane 모델에서 업데이트 개념 분리를 설명할 때 CPU와 IO Bound라는 개념을 언급했습니다. 일반적인 모든 렌더링은 CPU에 의존적이기 때문에 CPU-Bound에 속합니다. IO-Bound는 네트워크와 전환이 결합된 경우에만 해당합니다.</p>\n<p>리액트에서 네트워크와 관련된 컴포넌트는 <code class=\"language-text\">&lt;Suspense/></code>가 있습니다. <code class=\"language-text\">&lt;Suspense/></code>는 하위 요소가 준비되지 않았다면 Fallback을 노출하는 컴포넌트입니다. <strong>case 3</strong>를 통해서 일반 업데이트와 <code class=\"language-text\">&lt;Suspense/></code>의 동작 방식을 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_3.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>전환 업데이트 렌더링(Concurrent Render)의 특징은 사용자를 차단하지 않고 백그라운드에서 렌더링 작업을 진행하여 완료된 경우에만 사용자에게 UI를 노출하는 것입니다. UI 전환에 네트워크가 필요하여 <code class=\"language-text\">&lt;Suspense/></code>를 사용했다면 렌더링 경로의 요소들이 모두 준비되지 않는 한 렌더링을 완료하지 않습니다. 즉 해당 업데이트의 렌더링을 보류합니다. 이와 같은 이유로 <code class=\"language-text\">&lt;Suspense/></code>의 Fallback 또한 렌더링 되지 않습니다. <strong>case 4</strong>에서 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_4.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>Render Phase에서 <code class=\"language-text\">&lt;Suspense/></code>의 Fallback인 <code class=\"language-text\">[Text]: loading..</code>가 찍혔지만, Commit Phase를 진행하지 않았기 때문에 사용자에게는 노출되지 않습니다.</p>\n<p>이게 도대체 IO-Bound와 무슨 상관일까요? <code class=\"language-text\">&lt;Suspense/></code>에 대해서 인지해야 할 부분이 하나 더 있습니다. 개발을 할 때 복수의 네트워크 요청이 필요한 경우, 요청 간의 의존성이 있지 않은 한 순차적이 아닌 병렬적으로 요청을 보냅니다. <code class=\"language-text\">&lt;Suspense/></code>도 마찬가지로 렌더링 과정에서 하나의 컴포넌트가 준비되지 않았다고 바로 렌더링을 그 위치에서 중단하는 게 아닌 모든 하위 요소를 탐색하여 네트워크 요청을 발생시킵니다. <strong>case 5</strong>에서 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_5.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>다시 정리하면, <code class=\"language-text\">&lt;Suspense/></code>는 모든 하위 요소를 탐색하고 전환은 렌더링 경로의 모든 요소의 렌더링이 완료되지 않는 한 렌더링을 마무리하지 않습니다.</p>\n<p><strong>case 5</strong>에서 <code class=\"language-text\">AsyncB</code>가 완료되어 렌더링을 다시 시작했지만 <code class=\"language-text\">AsyncA</code>가 완료되지 않아 해당 렌더링은 다시 한번 보류 처리됩니다. 하지만 렌더링은 여기서 끝나지 않고 모든 하위 요소를 탐색하며 렌더링합니다. 이때의 렌더링을 바로 IO-Bound라고 합니다. 렌더링이 네트워크에 의존적인 상태이며 해당 네트워크 요청이 완료되지 않는 한 렌더링은 완료되지 못하지만, 아직 모든 렌더링 경로를 탐색한 것이 아니기 때문에 렌더링 작업이 계속 진행 중인 이때의 렌더링이 IO-Bound입니다.</p>\n<p>참고로 일반 업데이트와 <code class=\"language-text\">&lt;Suspense/></code>의 조합의 렌더링은 항상 CPU-Bound입니다. 왜냐하면, 이때의 렌더링은 절대 보류되지 않습니다. 이때의 <code class=\"language-text\">&lt;Suspense/></code>는 하위 모든 요소를 탐색한 후 하나의 요소라도 준비되지 않았다면 Fallback으로 대체하여 렌더링을 마무리하기 때문에 네트워크에 의존적인 상태에서 렌더링을 이어가는 상황은 발생할 수 없으므로 항상 CPU-Bound입니다.</p>\n<p>이제 다시 <code class=\"language-text\">업데이트의 개념 분리</code>로 돌아와서, 전환 업데이트의 렌더링 작업이 IO - CPU 순으로 발생한 경우에 IO-Bound 렌더링으로 인한 CPU-Bound 렌더링이 차단되는 상황을 짚어보겠습니다. 리액트가 현재의 렌더링이 IO-Bound임을 인지하는 시점은 <code class=\"language-text\">&lt;Suspense/></code>의 렌더링을 완료한 후 하위 요소가 아직 준비되지 않았음을 확인한 직후입니다. 리액트는 계속해서 IO-Bound 렌더링을 이어가지만, 중간에 전환 업데이트가 추가로 발생하면(interleaved update) IO-Bound 렌더링의 Lanes를 root의 <code class=\"language-text\">suspendedLanes</code>로 기록하고 신규 전환 업데이트로 렌더링을 새로 시작합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// scheduleUpdateOnFiber() &lt;- 신규 업데이트가 발생하면 호출된다.</span>\n<span class=\"token comment\">// concurrent render 과정에서 메인 스레드를 비워준 시점에 발생한 업데이트인지 확인</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> RenderContext<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> NoContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  workInProgressRootInterleavedUpdatedLanes <span class=\"token operator\">=</span> <span class=\"token function\">mergeLanes</span><span class=\"token punctuation\">(</span>\n    workInProgressRootInterleavedUpdatedLanes<span class=\"token punctuation\">,</span>\n    lane <span class=\"token comment\">// 신규 업데이트의 lane</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 현재 렌더링 경로 중에 보류된 요소가 있었는지. 즉, 현재 렌더링이 IO-Bound인지 확인.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressRootExitStatus <span class=\"token operator\">===</span> RootSuspendedWithDelay<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">markRootSuspended</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> workInProgressRootRenderLanes<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// markRootSuspended()</span>\nsuspendedLanes <span class=\"token operator\">=</span> <span class=\"token function\">removeLanes</span><span class=\"token punctuation\">(</span>\n  suspendedLanes<span class=\"token punctuation\">,</span>\n  workInProgressRootInterleavedUpdatedLanes\n<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 현재 렌더링의 Lane을 suspendedLanes로 관리하여 렌더링 대상에서 제외한다.</span>\nroot<span class=\"token punctuation\">.</span>suspendedLanes <span class=\"token operator\">|=</span> suspendedLanes\nroot<span class=\"token punctuation\">.</span>pingedLanes <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span>suspendedLanes</code></pre></div>\n<p>이제 다음 렌더링 시작 시점의 <code class=\"language-text\">getNextLanes()</code>는 <code class=\"language-text\">suspendedLanes</code>를 제외한 신규 업데이트의 전환 Lanes를 반환하면서 자연스레 이전 렌더링이 CPU-Bound의 전환 Lanes로 Interrupt 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// getNextLanes()</span>\n<span class=\"token comment\">/*...*/</span>\n<span class=\"token keyword\">const</span> suspendedLanes <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>suspendedLanes\n<span class=\"token comment\">/*...*/</span>\n<span class=\"token keyword\">const</span> nonIdleUnblockedLanes <span class=\"token operator\">=</span> nonIdlePendingLanes <span class=\"token operator\">&amp;</span> <span class=\"token operator\">~</span>suspendedLanes\nnextLanes <span class=\"token operator\">=</span> <span class=\"token function\">getHighestPriorityLanes</span><span class=\"token punctuation\">(</span>nonIdleUnblockedLanes<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">/*...*/</span></code></pre></div>\n<p>IO - CPU 상황에서 진행 중이던 IO를 중단하고 CPU를 먼저 렌더링하는 과정을 <strong>case 6</strong>에서 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_6.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>같은 전환 업데이트라도 CPU와 IO를 나눌 수 있는 이유는 Transition Lane이 하나가 아닌 복수기 때문에 가능합니다. Expiration Time과는 다르게 같은 우선순위를 가졌어도 업데이트를 다르게 배치처리할 수 있는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> TransitionLane1<span class=\"token operator\">:</span> Lane <span class=\"token operator\">=</span> <span class=\"token comment\">/*                        */</span> <span class=\"token number\">0b0000000000000000000000001000000</span>\n<span class=\"token comment\">// ~</span>\n<span class=\"token keyword\">const</span> TransitionLane16<span class=\"token operator\">:</span> Lane <span class=\"token operator\">=</span> <span class=\"token comment\">/*                       */</span> <span class=\"token number\">0b0000000001000000000000000000000</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">claimNextTransitionLane</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Lane <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> lane <span class=\"token operator\">=</span> nextTransitionLane\n  nextTransitionLane <span class=\"token operator\">&lt;&lt;=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>nextTransitionLane <span class=\"token operator\">&amp;</span> TransitionLanes<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> NoLanes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    nextTransitionLane <span class=\"token operator\">=</span> TransitionLane1\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> lane\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"2-불필요한-업데이트-건너뛰기\" style=\"position:relative;\"><a href=\"#2-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EA%B1%B4%EB%84%88%EB%9B%B0%EA%B8%B0\" aria-label=\"2 불필요한 업데이트 건너뛰기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 불필요한 업데이트 건너뛰기</h1>\n<p>자동완성 앱에서 자동완성 UI의 트리가 매우 커서 렌더링이 오래 걸린다면 다음과 같은 상황이 발생할 수 있습니다.</p>\n<img src=\"/path/to/dir/2dd173363eb87b0c02b4eddddb61cb5f/slow_transition.gif\">\n<p>사용자 입장에서 “리액” 입력이 완료된 시점에 “리”의 자동완성 UI에는 관심 없을 것입니다. 하지만 위 상황에서는 데이터 도착 순서대로 렌더링을 진행하게 되면서 이미 “리액”의 데이터가 도착했을지라도 “리” 데이터의 렌더링이 진행 중이기 때문에 렌더링이 차단됩니다. 그리고 사용자는 더 이상 관심 없는 “리”의 자동완성 UI를 확인하게 됩니다.</p>\n<p>리액트는 대규모 UI 전환 중이더라도 오래된 상태의 렌더링을 중단하고 최신 상태의 렌더링만 수행할 수 있습니다. 이를 확인하기 위해서는 렌더링 과정에서 업데이트를 어떻게 처리하는지 알아야 하므로 몇 가지 내부 구현사항을 간단히 정의하고 넘어가겠습니다.</p>\n<p>먼저 자동완성 앱에서 “리”의 렌더링이 끝난 상태에서 “리액”의 사용자 입력이 발생했다고 해봅시다. 사용자의 입력 처리 코드는 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">AutoComplete</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n  onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setInput</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"리액\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">startTransition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTransitionInput</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"리액\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드 실행 이후 Fiber를 표현하면 다음과 같습니다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 790px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.64646464646465%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC40lEQVQ4y11TS08TYRTt3zH+B1ckyqO0QB/TeT/bmem0pVLlJaWAJRQoj4pWQRqKimhi4kI2RjZEkY3BlfGVGBdujLoxro/3m7bEuLg5M/PNPd89594b4BMJsEi0g+M4Hz3Pg2Pb0FQV+eFhJC0LAs9DFAQ/2LOfR/93chgGBqNRhCIR/yUej/vIfvSyWSi6gcFYDJKuY4i+X+rvR08ohO7+EHrCYQxQbvy/QgITro1KPgdRkqDIcuuQIkLJOYFHKWWhbKdQdmwsZz1UPBfVXBZL2QzGTQMSXRijQs4qXCqMoDldhGYYyGQyvpTuYBDrmTQ+btXxubGJd5u38GXnLj5t38GHrdv42mzg/WYdvx7v4dlMEeFgHxKUx+QHkhMrSC8+QippIpfLwTJNDJAFbmQQb2qrON1Yx6vqIuEajgkPZqfxenUZxytL+LrbwPP5OYRJDU+++pJTtou0l4NNDcgSoUGVssMQeWWSnDFdQylpkfQUioQLjoWqRza5SbLCgieQPZEhXy7HxRHQKMFKJn1CJlmnBoii2EJFAS+Rr5II1XEh23Tx8CSmJueRIrTSI7C9PEwnB9V0IKkGAla+jPGNQ9iuhywRsrIlapBJ0iUiEnkZV6Y1XK9GMV5tYuf4D5pH3/Hg5DfKe29R2T/F7PYhNVLwlQVUh4OZ56EoaksumSvQAXvWNA26qkFImVjuuoAbF/vgXVvA4lwV+dE56O5lJAQZHC+Ba49cIOX1wh3tgkID7DjOGSGTLNMYybICw9aRTyYwmi5gcm0fN7eeYKb2EJmpdTiFWbiFGX/U/C6ne4NonDsPmQgMQ/erYkSMUBBJRkJCfkJCsWbganUX9Rc/cP/oG+69/InSzgmK9QNMbTwlwvbYiArNn+rApOb4Y0MrxqpUqWIW7AJR4OCMlOCNVWibYuBFapQgkd88otThWCzaWkE2NpJqwinWfKKO5M4a/hut1eJbXnWivW6d7WKkfwFKbEwOpbXQWgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"fiber structure\" title=\"fiber structure\" src=\"/static/168150f5c9f6b6cd00239f5dfb836f21/2e237/fiber_structure.png\" srcset=\"/static/168150f5c9f6b6cd00239f5dfb836f21/18f77/fiber_structure.png 198w,\n/static/168150f5c9f6b6cd00239f5dfb836f21/2cb6c/fiber_structure.png 395w,\n/static/168150f5c9f6b6cd00239f5dfb836f21/2e237/fiber_structure.png 790w,\n/static/168150f5c9f6b6cd00239f5dfb836f21/471ef/fiber_structure.png 1185w,\n/static/168150f5c9f6b6cd00239f5dfb836f21/6f464/fiber_structure.png 1464w\" sizes=\"(max-width: 790px) 100vw, 790px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n<ul>\n<li>Fiber의 memoizedState에는 컴포넌트에서 사용된 Hook을 연결 리스트 형태로 참조하고 있습니다(<a target=\"blank\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L676-L677\">참고</a>).</li>\n<li>Hook의 memoizedState에는 반영된 상태를 참조하고 있습니다(<a target=\"blank\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L896\">참고</a>).</li>\n<li>Hook에는 업데이트를 담을 큐를 가지고 있습니다(<a target=\"blank\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1514-L1521\">참고</a>).</li>\n<li>업데이트는 해당 Hook의 큐에 연결 리스트 형태로 추가됩니다(<a target=\"blank\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberConcurrentUpdates.new.js#L67-L77\">참고</a>).</li>\n<li>업데이트에는 Lane이 할당됩니다(<a target=\"blank\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L2243-L2251\">참고</a>).</li>\n<li>업데이트 생성 문자 표현을 <strong>A</strong><up>A Hook</up><strong>S</strong><up>Sync Update</up><strong>1</strong><up>생성 시점</up>의 형태로 정의하겠습니다.</li>\n</ul>\n<p>위 상황에서 사용자가 “리액트”를 입력했다고 해봅시다. Fiber 내부에서는 다음과 같은 과정을 거칩니다.</p>\n<video controls height=\"500px\">\n <source src=\"/path/to/dir/d796fd72d8703f274d31ae03ca504e27/simul_autocomplete.mp4\" type=\"video/mp4\" />\n</video>\n<p>사용자 입력 UI 업데이트<up>setInput()</up>의 Sync Lane은 우선순위가 가장 높으므로 전환 업데이트보다 먼저 렌더링을 완료합니다. 그리고 “리액” 전환 렌더링 중에 “리액트” 업데이트가 발생했습니다. Reconciler는 진행 중이던 “리액” 렌더링을 중단하고 Sync Lane인 “리액트” 업데이트를 먼저 처리합니다. 현시점에서 렌더링 대기 중인 업데이트는 “리액”, “리액트” 전환 업데이트 두 개입니다. Reconciler는 굳이 중간 상태의 렌더링을 진행하지 않고 두 전환 업데이트를 배치처리하여 최종 상태인 “리액트”를 기준으로 한 번의 렌더링으로 마무리합니다. <strong>case 7</strong>에서 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_7.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<h1 id=\"3-우선순위가-더-높은-업데이트를-먼저-처리하기\" style=\"position:relative;\"><a href=\"#3-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EA%B0%80-%EB%8D%94-%EB%86%92%EC%9D%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%A5%BC-%EB%A8%BC%EC%A0%80-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0\" aria-label=\"3 우선순위가 더 높은 업데이트를 먼저 처리하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 우선순위가 더 높은 업데이트를 먼저 처리하기</h1>\n<p>지금까지 여러 번 우선순위에 따라 업데이트의 처리 순서가 다를 수 있음을 언급했습니다. 이는 전환 업데이트의 렌더링이 비동기 점진적 진행 방식이기에 중간마다 사용자 인풋을 처리할 수 있어 가능한 부분입니다. <strong>case 8</strong>에서 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_8.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<blockquote>\n<p>느린 화면으로 확인해보면 숫자의 변경이 더 잘 확인됩니다.\n<img src=\"/path/to/dir/86d802d838b659a96fc0b3e666409623/update_priority.gif\" width=\"100%\"></p>\n</blockquote>\n<p>업데이트 처리 방식은 Git의 그것과 유사하기 때문에 Git을 예로 들면서 개념을 먼저 이해해보겠습니다.<br>\nA라는 Hook에 업데이트가 다음과 같이 발생했다고 가정해 봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">AT1 - AS2 - AT3</code></pre></div>\n<p>여기서 A Hook은 Main 브랜치이고 업데이트가 쌓이는 큐는 Feature 브랜치가 됩니다. 그리고 각 업데이트는 Feature 브랜치의 커밋이며, 현재 렌더링의 Lanes는 배포 버전 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(main) AT0\n(feature) AT1 - AS2 - AT3</code></pre></div>\n<p>업데이트 중 가장 먼저 배포해야 할 버전은 Sync Lane입니다. AS2를 Cherry pick 해서 Main 브랜치에 병합합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(main) AT0 - AS2\n(develop) AT1 - AS2 - AT3</code></pre></div>\n<p>다음 배포 대상은 Transition Lane입니다. 이때는 커밋의 순서를 맞추기 위해 Rebase를 진행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(main) AT0 - AT1 - AS2 - AT3\n(feature) AT1 - AS2 - AT3</code></pre></div>\n<p>모든 커밋이 병합되었으니 Feature 브랜치를 삭제합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(main) AT0 - AT1 - AS2 - AT3\n(feature)</code></pre></div>\n<p>우선순위에 따라 동일한 훅에서 업데이트 처리 순서가 달라질 경우 이런 Rebase 과정이 추가로 필요합니다.<br>\n만약 모든 업데이트가 같은 우선순위를 가졌다면 <em>Cherry Pick -> Rebase</em> 과정 없이 간단히 Fast Forward Merge만 진행합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(main) AT0\n(feature) AT1 - AT2 - AT3\n->\n(main) AT0 - AT1 - AT2 - AT3\n(feature)</code></pre></div>\n<p>이 과정에서 사용되는 리액트 구성 요소는 다음과 같으며 현재 필요하지 않은 속성은 생략했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 역시 Git에 빗대어 설명합니다.</span>\n<span class=\"token comment\">// Main 브랜치</span>\n<span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  memoizedState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 최종 코드</span>\n  baseQueue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 병합 대상 커밋 Head</span>\n  baseState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 병합 대상(baseQueue) 이전의 최종 코드(Fast Foward Merg만 진행했다면 memoizedState와 같다)</span>\n  queue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Feature 브랜치</span>\n  next<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 다음 Hook</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Feature 브랜치</span>\n<span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  pending<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Main 브랜치 병합 대상에 아직 포함되지 않은 갓 커밋된 커밋 Head</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Commit</span>\n<span class=\"token keyword\">const</span> update <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  action<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 작업 내역</span>\n  lane<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 배포될 버전</span>\n\n  next<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 다음 업데이트</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>case_8</strong>의 업데이트 처리 과정은 다음과 같습니다.</p>\n<video controls height=\"500px\" width=\"100%\">\n <source src=\"/path/to/dir/9280caea2e4961bc0c1ffb5d1fa36f2f/simul_update_priority.mp4\" type=\"video/mp4\" />\n</video>\n<p>이처럼 우선순위에 따라서 중간 상태는 다를 수 있지만 결국 마지막에는 Rebase를 통해 업데이트 순서를 보장하므로 마지막 상태 값은 항상 사용자 상호 작용과 일치하게 됩니다.</p>\n<p>업데이트를 처리하는 코드는 확인해볼 가치는 있지만, 길기도 하고 필수적으로 알아야 하는 내용은 아니기에 관심이 있으신 분은 확인해보세요.</p>\n<details><summary>코드 펼치기</summary>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 훅 객체를 참조한다.</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>queue\n  <span class=\"token keyword\">const</span> current <span class=\"token operator\">=</span> currentHook\n  <span class=\"token keyword\">let</span> baseQueue <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>baseQueue <span class=\"token comment\">// 병합 대상</span>\n\n  <span class=\"token comment\">// 병합 대상에 아직 포함되지 않은 커밋</span>\n  <span class=\"token keyword\">const</span> pendingQueue <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>pending\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pendingQueue <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 병합 대기중인 대상이 있는지 확인한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>baseQueue <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 병합 대상에 포함되지 않은 커밋을 가장 뒤쪽에 연결한다.</span>\n      <span class=\"token keyword\">const</span> baseFirst <span class=\"token operator\">=</span> baseQueue<span class=\"token punctuation\">.</span>next <span class=\"token comment\">// baseQueue는 원형 연결 리스트이며, 마지막 노드로 관리한다. 고로 baseQueue의 next는 원형 연결 리스트의 첫 번째 노드이다.</span>\n      <span class=\"token keyword\">const</span> pendingFirst <span class=\"token operator\">=</span> pendingQueue<span class=\"token punctuation\">.</span>next <span class=\"token comment\">// pendingQueue도 baseQueue와 같다. next는 첫 번째 노드를 가리킨다.</span>\n      baseQueue<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> pendingFirst\n      pendingQueue<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> baseFirst\n    <span class=\"token punctuation\">}</span>\n    current<span class=\"token punctuation\">.</span>baseQueue <span class=\"token operator\">=</span> baseQueue <span class=\"token operator\">=</span> pendingQueue\n    queue<span class=\"token punctuation\">.</span>pending <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 모든 커밋을 병합 대상으로 옮겼으므로 초기화한다.</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 병합할 대상이 있는지 확인한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>baseQueue <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> baseQueue<span class=\"token punctuation\">.</span>next <span class=\"token comment\">// 병합할 대상의 첫 번째 노드를 참조한다.</span>\n    <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>baseState <span class=\"token comment\">// 병합할 대상의 첫 번째 노드 이전의 main 브랜치의 최종 코드를 참조한다.</span>\n\n    <span class=\"token keyword\">let</span> newBaseState <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 병합된 최종 코드가 저장된다.</span>\n    <span class=\"token keyword\">let</span> newBaseQueueFirst <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// Rebase 대상의 첫 번째 커밋이 저장된다.</span>\n    <span class=\"token keyword\">let</span> newBaseQueueLast <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// Rebase 대상의 마지막 커밋이 저장된다.</span>\n    <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> first <span class=\"token comment\">// 병합을 진행할 커밋</span>\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> updateLane <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>lane <span class=\"token comment\">// 커밋의 배포 버전을 참조한다.</span>\n      <span class=\"token comment\">// 커밋이 현재 배포 버전에 포함되지 않는지 확인한다. (renderLanes &amp; updateLane) === updateLane;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isSubsetOfLanes</span><span class=\"token punctuation\">(</span>renderLanes<span class=\"token punctuation\">,</span> updateLane<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> clone <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n          lane<span class=\"token operator\">:</span> updateLane<span class=\"token punctuation\">,</span>\n          action<span class=\"token operator\">:</span> update<span class=\"token punctuation\">.</span>action<span class=\"token punctuation\">,</span>\n          hasEagerState<span class=\"token operator\">:</span> update<span class=\"token punctuation\">.</span>hasEagerState<span class=\"token punctuation\">,</span>\n          eagerState<span class=\"token operator\">:</span> update<span class=\"token punctuation\">.</span>eagerState<span class=\"token punctuation\">,</span>\n          next<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 현재 커밋을 Rebase 대상으로 추가한다.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newBaseQueueLast <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// 병합되지 못한 첫 번째 커밋이다. 해당 커밋을 포함하여 이후 모든 커밋이 Rebase 대상이 된다.</span>\n          newBaseQueueFirst <span class=\"token operator\">=</span> newBaseQueueLast <span class=\"token operator\">=</span> clone\n          <span class=\"token comment\">// Rebase 대상 이전까지 병합된 코드를 기록한다.</span>\n          newBaseState <span class=\"token operator\">=</span> newState\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          newBaseQueueLast <span class=\"token operator\">=</span> newBaseQueueLast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> clone\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 추후에 다시 배포해야 하기 때문에 배포되지 않은 버전을 기록한다.</span>\n        currentlyRenderingFiber<span class=\"token punctuation\">.</span>lanes <span class=\"token operator\">=</span> <span class=\"token function\">mergeLanes</span><span class=\"token punctuation\">(</span>\n          currentlyRenderingFiber<span class=\"token punctuation\">.</span>lanes<span class=\"token punctuation\">,</span>\n          updateLane\n        <span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 병합될 커밋이다.</span>\n\n        <span class=\"token comment\">// 이번 배포에서 Rebase 대상이 존재하는지 확인한다. 존재한다면 커밋 순서를 맞추기 위해 모든 커밋을 Rebase 대상으로 추가한다.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newBaseQueueLast <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> clone <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 이미 배포된 커밋은 추후 Rebase 과정에서 항상 포함될 수 있도록 NoLane(0)을 할당한다.</span>\n            lane<span class=\"token operator\">:</span> NoLane<span class=\"token punctuation\">,</span>\n            action<span class=\"token operator\">:</span> update<span class=\"token punctuation\">.</span>action<span class=\"token punctuation\">,</span>\n            hasEagerState<span class=\"token operator\">:</span> update<span class=\"token punctuation\">.</span>hasEagerState<span class=\"token punctuation\">,</span>\n            eagerState<span class=\"token operator\">:</span> update<span class=\"token punctuation\">.</span>eagerState<span class=\"token punctuation\">,</span>\n            next<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n          <span class=\"token punctuation\">}</span>\n          newBaseQueueLast <span class=\"token operator\">=</span> newBaseQueueLast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> clone\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 병합을 진행하고 코드를 뽑아낸다.</span>\n        <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action\n        newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span> <span class=\"token comment\">// typeof action === 'function' ? action(newState) : action;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 다음 병합 대상을 참조한다.</span>\n      update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next\n      <span class=\"token comment\">// 원형 연결 리스트이기 때문에 무한 루프에 빠지지 않도록 첫 번째 노드를 확인한다.</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> update <span class=\"token operator\">!==</span> first<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// Rebase 대상이 있는지 확인한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newBaseQueueLast <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Rebase 대상이 없다는 것은 Fast Forward Merge로 진행되었다는 의미이다.</span>\n      newBaseState <span class=\"token operator\">=</span> newState\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 병합되지 못한 커밋이 있다. 원형 연결 리스트로 관리한다.</span>\n      newBaseQueueLast<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newBaseQueueFirst\n    <span class=\"token punctuation\">}</span>\n\n    hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState <span class=\"token comment\">// Main 브랜치의 최종 코드, Rebase 대상이 존재한다면 중간 상태의 코드가 된다.</span>\n    hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> newBaseState <span class=\"token comment\">// 병합되지 못한 첫 번째 커밋 직전의 병합된 코드. 만약 모두 병합되었다면 memoizedState와 같다.</span>\n    hook<span class=\"token punctuation\">.</span>baseQueue <span class=\"token operator\">=</span> newBaseQueueLast <span class=\"token comment\">// Rebase 대상을 병합 대상으로 관리한다.</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 한가지 짚고 넘어가고 싶은 부분은 얕은 복사로 <code class=\"language-text\">clone</code> 객체를 만드는 부분입니다.<br>\nConcurrent Rendering이 가능해지면서 컴포넌트가 여러 번 호출될 수 있고 때로는 호출된 결과를 폐기할 때도 있습니다. 얕은 복사를 하지 않고 작업해버리면 의존성이 없는 렌더링 간의 영향을 줄 수 있기 때문에 반드시 작업 이전에 객체를 얕은 복사 해야 합니다.</p>\n</details>\n<h1 id=\"suspense-vs-suspense--transition\" style=\"position:relative;\"><a href=\"#suspense-vs-suspense--transition\" aria-label=\"suspense vs suspense  transition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>&#x3C;Suspense/> vs &#x3C;Suspense/> + Transition</h1>\n<p><code class=\"language-text\">&lt;Suspense/></code>는 Fallback을 노출하여 렌더링을 완료하는 반면에 <code class=\"language-text\">&lt;Suspense/></code> + Transition은 네트워크 요청과 전환이 모두 완료되기 전까지 렌더링을 보류했습니다. 이 둘의 쓰임새는 다르며 이를 이해하는 것이 중요하기 때문에 짚고 넘어가겠습니다.</p>\n<p>다음 동영상은 구글맵을 사용하는 영상입니다. 당연히 리액트로 개발된 것은 아니겠지만, 영상에 나오는 UI의 동작은 <code class=\"language-text\">&lt;Suspense/></code>와 <code class=\"language-text\">&lt;Suspense/></code> + Transition의 그것과 같습니다. 한번 구별해보시고 사용자 관점에서 느껴보시길 바랍니다.</p>\n<video controls height=\"500px\">\n <source src=\"/path/to/dir/ae09b232e44b8614658f537ec5a11117/play_googlemap.mp4\" type=\"video/mp4\" />\n</video>\n<p>자동 완성 UI는 <code class=\"language-text\">&lt;Suspense/></code> + Transition이고, 경로 UI는 <code class=\"language-text\">&lt;Suspense/></code>입니다. 두 UI에는 어떠한 차이점이 있기 때문에 이런 구현상의 차이가 있는 것일까요? <code class=\"language-text\">&lt;Suspense/></code>만 사용해도 대부분의 전환에 대해 잘 작동하지만, 특정 상황에서는 그렇지 않습니다.</p>\n<p>전환이 매우 짧은 시간 안에 끝난다면 사용자는 이런 찰나의 전환에서 요청과 관련된 피드백을 인지하기도 전에 전환이 완료되어 UI가 크게 요동치는 느낌을 받을 수 있습니다. 리액트에서 이런 찰나의 순간의 임계값을 JND(Just Signable Difference)라고 합니다.</p>\n<img src=\"/path/to/dir/8fb75ec49314ffac5b8b602ba6a84407/case_suspense.gif\">\n<p>만약 전환이 JND 아래에 머물 수 있다면 사용자 경험을 위해 <code class=\"language-text\">&lt;Suspense/></code>의 Fallback을 건너뛸 가치가 있습니다. 전환이 항상 사용자가 알아채지 못할 정도로 지연 시간이 작다는 것을 보장할 수 있다면 말입니다. 이런 경우 트리의 일관성을 포기하고 이전 상태의 화면을 유지하면서 Fallback을 생략하는 방법을 선택할 수 있습니다.</p>\n<img src=\"/path/to/dir/0ed117858aabf9e797dd86ba62a9fdb1/case_suspense_transition.gif\">\n<blockquote>\n<p><code class=\"language-text\">&lt;Suspense/></code>만 사용한 경우에도 JND 아래에 위치한다면 Fallback을 생략할 수 있도록 하려는 움직임이 있습니다. 아직 실험 단계이며 <code class=\"language-text\">&lt;Suspense/></code>의 expectedLoadTime 속성으로 개발 중에 있습니다.</p>\n</blockquote>\n<p>그렇다고 전환이 찰나의 순간이 아니라면 무조건 <code class=\"language-text\">&lt;Suspense/></code>를 써야 한다고 이야기 하는게 아닙니다. JND보다 큰 지연에도 오래된 상태의 UI를 유지하는 게 더 나은 경우도 많습니다. 이때는 Fallback과 마찬가지로 지연 상태에 대한 피드백을 사용자에게 전달해야 하며, <code class=\"language-text\">startTransition</code> API의 <code class=\"language-text\">isPending</code> 속성을 활용할 수 있습니다(<a href=\"https://github.com/reactwg/react-18/discussions/65\" target=\"blank\">참고</a>).</p>\n<video controls height=\"500px\">\n <source src=\"/path/to/dir/39c738ac00c5d2b988fe2ddd056513e9/is_pending.mp4\" type=\"video/mp4\" />\n</video>\n<blockquote>\n<p>차트 영역의 색상을 수정하여 사용자에게 지연 상태를 피드백하고 있다.</p>\n</blockquote>\n<h1 id=\"usetransition-vs-starttransition\" style=\"position:relative;\"><a href=\"#usetransition-vs-starttransition\" aria-label=\"usetransition vs starttransition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useTransition vs startTransition</h1>\n<p>전환 업데이트를 생성하는 방법은 두 가지가 있으며, 둘의 차이점은 쓰임새에 있습니다. 그리고 이 쓰임새로 인한 성능 차이도 존재하기 때문에 알고 쓰는 게 중요합니다. <strong>case 9</strong>에서 확인해보세요.</p>\n<iframe src=\"https://codesandbox.io/embed/use-case-u928zv?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&module=%2Fuse-cases%2Fcase_9.js&runonclick=1\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"use-case\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>최종 렌더링까지 걸린 시간을 비교하면 <code class=\"language-text\">useTransition()</code>가 대략 1초 정도 더 느리며, 원인은 <code class=\"language-text\">isPending</code>에 있습니다. <code class=\"language-text\">isPending</code>은 전환의 시작과 끝을 알려주는 변수입니다. 그렇기 때문에 전환 업데이트보다 먼저 렌더링을 진행하여 <code class=\"language-text\">isPending</code>의 상태를 반영해야 합니다. 그리고 난 후에 <code class=\"language-text\">isPending</code>을 활용하여 피드백 UI를 렌더링하는 것입니다. 즉, <code class=\"language-text\">useTransition()</code>는 <code class=\"language-text\">startTransition()</code> 보다 한 번의 Render Phase - Commit Phase가 더 필요합니다.</p>\n<blockquote>\n<p><strong>case 7</strong>에서는 <code class=\"language-text\">&lt;Bubble/></code>의 색상으로 이를 표현했습니다. 다만, <code class=\"language-text\">&lt;Bubble/></code>이 아닌 규모가 작은 UI에 이를 표현했다면 성능의 차이점은 거의 없었을 것이지만, 이와 같이 사용되는 경우도 있기에 눈에 띄는 방식으로 작성했습니다.</p>\n</blockquote>\n<p><code class=\"language-text\">useTransition()</code>의 세부 구현사항은 다음과 같습니다.</p>\n<blockquote>\n<p><code class=\"language-text\">startTransition()</code>의 구현사항은 이미 <a href=\"http://localhost:8000/react/in-depth-react18-lane/#%EC%A0%84%ED%99%98-%EC%9D%B4%EB%B2%A4%ED%8A%B8\" target=\"blank\">Lane 모델</a>에서 확인했습니다.</p>\n</blockquote>\n<p><a class=\"code_link\" target=\"blink\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L2049-L2059\">reconciler > ReactFiberHooks.js</a></p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">\u001c\n<span class=\"token keyword\">function</span> <span class=\"token function\">mountTransition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 컴포넌트 Mount 시점에 사용되는 useTransition() 구현체</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isPending<span class=\"token punctuation\">,</span> setPending<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">mountState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">const</span> start <span class=\"token operator\">=</span> <span class=\"token function\">startTransition</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> setPending<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>isPending<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a class=\"code_link_3\" target=\"blink\" href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L2002-L2047\">reconciler > ReactFiberHooks.js</a></p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre style=\"counter-reset: linenumber 0\" class=\"language-js line-numbers\"><code class=\"language-js\">\u001c\n<span class=\"token keyword\">function</span> <span class=\"token function\">startTransition</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">setPending<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token function\">setPending</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">const</span> prevTransition <span class=\"token operator\">=</span> ReactCurrentBatchConfig<span class=\"token punctuation\">.</span>transition<span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">  ReactCurrentBatchConfig<span class=\"token punctuation\">.</span>transition <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">setPending</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    ReactCurrentBatchConfig<span class=\"token punctuation\">.</span>transition <span class=\"token operator\">=</span> prevTransition<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>개발자가 <code class=\"language-text\">mountTransition()</code>이 반환하는 <code class=\"language-text\">start()</code>를 통해 전환 업데이트를 생성하면 먼저 <code class=\"language-text\">isPending</code>를 true로 설정<up>3</up>하는 업데이트가 생성됩니다. 이때 업데이트의 우선순위(Lane)는 <code class=\"language-text\">start()</code>를 호출한 이벤트를 기반으로 결정됩니다. <strong>case 7</strong>에서는 <code class=\"language-text\">setTimeout()</code>에서 사용했기 때문에 <code class=\"language-text\">Default Lane</code>이 할당됩니다.</p>\n<p>그 다음으로 Transition 플래그를 세우고<up>6</up> 난 후 <code class=\"language-text\">isPending</code>을 false<up>9</up>, 개발자의 전환 업데이트를 생성할 <code class=\"language-text\">callback()</code>을 실행<up>10</up>시켜 모두 전환 업데이트로 생성합니다. 지금까지 생성된 업데이트는 리액트가 의도적으로 생성한 업데이트 두 개와 <code class=\"language-text\">callback()</code>으로 생성한 업데이트가 있으며, 렌더링 대기 중인 상태입니다.</p>\n<p>여기서 우선순위가 가장 높은 건 전환 플래그를 세우기 전에 생성한 <code class=\"language-text\">isPending</code>을 true로 변경하는 업데이트입니다. 해당 렌더링이 완료되면 지연 피드백 UI가 사용자에게 노출됩니다. 이어서 전환 업데이트의 렌더링이 진행될 때는 이미 <code class=\"language-text\">isPending</code>를 false로 변경하는 업데이트도 같이 배치처리 되기 때문에 자연스레 지연 피드백 UI는 미적용된 상태로 전환 UI를 렌더링하게 됩니다.</p>\n<hr>\n<p>리액트 18로 넘어오면서 리액트 어플리케이션에서 발생하는 업데이트를 이해하는 것이 중요해졌습니다. 앞으로 나올 신규 기능도 이런 업데이트의 개념이 밑바탕에 깔려있기 때문에 반드시 이해하고 넘어가면 좋겠습니다.</p>\n<p>다음은 Concurrent Render과 Sync Render에 대해서 알아볼 것입니다.</p>","frontmatter":{"title":"React 18 톺아보기 - 03. Transition Lane_2","date":"2023-05-02","keywords":["리액트","react","react 18","concurrent render","lane","lane model","transition","transition lane"]}}},"pageContext":{"slug":"/react/in-depth-react18-transition_2/","previous":{"fields":{"slug":"/react/in-depth-react18-transition_1/"},"frontmatter":{"title":"React 18 톺아보기 - 03. Transition Lane_1","category":"react"}},"next":{"fields":{"slug":"/react/in-depth-react18-concurrent_render/"},"frontmatter":{"title":"React 18 톺아보기 - 04. Concurrent Render","category":"react"}}}},"staticQueryHashes":["2277278352","536400264"]}