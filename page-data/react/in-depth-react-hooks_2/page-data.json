{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/in-depth-react-hooks_2/","result":{"data":{"site":{"siteMetadata":{"title":"Deep Dive Magic Code","author":"Goidle","comment":{"utterances":"goidle/goidle.github.io"}}},"markdownRemark":{"id":"af326ec3-7a9d-507d-be4d-f37b2d617f84","excerpt":"모든 설명은 v16.12.0 버전 함수형 컴포넌트와 브라우저 환경을 기준으로 합니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다. 3. 상태가 변경되어 리-렌더될 때 변경된 상태 값은 어떻게 가지고 오는 것일까? 3 - 1 상태를 담은 훅 객체 불러오기 컴포넌트 마운트 이후 우리가 작성한 useState()는 업데이트 구현체인 updateState()를 사용하게 됩니다. reconciler > ReactFiberHooks.js…","html":"<blockquote>\n<p>모든 설명은 v16.12.0 버전 함수형 컴포넌트와 브라우저 환경을 기준으로 합니다. 버전에 따라 코드는 변경될 수 있으며 클래스 컴포넌트는 설명에서 제외됨을 알려 드립니다.</p>\n</blockquote>\n<h1 id=\"3-상태가-변경되어-리-렌더될-때-변경된-상태-값은-어떻게-가지고-오는-것일까\" style=\"position:relative;\"><a href=\"#3-%EC%83%81%ED%83%9C%EA%B0%80-%EB%B3%80%EA%B2%BD%EB%90%98%EC%96%B4-%EB%A6%AC-%EB%A0%8C%EB%8D%94%EB%90%A0-%EB%95%8C-%EB%B3%80%EA%B2%BD%EB%90%9C-%EC%83%81%ED%83%9C-%EA%B0%92%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%98%A4%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C\" aria-label=\"3 상태가 변경되어 리 렌더될 때 변경된 상태 값은 어떻게 가지고 오는 것일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 상태가 변경되어 리-렌더될 때 변경된 상태 값은 어떻게 가지고 오는 것일까?</h1>\n<h2 id=\"3---1-상태를-담은-훅-객체-불러오기\" style=\"position:relative;\"><a href=\"#3---1-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%8B%B4%EC%9D%80-%ED%9B%85-%EA%B0%9D%EC%B2%B4-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0\" aria-label=\"3   1 상태를 담은 훅 객체 불러오기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 - 1 상태를 담은 훅 객체 불러오기</h2>\n<p>컴포넌트 마운트 이후 우리가 작성한 useState()는 업데이트 구현체인 updateState()를 사용하게 됩니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L848\" target=\"_blank\" class=\"code_link\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initialState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span>basicStateReducer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">updateState()</code>는 그저 <code class=\"language-text\">updateReducer()</code>로 포워딩하는 함수입니다. 그리고 이름에서 알 수 있듯이 updateReducer()는 useReducer()의 업데이트 구현체입니다. useState()와 useReducer()의 차이점은 내부에서 action을 소비하는 리듀서를 외부에서 주입할 수 있느냐?입니다.</p>\n<p>업데이트 구현체가 해야 할 일은 이전에 만들어놓았던 훅을 다시 불러오는 것입니다. 그리고 훅의 queue에 담겨있는 update를 소비하여 최종 상태 값을 구해야 합니다. 이 동작은 useState(), useReducer()의 훅 객체마다 행해지는데 이 과정에서 진행 상황을 훅 객체의 <a href=\"/react/in-depth-react-hooks_1#hook_object\" target=\"_blank\">baseUpdate와 baseState</a>에 기입하게 됩니다.</p>\n<p>문제는 여러가지 이유로 컴포넌트 렌더링을 취소해야 될 경우가 있습니다. 이를 대비하기 위해 fiber의 workInProgress 처럼 훅 객체 또한 작업용 훅을 만들어 사용합니다.</p>\n<p>가장 먼저 마운트는 객체를 생성했다면 업데이트는 기존 훅을 작업용 훅으로 생성해야 합니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L679\" target=\"_blank\" class=\"code_link\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<anchor id=\"updateWorkInProgressHook\">\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L593\" target=\"_blank\" class=\"code_link_6\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextWorkInProgressHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Render phase update로 인해 재호출될 경우 아래에서 만들어논 객체를 재사용..</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    currentHook <span class=\"token operator\">=</span> nextCurrentHook\n    <span class=\"token comment\">// 작업용 훅 객체를 만든다.</span>\n    <span class=\"token keyword\">const</span> <span class=\"token literal-property property\">newHook</span><span class=\"token operator\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">memoizedState</span><span class=\"token operator\">:</span> currentHook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span>\n\n      <span class=\"token literal-property property\">baseState</span><span class=\"token operator\">:</span> currentHook<span class=\"token punctuation\">.</span>baseState<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">queue</span><span class=\"token operator\">:</span> currentHook<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">baseUpdate</span><span class=\"token operator\">:</span> currentHook<span class=\"token punctuation\">.</span>baseUpdate<span class=\"token punctuation\">,</span>\n\n      <span class=\"token literal-property property\">next</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// This is the first hook in the list.</span>\n      workInProgressHook <span class=\"token operator\">=</span> firstWorkInProgressHook <span class=\"token operator\">=</span> newHook\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Append to the end of the list.</span>\n      workInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newHook\n    <span class=\"token punctuation\">}</span>\n    nextCurrentHook <span class=\"token operator\">=</span> currentHook<span class=\"token punctuation\">.</span>next\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">nextWorkInProgressHook</code>와 <code class=\"language-text\">nextCurrentHook</code>가 무엇을 뜻하는지 기억 안날 경우 renderWithHooks()의 <a href=\"/react/in-depth-react-hooks_1#renderWithHooks_2\" target=\"_blank\">Render phase update로 인한 호출 로직</a>과 <a href=\"/react/in-depth-react-hooks_1#renderWithHooks\" target=\"_blank\">일반 호출 로직</a>을 다시 확인해보고 오세요.</p>\n</blockquote>\n<p>Render phase update는 언제든지 자주 발생할 수 있습니다. 이때 매번 작업용 객체를 생성한다면 비효율적이므로 첫 컴포넌트 호출에서 만들어놓은 것을 재사용합니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L599\" target=\"_blank\" class=\"code_link\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextWorkInProgressHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 재사용</span>\n    workInProgressHook <span class=\"token operator\">=</span> nextWorkInProgressHook\n    nextWorkInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next\n    <span class=\"token comment\">// current hook</span>\n    currentHook <span class=\"token operator\">=</span> nextCurrentHook\n    nextCurrentHook <span class=\"token operator\">=</span> currentHook <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> currentHook<span class=\"token punctuation\">.</span>next <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/* 작업용 훅 객체 생성.. */</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> workInProgressHook\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"진행-상황-기록하기\" style=\"position:relative;\"><a href=\"#%EC%A7%84%ED%96%89-%EC%83%81%ED%99%A9-%EA%B8%B0%EB%A1%9D%ED%95%98%EA%B8%B0\" aria-label=\"진행 상황 기록하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진행 상황 기록하기</h3>\n<p>훅 객체를 만들 때 설명을 생략했던 baseUpdate와 baseState, 그리고 update가 왜 <em>Circular Linked List</em>인지 알아볼 시점이 왔습니다. 잠시 해당 부분만 뜯어오겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">memoizedState</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">queue</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">next</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">baseState</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">baseUpdate</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>last\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  update<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> last<span class=\"token punctuation\">.</span>next\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    update<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> first\n  <span class=\"token punctuation\">}</span>\n  last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> update\n<span class=\"token punctuation\">}</span>\nqueue<span class=\"token punctuation\">.</span>last <span class=\"token operator\">=</span> update</code></pre></div>\n<h4 id=\"baseupdate-basestate\" style=\"position:relative;\"><a href=\"#baseupdate-basestate\" aria-label=\"baseupdate basestate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>baseUpdate, baseState</h4>\n<p>훅과 queue에 대해 좀 더 깊게 생각해 봅시다.</p>\n<p>컴포넌트의 상태를 변경하기 위해 훅 setState()를 호출하면 update는 queue에 연결 리스트로 추가됩니다. 그리고 컴포넌트 재호출 시 queue에서 update를 꺼내와 소비합니다. 문제는 update를 소비할 때 항상 head부터 시작하게 된다면 이미 소비된 update를 중복으로 처리하게 됩니다.</p>\n<p>그래서 적용된 부분과 아직 적용되지 않은 부분의 경계선을 정해줄 필요가 있습니다. 그래야 이 경계선을 기준으로 적용되지 않은 부분의 update들만 소비할 수 있으며 이미 적용된, 더는 사용하지 않을 update를 건너뛰고 GC를 위해 참조도 끊어줄 수 있습니다.</p>\n<p>이 경계선에 대한 정보는 baseUpdate, baseState에 담기게 됩니다. baseUpdate는 마지막으로 적용된 update의 포인터이며 baseState는 baseUpdate를 소비한 결괏값입니다. 이제 이 baseUpdate를 기준으로 이후 노드들은 아직 적용되지 않은 update 리스트가 됩니다.</p>\n<h4 id=\"circular-linked-list\" style=\"position:relative;\"><a href=\"#circular-linked-list\" aria-label=\"circular linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Circular Linked List</h4>\n<p>근데 queue는 <code class=\"language-text\">last</code>를 통해 마지막 update만 참조하고 있습니다. 이러면 tail만 알 수 있지 head는 모릅니다.<br>\n잠깐, <em>“훅의 baseUpdate를 통해 아직 적용하지 않은 update를 알 수 있다고 하지 않았나요?”</em><br>\n맞습니다. 하지만 baseUpdate는 컴포넌트 재호출을 통해 한번은 update를 소비해야 훅에 기록됩니다. 그전까지는 head를 알 수 없습니다.</p>\n<p>이러한 이유로 컴포넌트의 첫 업데이트가 발생하기 전까지는 head를 어딘가에서 물고 있어야 하며 update를 <em>Circular Linked List</em>로 만들어 tail update가 head 가리키도록 한 것입니다. 그리고 이 연결은 첫 업데이트 적용 시점에 끊어주게 됩니다.   </p>\n<p>update를 queue에 추가하는 코드를 보면 last.next의 존재 여부를 확인하는 코드가 바로 head를 훅의 baseUpdate로 물고 있는 것인지 아니면 아직도 tail update가 물고 있는지 확인하는 부분입니다.</p>\n<h2 id=\"3---2-update-소비하기\" style=\"position:relative;\"><a href=\"#3---2-update-%EC%86%8C%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"3   2 update 소비하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 - 2 update 소비하기</h2>\n<p>update를 소비할 때 두 가지 상황이 존재합니다. 하나는 유휴 상태에서 발생한 업데이트이며 또 다른 하나는 컴포넌트 호출 시점에서 발생한 Render phase update입니다. </p>\n<anchor id=\"updateReducer\" />\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L680\" target=\"_blank\" class=\"code_link\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// const hook = updateWorkInProgressHook();</span>\n\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>queue\n  queue<span class=\"token punctuation\">.</span>lastRenderedReducer <span class=\"token operator\">=</span> reducer <span class=\"token comment\">// useState()는 기본 리듀서인 basicStateReducer를 사용</span>\n  \n  <span class=\"token comment\">// Render phase update 판단</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numberOfReRenders <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/* Render phase update 소비.. */</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/* update 소비.. */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>Render phase update를 소비하는 부분은 마지막에 확인하도록 하겠습니다.</p>\n</blockquote>\n<p>이제 훅을 가지고 왔으니 queue에 있는 update를 적용할 차례입니다. 로직은 간단합니다.</p>\n<ol>\n<li>\n<p>적용할 update 리스트의 head를 가지고 온다.</p>\n<ol>\n<li>훅의 baseUpdate 또는 queue의 last.next</li>\n<li><em>Circular Linked List</em> 라면 더는 head를 물고 있을 필요가 없으므로 연결을 끊어준다.</li>\n</ol>\n</li>\n<li>update 리스트의 head부터 tail까지 차례로 리듀서에 action을 던져 결괏값을 취한다.</li>\n<li>update를 모두 소비했다면 최종 상태값을 저장한다.</li>\n</ol>\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L732\" target=\"_blank\" class=\"code_link_4\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n\n  <span class=\"token comment\">/*\n  if (numberOfReRenders > 0) {\n    Render phase update 소비..\n  }\n  */</span>\n \n  <span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>last\n  <span class=\"token keyword\">const</span> baseUpdate <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseUpdate\n  <span class=\"token keyword\">const</span> baseState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseState\n\n  <span class=\"token comment\">// 1. 적용시킬 update의 head를 가지고 온다.</span>\n  <span class=\"token keyword\">let</span> first\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>baseUpdate <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 1-2 연결을 끊는다.</span>\n    <span class=\"token punctuation\">}</span>\n    first <span class=\"token operator\">=</span> baseUpdate<span class=\"token punctuation\">.</span>next <span class=\"token comment\">// 1-1 baseUpdate의 head 참조</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    first <span class=\"token operator\">=</span> last <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token comment\">// 1-1 Circular Linked List의 head 참조</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 2. head부터 tail까지 차례로 리듀서에 action을 던져 결괏값을 취한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> baseState\n    <span class=\"token keyword\">let</span> prevUpdate <span class=\"token operator\">=</span> baseUpdate\n    <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> first\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action\n      newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span>\n      prevUpdate <span class=\"token operator\">=</span> update\n      update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> update <span class=\"token operator\">!==</span> first<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// 3. update를 모두 소비했다면 최종 상태값을 저장한다.</span>\n    hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState\n    hook<span class=\"token punctuation\">.</span>baseUpdate <span class=\"token operator\">=</span> prevUpdate <span class=\"token comment\">// 적용된 update의 tail pointer</span>\n    hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> newState <span class=\"token comment\">// baseUpdate의 결괏값</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>dispatch\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span> <span class=\"token comment\">// 최종 상태 값 반환</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>마지막으로 Render phase update 소비 로직을 확인하면서 마무리 하겠습니다.</p>\n<h2 id=\"3---3-render-phase-update-적용-시키기\" style=\"position:relative;\"><a href=\"#3---3-render-phase-update-%EC%A0%81%EC%9A%A9-%EC%8B%9C%ED%82%A4%EA%B8%B0\" aria-label=\"3   3 render phase update 적용 시키기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 - 3 Render phase update 적용 시키기</h2>\n<p>dispatchAction()은 자신이 호출될 때 Render phase가 진행 중이라면 update를 queue가 아닌 renderPhaseUpdates에 저장해두었으므로 queue가 아닌 맵에서 리스트를 꺼내 사용합니다.  update 소비 로직은 이전에 본 것과 크게 다르지 않으므로 별 다른 설명 없이 넘어가겠습니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberHooks.js#L688\" target=\"_blank\" class=\"code_link\">reconciler > ReactFiberHooks.js </a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  \n<span class=\"token keyword\">function</span> <span class=\"token function\">updateReducer</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reducer<span class=\"token punctuation\">,</span> initialArg<span class=\"token punctuation\">,</span> init</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*...*/</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numberOfReRenders <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>dispatch\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>renderPhaseUpdates <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> firstRenderPhaseUpdate <span class=\"token operator\">=</span> renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstRenderPhaseUpdate <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        renderPhaseUpdates<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">let</span> newState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState\n        <span class=\"token keyword\">let</span> update <span class=\"token operator\">=</span> firstRenderPhaseUpdate\n\n        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> action <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>action\n          newState <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>newState<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span>\n          update <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>next\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>update <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n  \n        hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> newState\n        queue<span class=\"token punctuation\">.</span>lastRenderedState <span class=\"token operator\">=</span> newState\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>newState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">/*...*/</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Render phase update는 queue에 추가되는 것이 아니므로 따로 baseUpdate에 tail update를 추가하는 작업은 필요 없습니다. </li>\n</ul>\n<p>useState()가 어떻게 함수형 컴포넌트의 상태를 관리하는지 알아보았습니다. 본의 아니게 useReducer()의 update 구현체도 함께 알아보았는데 useEffect()와 useLayoutEffect()는 <strong>reconciler</strong>를 분석하면서 확인하게 될 것이지만 이를 제외한 나머지 훅들은 다루지 않으므로 따로 직접 분석해 보시길 추천해 드립니다.</p>\n<p>다음 포스트는 dispatchAction()에게 전달받은 <strong>Work</strong>를 실행시켜 줄 <strong>scheduler</strong>입니다.</p>","frontmatter":{"title":"React 톺아보기 - 03. Hooks_2","date":"2020-10-11","keywords":["리액트","react","fiber","hook","hooks","useState","useEffect","useLayoutEffect","useCallback"]}}},"pageContext":{"slug":"/react/in-depth-react-hooks_2/","previous":{"fields":{"slug":"/react/in-depth-react-hooks_1/"},"frontmatter":{"title":"React 톺아보기 - 03. Hooks_1","category":"react"}},"next":{"fields":{"slug":"/react/in-depth-react-scheduler_1/"},"frontmatter":{"title":"React 톺아보기 - 04. Scheduler_1","category":"react"}}}},"staticQueryHashes":["2277278352","536400264"]}